{"version":3,"sources":["webpack:///sdk/dist/strophe-1.2.14.min.js","webpack:///webpack/bootstrap c9402f91bc3dfc2c1147?e414","webpack:///./sdk/dist/strophe-1.2.14.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","242","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","obj","constructor","prototype","root","factory","apply","undefined","requirejs","require","define","undef","hasProp","prop","hasOwn","normalize","name","baseName","nameParts","nameSegment","mapValue","foundMap","lastIndex","foundI","foundStarMap","starI","i","j","part","normalizedBaseParts","baseParts","split","map","config","starMap","length","nodeIdCompat","jsSuffixRegExp","test","replace","charAt","slice","concat","splice","join","makeRequire","relName","forceSync","args","aps","arguments","push","req","makeNormalize","makeLoad","depName","value","defined","callDep","waiting","defining","main","Error","splitPrefix","prefix","index","indexOf","substring","makeRelParts","makeConfig","makeMap","handlers","Object","hasOwnProperty","relParts","plugin","parts","relResourceName","f","n","pr","e","uri","deps","callback","cjsModule","ret","usingExports","callbackType","load","alt","setTimeout","cfg","_defined","amd","jQuery","this","Function","bind","func","_slice","Array","_concat","_args","isArray","arg","toString","elt","len","from","Number","Math","ceil","floor","forEach","thisArg","T","k","TypeError","O","kValue","keyStr","btoa","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","charCodeAt","isNaN","atob","String","fromCharCode","SHA1","core_sha1","x","t","olda","oldb","oldc","oldd","olde","w","a","b","d","rol","safe_add","sha1_ft","sha1_kt","core_hmac_sha1","key","data","bkey","str2binb","ipad","opad","hash","y","lsw","msw","num","cnt","str","bin","mask","binb2str","binb2b64","binarray","triplet","tab","b64_hmac_sha1","b64_sha1","s","str_hmac_sha1","str_sha1","MD5","bit_rol","str2binl","binl2str","binl2hex","hex_tab","md5_cmn","q","md5_ff","md5_gg","md5_hh","md5_ii","core_md5","hexdigest","stropheUtils","utils","utf16to8","out","addCookies","cookies","cookieName","cookieObj","isObj","cookieValue","expires","domain","path","escape","unescape","document","cookie","o","Strophe","$build","$iq","$msg","$pres","attrs","Builder","VERSION","NS","HTTPBIND","BOSH","CLIENT","AUTH","ROSTER","PROFILE","DISCO_INFO","DISCO_ITEMS","MUC","SASL","STREAM","FRAMING","BIND","SESSION","STANZAS","XHTML_IM","XHTML","tags","attributes","blockquote","br","cite","em","img","li","ol","span","strong","ul","body","css","validTag","tag","validAttribute","attribute","validCSS","style","Status","ERROR","CONNECTING","CONNFAIL","AUTHENTICATING","AUTHFAIL","CONNECTED","DISCONNECTED","DISCONNECTING","ATTACHED","REDIRECT","CONNTIMEOUT","LogLevel","DEBUG","INFO","WARN","FATAL","ElementType","NORMAL","TEXT","CDATA","FRAGMENT","TIMEOUT","SECONDARY_TIMEOUT","addNamespace","forEachChild","elem","elemName","childNode","childNodes","nodeType","isTagEqual","el","tagName","_xmlGenerator","_makeGenerator","doc","implementation","createDocument","documentMode","_getIEXmlDom","appendChild","createElement","xmlGenerator","docStrings","ActiveXObject","xmlElement","node","xmlTextNode","sort","attr","setAttribute","xmlescape","text","xmlunescape","createTextNode","xmlHtmlNode","html","DOMParser","parser","parseFromString","async","loadXML","getText","nodeValue","copyElement","nodeName","createHtml","cssAttrs","cssName","cssValue","toLowerCase","getAttribute","cssText","createDocumentFragment","escapeNode","unescapeNode","getNodeFromJid","jid","getDomainFromJid","bare","getBareJidFromJid","getResourceFromJid","_handleError","stack","fatal","sourceURL","handler","line","message","fileName","lineNumber","log","level","msg","debug","info","warn","error","serialize","result","tree","child","_requestId","_connectionPlugins","addConnectionPlugin","ptype","xmlns","nodeTree","up","parentNode","moreattrs","removeAttribute","cnode","impNode","xmlGen","importNode","newElem","h","fragment","innerHTML","xhtml","Handler","ns","type","options","matchBareFromJid","ignoreNamespaceFragment","matchBare","user","getNamespace","elNamespace","namespaceMatch","nsMatch","that","isMatch","elem_type","run","TimedHandler","period","lastCalled","Date","getTime","reset","Connection","service","proto","protocol","_proto","Websocket","Bosh","features","_sasl_data","do_session","do_bind","timedHandlers","removeTimeds","removeHandlers","addTimeds","addHandlers","protocolErrorHandlers","HTTP","websocket","_idleTimeout","_disconnectTimeout","authenticated","connected","disconnecting","do_authentication","paused","restored","_data","_uniqueId","_sasl_success_handler","_sasl_failure_handler","_sasl_challenge_handler","maxRetries","_onIdle","registerSASLMechanisms","mechanisms","F","init","_reset","_requests","pause","resume","getUniqueId","suffix","uuid","r","random","v","addProtocolErrorHandler","status_code","connect","pass","wait","hold","route","authcid","authzid","servtype","connect_callback","_changeConnectStatus","_connect","attach","sid","rid","wind","_attach","restore","_sessionCachingSupported","_restore","JSON","sessionStorage","setItem","removeItem","xmlInput","xmlOutput","rawInput","rawOutput","nextValidRid","send","_queueData","_send","flush","clearTimeout","sendPresence","errback","timeout","timeoutHandler","addHandler","stanza","deleteTimedHandler","addTimedHandler","deleteHandler","sendIQ","iqtype","element","_sendRestart","thand","handRef","hand","SASLAnonymous","SASLExternal","SASLMD5","SASLOAuthBearer","SASLPlain","SASLSHA1","registerSASLMechanism","mechanism","disconnect","reason","pres","_addSysTimedHandler","_onDisconnectTimeout","_disconnect","_abortAllRequests","_doDisconnect","status","condition","statusChanged","err","_dataRecv","raw","_reqToData","strip","pop","_emptyQueue","cond","conflict","getElementsByTagName","newList","_connect_cb","_callback","bodyWrap","conncheck","hasFeatures","getElementsByTagNameNS","_no_auth_received","mech","matched","authenticate","sortMechanismsByPriority","higher","swap","priority","_attemptSASLAuth","mechanism_found","_addSysHandler","_sasl_success_cb","_sasl_failure_cb","_sasl_challenge_cb","_sasl_mechanism","onStart","request_auth_exchange","isClientFirst","response","onChallenge","_attemptLegacyAuth","_auth1_cb","to","challenge","iq","_auth2_cb","serverSignature","success","attribMatch","matches","match","onSuccess","streamfeature_handlers","wrapper","_sasl_auth1_cb","_sasl_bind_cb","resource","jidNode","_sasl_session_cb","onFailure","since","now","SASLMechanism","connection","_connection","auth_str","test_cnonce","cnonce","nonce","salt","iter","Hi","U","U_old","clientKey","serverKey","clientSignature","responseText","authMessage","substr","_quote","realm","host","qop","digest_uri","cred","A1","A2","core","Request","sends","xmlData","origFunc","date","NaN","abort","dead","age","timeDead","xhr","_newXHR","getResponse","responseXML","documentElement","window","XMLHttpRequest","overrideMimeType","onreadystatechange","_conn","errors","inactivity","_buildBody","keepalive","_cacheSession","xml:lang","content","ver","xmpp:version","xmlns:xmpp","_onRequestStateChange","_throttledRequestHandler","session","parse","getItem","stringify","typ","parseInt","_sendTerminate","_callProtocolErrorHandlers","err_callback","reqStatus","_getRequestStatus","_hitError","xmpp:restart","time_elapsed","def","readyState","valid_request","too_many_retries","_removeRequest","reqIs0","reqIs1","_restartRequest","_processRequest","self","primaryTimeout","secondaryTimeout","requestCompletedWithServerError","contentType","open","sync","setRequestHeader","withCredentials","e2","sendFunc","customHeaders","headers","header","backoff","min","pow","abs","new_service","location","pathname","_buildStream","version","_check_streamerror","connectstatus","textContent","errorString","_closeSocket","socket","WebSocket","onopen","_onOpen","onerror","_onError","onclose","_onClose","onmessage","_connect_cb_wrapper","_handleStreamStart","streamStart","see_uri","string","_streamWrap","_onMessage","CLOSED","close","closeString","code","rawStanza","search","firstChild","start","startString"],"mappings":"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","file":"./sdk/dist/strophe-1.2.14.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(242);\n\n\n/***/ }),\n\n/***/ 242:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/** File: strophe.js\n\t *  A JavaScript library for writing XMPP clients.\n\t *\n\t *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)\n\t *  to emulate a persistent, stateful, two-way connection to an XMPP server or\n\t *  alternatively WebSockets.\n\t *\n\t *  More information on BOSH can be found in XEP 124.\n\t *  For more information on XMPP-over WebSocket see this RFC:\n\t *  http://tools.ietf.org/html/rfc7395\n\t */\n\t\n\t/* All of the Strophe globals are defined in this special function below so\n\t * that references to the globals become closures.  This will ensure that\n\t * on page reload, these references will still be available to callbacks\n\t * that are still executing.\n\t */\n\t\n\t/* jshint ignore:start */\n\t(function (root, factory) {\n\t    if (true) {\n\t        //Allow using this built library as an AMD module\n\t        //in another project. That other project will only\n\t        //see this AMD call, not the internal modules in\n\t        //the closure below.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else {\n\t        //Browser globals case.\n\t        var wrapper = factory();\n\t        root.Strophe = wrapper.Strophe;\n\t        root.$build = wrapper.$build;\n\t        root.$iq = wrapper.$iq;\n\t        root.$msg = wrapper.$msg;\n\t        root.$pres = wrapper.$pres;\n\t        root.SHA1 = wrapper.SHA1;\n\t        root.MD5 = wrapper.MD5;\n\t        root.b64_hmac_sha1 = wrapper.b64_hmac_sha1;\n\t        root.b64_sha1 = wrapper.b64_sha1;\n\t        root.str_hmac_sha1 = wrapper.str_hmac_sha1;\n\t        root.str_sha1 = wrapper.str_sha1;\n\t    }\n\t})(undefined, function () {\n\t    //almond, and your modules will be inlined here\n\t    /* jshint ignore:end */\n\t    /**\n\t     * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\n\t     * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n\t     */\n\t    //Going sloppy to avoid 'use strict' string cost, but strict practices should\n\t    //be followed.\n\t    /*global setTimeout: false */\n\t\n\t    var requirejs, require, define;\n\t    (function (undef) {\n\t        var main,\n\t            _req,\n\t            makeMap,\n\t            handlers,\n\t            defined = {},\n\t            waiting = {},\n\t            config = {},\n\t            defining = {},\n\t            hasOwn = Object.prototype.hasOwnProperty,\n\t            aps = [].slice,\n\t            jsSuffixRegExp = /\\.js$/;\n\t\n\t        function hasProp(obj, prop) {\n\t            return hasOwn.call(obj, prop);\n\t        }\n\t\n\t        /**\n\t         * Given a relative module name, like ./something, normalize it to\n\t         * a real name that can be mapped to a path.\n\t         * @param {String} name the relative name\n\t         * @param {String} baseName a real name that the name arg is relative\n\t         * to.\n\t         * @returns {String} normalized name\n\t         */\n\t        function normalize(name, baseName) {\n\t            var nameParts,\n\t                nameSegment,\n\t                mapValue,\n\t                foundMap,\n\t                lastIndex,\n\t                foundI,\n\t                foundStarMap,\n\t                starI,\n\t                i,\n\t                j,\n\t                part,\n\t                normalizedBaseParts,\n\t                baseParts = baseName && baseName.split(\"/\"),\n\t                map = config.map,\n\t                starMap = map && map['*'] || {};\n\t\n\t            //Adjust any relative paths.\n\t            if (name) {\n\t                name = name.split('/');\n\t                lastIndex = name.length - 1;\n\t\n\t                // If wanting node ID compatibility, strip .js from end\n\t                // of IDs. Have to do this here, and not in nameToUrl\n\t                // because node allows either .js or non .js to map\n\t                // to same file.\n\t                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n\t                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n\t                }\n\t\n\t                // Starts with a '.' so need the baseName\n\t                if (name[0].charAt(0) === '.' && baseParts) {\n\t                    //Convert baseName to array, and lop off the last part,\n\t                    //so that . matches that 'directory' and not name of the baseName's\n\t                    //module. For instance, baseName of 'one/two/three', maps to\n\t                    //'one/two/three.js', but we want the directory, 'one/two' for\n\t                    //this normalization.\n\t                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n\t                    name = normalizedBaseParts.concat(name);\n\t                }\n\t\n\t                //start trimDots\n\t                for (i = 0; i < name.length; i++) {\n\t                    part = name[i];\n\t                    if (part === '.') {\n\t                        name.splice(i, 1);\n\t                        i -= 1;\n\t                    } else if (part === '..') {\n\t                        // If at the start, or previous value is still ..,\n\t                        // keep them so that when converted to a path it may\n\t                        // still work when converted to a path, even though\n\t                        // as an ID it is less than ideal. In larger point\n\t                        // releases, may be better to just kick out an error.\n\t                        if (i === 0 || i === 1 && name[2] === '..' || name[i - 1] === '..') {\n\t                            continue;\n\t                        } else if (i > 0) {\n\t                            name.splice(i - 1, 2);\n\t                            i -= 2;\n\t                        }\n\t                    }\n\t                }\n\t                //end trimDots\n\t\n\t                name = name.join('/');\n\t            }\n\t\n\t            //Apply map config if available.\n\t            if ((baseParts || starMap) && map) {\n\t                nameParts = name.split('/');\n\t\n\t                for (i = nameParts.length; i > 0; i -= 1) {\n\t                    nameSegment = nameParts.slice(0, i).join(\"/\");\n\t\n\t                    if (baseParts) {\n\t                        //Find the longest baseName segment match in the config.\n\t                        //So, do joins on the biggest to smallest lengths of baseParts.\n\t                        for (j = baseParts.length; j > 0; j -= 1) {\n\t                            mapValue = map[baseParts.slice(0, j).join('/')];\n\t\n\t                            //baseName segment has  config, find if it has one for\n\t                            //this name.\n\t                            if (mapValue) {\n\t                                mapValue = mapValue[nameSegment];\n\t                                if (mapValue) {\n\t                                    //Match, update name to the new value.\n\t                                    foundMap = mapValue;\n\t                                    foundI = i;\n\t                                    break;\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (foundMap) {\n\t                        break;\n\t                    }\n\t\n\t                    //Check for a star map match, but just hold on to it,\n\t                    //if there is a shorter segment match later in a matching\n\t                    //config, then favor over this star map.\n\t                    if (!foundStarMap && starMap && starMap[nameSegment]) {\n\t                        foundStarMap = starMap[nameSegment];\n\t                        starI = i;\n\t                    }\n\t                }\n\t\n\t                if (!foundMap && foundStarMap) {\n\t                    foundMap = foundStarMap;\n\t                    foundI = starI;\n\t                }\n\t\n\t                if (foundMap) {\n\t                    nameParts.splice(0, foundI, foundMap);\n\t                    name = nameParts.join('/');\n\t                }\n\t            }\n\t\n\t            return name;\n\t        }\n\t\n\t        function makeRequire(relName, forceSync) {\n\t            return function () {\n\t                //A version of a require function that passes a moduleName\n\t                //value for items that may need to\n\t                //look up paths relative to the moduleName\n\t                var args = aps.call(arguments, 0);\n\t\n\t                //If first arg is not require('string'), and there is only\n\t                //one arg, it is the array form without a callback. Insert\n\t                //a null so that the following concat is correct.\n\t                if (typeof args[0] !== 'string' && args.length === 1) {\n\t                    args.push(null);\n\t                }\n\t                return _req.apply(undef, args.concat([relName, forceSync]));\n\t            };\n\t        }\n\t\n\t        function makeNormalize(relName) {\n\t            return function (name) {\n\t                return normalize(name, relName);\n\t            };\n\t        }\n\t\n\t        function makeLoad(depName) {\n\t            return function (value) {\n\t                defined[depName] = value;\n\t            };\n\t        }\n\t\n\t        function callDep(name) {\n\t            if (hasProp(waiting, name)) {\n\t                var args = waiting[name];\n\t                delete waiting[name];\n\t                defining[name] = true;\n\t                main.apply(undef, args);\n\t            }\n\t\n\t            if (!hasProp(defined, name) && !hasProp(defining, name)) {\n\t                throw new Error('No ' + name);\n\t            }\n\t            return defined[name];\n\t        }\n\t\n\t        //Turns a plugin!resource to [plugin, resource]\n\t        //with the plugin being undefined if the name\n\t        //did not have a plugin prefix.\n\t        function splitPrefix(name) {\n\t            var prefix,\n\t                index = name ? name.indexOf('!') : -1;\n\t            if (index > -1) {\n\t                prefix = name.substring(0, index);\n\t                name = name.substring(index + 1, name.length);\n\t            }\n\t            return [prefix, name];\n\t        }\n\t\n\t        //Creates a parts array for a relName where first part is plugin ID,\n\t        //second part is resource ID. Assumes relName has already been normalized.\n\t        function makeRelParts(relName) {\n\t            return relName ? splitPrefix(relName) : [];\n\t        }\n\t\n\t        /**\n\t         * Makes a name map, normalizing the name, and using a plugin\n\t         * for normalization if necessary. Grabs a ref to plugin\n\t         * too, as an optimization.\n\t         */\n\t        makeMap = function makeMap(name, relParts) {\n\t            var plugin,\n\t                parts = splitPrefix(name),\n\t                prefix = parts[0],\n\t                relResourceName = relParts[1];\n\t\n\t            name = parts[1];\n\t\n\t            if (prefix) {\n\t                prefix = normalize(prefix, relResourceName);\n\t                plugin = callDep(prefix);\n\t            }\n\t\n\t            //Normalize according\n\t            if (prefix) {\n\t                if (plugin && plugin.normalize) {\n\t                    name = plugin.normalize(name, makeNormalize(relResourceName));\n\t                } else {\n\t                    name = normalize(name, relResourceName);\n\t                }\n\t            } else {\n\t                name = normalize(name, relResourceName);\n\t                parts = splitPrefix(name);\n\t                prefix = parts[0];\n\t                name = parts[1];\n\t                if (prefix) {\n\t                    plugin = callDep(prefix);\n\t                }\n\t            }\n\t\n\t            //Using ridiculous property names for space reasons\n\t            return {\n\t                f: prefix ? prefix + '!' + name : name, //fullName\n\t                n: name,\n\t                pr: prefix,\n\t                p: plugin\n\t            };\n\t        };\n\t\n\t        function makeConfig(name) {\n\t            return function () {\n\t                return config && config.config && config.config[name] || {};\n\t            };\n\t        }\n\t\n\t        handlers = {\n\t            require: function require(name) {\n\t                return makeRequire(name);\n\t            },\n\t            exports: function exports(name) {\n\t                var e = defined[name];\n\t                if (typeof e !== 'undefined') {\n\t                    return e;\n\t                } else {\n\t                    return defined[name] = {};\n\t                }\n\t            },\n\t            module: function module(name) {\n\t                return {\n\t                    id: name,\n\t                    uri: '',\n\t                    exports: defined[name],\n\t                    config: makeConfig(name)\n\t                };\n\t            }\n\t        };\n\t\n\t        main = function main(name, deps, callback, relName) {\n\t            var cjsModule,\n\t                depName,\n\t                ret,\n\t                map,\n\t                i,\n\t                relParts,\n\t                args = [],\n\t                callbackType = typeof callback === 'undefined' ? 'undefined' : _typeof(callback),\n\t                usingExports;\n\t\n\t            //Use name if no relName\n\t            relName = relName || name;\n\t            relParts = makeRelParts(relName);\n\t\n\t            //Call the callback to define the module, if necessary.\n\t            if (callbackType === 'undefined' || callbackType === 'function') {\n\t                //Pull out the defined dependencies and pass the ordered\n\t                //values to the callback.\n\t                //Default to [require, exports, module] if no deps\n\t                deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n\t                for (i = 0; i < deps.length; i += 1) {\n\t                    map = makeMap(deps[i], relParts);\n\t                    depName = map.f;\n\t\n\t                    //Fast path CommonJS standard dependencies.\n\t                    if (depName === \"require\") {\n\t                        args[i] = handlers.require(name);\n\t                    } else if (depName === \"exports\") {\n\t                        //CommonJS module spec 1.1\n\t                        args[i] = handlers.exports(name);\n\t                        usingExports = true;\n\t                    } else if (depName === \"module\") {\n\t                        //CommonJS module spec 1.1\n\t                        cjsModule = args[i] = handlers.module(name);\n\t                    } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {\n\t                        args[i] = callDep(depName);\n\t                    } else if (map.p) {\n\t                        map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n\t                        args[i] = defined[depName];\n\t                    } else {\n\t                        throw new Error(name + ' missing ' + depName);\n\t                    }\n\t                }\n\t\n\t                ret = callback ? callback.apply(defined[name], args) : undefined;\n\t\n\t                if (name) {\n\t                    //If setting exports via \"module\" is in play,\n\t                    //favor that over return value and exports. After that,\n\t                    //favor a non-undefined return value over exports use.\n\t                    if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {\n\t                        defined[name] = cjsModule.exports;\n\t                    } else if (ret !== undef || !usingExports) {\n\t                        //Use the return value from the function.\n\t                        defined[name] = ret;\n\t                    }\n\t                }\n\t            } else if (name) {\n\t                //May just be an object definition for the module. Only\n\t                //worry about defining if have a module name.\n\t                defined[name] = callback;\n\t            }\n\t        };\n\t\n\t        requirejs = require = _req = function req(deps, callback, relName, forceSync, alt) {\n\t            if (typeof deps === \"string\") {\n\t                if (handlers[deps]) {\n\t                    //callback in this case is really relName\n\t                    return handlers[deps](callback);\n\t                }\n\t                //Just return the module wanted. In this scenario, the\n\t                //deps arg is the module name, and second arg (if passed)\n\t                //is just the relName.\n\t                //Normalize module name, if it contains . or ..\n\t                return callDep(makeMap(deps, makeRelParts(callback)).f);\n\t            } else if (!deps.splice) {\n\t                //deps is a config object, not an array.\n\t                config = deps;\n\t                if (config.deps) {\n\t                    _req(config.deps, config.callback);\n\t                }\n\t                if (!callback) {\n\t                    return;\n\t                }\n\t\n\t                if (callback.splice) {\n\t                    //callback is an array, which means it is a dependency list.\n\t                    //Adjust args if there are dependencies\n\t                    deps = callback;\n\t                    callback = relName;\n\t                    relName = null;\n\t                } else {\n\t                    deps = undef;\n\t                }\n\t            }\n\t\n\t            //Support require(['a'])\n\t            callback = callback || function () {};\n\t\n\t            //If relName is a function, it is an errback handler,\n\t            //so remove it.\n\t            if (typeof relName === 'function') {\n\t                relName = forceSync;\n\t                forceSync = alt;\n\t            }\n\t\n\t            //Simulate async callback;\n\t            if (forceSync) {\n\t                main(undef, deps, callback, relName);\n\t            } else {\n\t                //Using a non-zero value because of concern for what old browsers\n\t                //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n\t                //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n\t                //If want a value immediately, use require('id') instead -- something\n\t                //that works in almond on the global level, but not guaranteed and\n\t                //unlikely to work in other AMD implementations.\n\t                setTimeout(function () {\n\t                    main(undef, deps, callback, relName);\n\t                }, 4);\n\t            }\n\t\n\t            return _req;\n\t        };\n\t\n\t        /**\n\t         * Just drops the config on the floor, but returns req in case\n\t         * the config return value is used.\n\t         */\n\t        _req.config = function (cfg) {\n\t            return _req(cfg);\n\t        };\n\t\n\t        /**\n\t         * Expose module registry for debugging and tooling\n\t         */\n\t        requirejs._defined = defined;\n\t\n\t        define = function define(name, deps, callback) {\n\t            if (typeof name !== 'string') {\n\t                throw new Error('See almond README: incorrect module build, no module name');\n\t            }\n\t\n\t            //This module may not have dependencies\n\t            if (!deps.splice) {\n\t                //deps is not an array, so probably means\n\t                //an object literal or factory function for\n\t                //the value. Adjust args.\n\t                callback = deps;\n\t                deps = [];\n\t            }\n\t\n\t            if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n\t                waiting[name] = [name, deps, callback];\n\t            }\n\t        };\n\t\n\t        define.amd = {\n\t            jQuery: true\n\t        };\n\t    })();\n\t\n\t    define(\"node_modules/almond/almond.js\", function () {});\n\t\n\t    /*\n\t        This program is distributed under the terms of the MIT license.\n\t        Please see the LICENSE file for details.\n\t    \n\t        Copyright 2006-2008, OGG, LLC\n\t    */\n\t    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n\t    /* global define */\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-polyfill', [], function () {\n\t                return factory(root);\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            return factory(root);\n\t        }\n\t    })(this, function (root) {\n\t\n\t        /** Function: Function.prototype.bind\n\t         *  Bind a function to an instance.\n\t         *\n\t         *  This Function object extension method creates a bound method similar\n\t         *  to those in Python.  This means that the 'this' object will point\n\t         *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>\n\t         *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>\n\t         *  for a complete explanation.\n\t         *\n\t         *  This extension already exists in some browsers (namely, Firefox 3), but\n\t         *  we provide it to support those that don't.\n\t         *\n\t         *  Parameters:\n\t         *    (Object) obj - The object that will become 'this' in the bound function.\n\t         *    (Object) argN - An option argument that will be prepended to the\n\t         *      arguments given for the function call\n\t         *\n\t         *  Returns:\n\t         *    The bound function.\n\t         */\n\t        if (!Function.prototype.bind) {\n\t            Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {\n\t                var func = this;\n\t                var _slice = Array.prototype.slice;\n\t                var _concat = Array.prototype.concat;\n\t                var _args = _slice.call(arguments, 1);\n\t                return function () {\n\t                    return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));\n\t                };\n\t            };\n\t        }\n\t\n\t        /** Function: Array.isArray\n\t         *  This is a polyfill for the ES5 Array.isArray method.\n\t         */\n\t        if (!Array.isArray) {\n\t            Array.isArray = function (arg) {\n\t                return Object.prototype.toString.call(arg) === '[object Array]';\n\t            };\n\t        }\n\t\n\t        /** Function: Array.prototype.indexOf\n\t         *  Return the index of an object in an array.\n\t         *\n\t         *  This function is not supplied by some JavaScript implementations, so\n\t         *  we provide it if it is missing.  This code is from:\n\t         *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf\n\t         *\n\t         *  Parameters:\n\t         *    (Object) elt - The object to look for.\n\t         *    (Integer) from - The index from which to start looking. (optional).\n\t         *\n\t         *  Returns:\n\t         *    The index of elt in the array or -1 if not found.\n\t         */\n\t        if (!Array.prototype.indexOf) {\n\t            Array.prototype.indexOf = function (elt /*, from*/) {\n\t                var len = this.length;\n\t                var from = Number(arguments[1]) || 0;\n\t                from = from < 0 ? Math.ceil(from) : Math.floor(from);\n\t                if (from < 0) {\n\t                    from += len;\n\t                }\n\t\n\t                for (; from < len; from++) {\n\t                    if (from in this && this[from] === elt) {\n\t                        return from;\n\t                    }\n\t                }\n\t                return -1;\n\t            };\n\t        }\n\t\n\t        /** Function: Array.prototype.forEach\n\t         *\n\t         *  This function is not available in IE < 9\n\t         *\n\t         *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>\n\t         */\n\t        if (!Array.prototype.forEach) {\n\t            Array.prototype.forEach = function (callback, thisArg) {\n\t                var T, k;\n\t                if (this === null) {\n\t                    throw new TypeError(' this is null or not defined');\n\t                }\n\t                // 1. Let O be the result of calling toObject() passing the\n\t                // |this| value as the argument.\n\t                var O = Object(this);\n\t                // 2. Let lenValue be the result of calling the Get() internal\n\t                // method of O with the argument \"length\".\n\t                // 3. Let len be toUint32(lenValue).\n\t                var len = O.length >>> 0;\n\t                // 4. If isCallable(callback) is false, throw a TypeError exception.\n\t                // See: http://es5.github.com/#x9.11\n\t                if (typeof callback !== \"function\") {\n\t                    throw new TypeError(callback + ' is not a function');\n\t                }\n\t                // 5. If thisArg was supplied, let T be thisArg; else let\n\t                // T be undefined.\n\t                if (arguments.length > 1) {\n\t                    T = thisArg;\n\t                }\n\t                // 6. Let k be 0\n\t                k = 0;\n\t                // 7. Repeat, while k < len\n\t                while (k < len) {\n\t                    var kValue;\n\t                    // a. Let Pk be ToString(k).\n\t                    //        This is implicit for LHS operands of the in operator\n\t                    // b. Let kPresent be the result of calling the HasProperty\n\t                    //        internal method of O with argument Pk.\n\t                    //        This step can be combined with c\n\t                    // c. If kPresent is true, then\n\t                    if (k in O) {\n\t                        // i. Let kValue be the result of calling the Get internal\n\t                        // method of O with argument Pk.\n\t                        kValue = O[k];\n\t                        // ii. Call the Call internal method of callback with T as\n\t                        // the this value and argument list containing kValue, k, and O.\n\t                        callback.call(T, kValue, k, O);\n\t                    }\n\t                    // d. Increase k by 1.\n\t                    k++;\n\t                }\n\t                // 8. return undefined\n\t            };\n\t        }\n\t\n\t        // This code was written by Tyler Akins and has been placed in the\n\t        // public domain.  It would be nice if you left this header intact.\n\t        // Base64 code from Tyler Akins -- http://rumkin.com\n\t        var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\t        if (!root.btoa) {\n\t            root.btoa = function (input) {\n\t                /**\n\t                 * Encodes a string in base64\n\t                 * @param {String} input The string to encode in base64.\n\t                 */\n\t                var output = \"\";\n\t                var chr1, chr2, chr3;\n\t                var enc1, enc2, enc3, enc4;\n\t                var i = 0;\n\t                do {\n\t                    chr1 = input.charCodeAt(i++);\n\t                    chr2 = input.charCodeAt(i++);\n\t                    chr3 = input.charCodeAt(i++);\n\t\n\t                    enc1 = chr1 >> 2;\n\t                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n\t                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n\t                    enc4 = chr3 & 63;\n\t\n\t                    if (isNaN(chr2)) {\n\t                        enc2 = (chr1 & 3) << 4;\n\t                        enc3 = enc4 = 64;\n\t                    } else if (isNaN(chr3)) {\n\t                        enc4 = 64;\n\t                    }\n\t                    output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);\n\t                } while (i < input.length);\n\t                return output;\n\t            };\n\t        }\n\t\n\t        if (!root.atob) {\n\t            root.atob = function (input) {\n\t                /**\n\t                 * Decodes a base64 string.\n\t                 * @param {String} input The string to decode.\n\t                 */\n\t                var output = \"\";\n\t                var chr1, chr2, chr3;\n\t                var enc1, enc2, enc3, enc4;\n\t                var i = 0;\n\t                // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n\t                input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\t                do {\n\t                    enc1 = keyStr.indexOf(input.charAt(i++));\n\t                    enc2 = keyStr.indexOf(input.charAt(i++));\n\t                    enc3 = keyStr.indexOf(input.charAt(i++));\n\t                    enc4 = keyStr.indexOf(input.charAt(i++));\n\t\n\t                    chr1 = enc1 << 2 | enc2 >> 4;\n\t                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n\t                    chr3 = (enc3 & 3) << 6 | enc4;\n\t\n\t                    output = output + String.fromCharCode(chr1);\n\t\n\t                    if (enc3 !== 64) {\n\t                        output = output + String.fromCharCode(chr2);\n\t                    }\n\t                    if (enc4 !== 64) {\n\t                        output = output + String.fromCharCode(chr3);\n\t                    }\n\t                } while (i < input.length);\n\t                return output;\n\t            };\n\t        }\n\t    });\n\t\n\t    /*\n\t     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n\t     * in FIPS PUB 180-1\n\t     * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n\t     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n\t     * Distributed under the BSD License\n\t     * See http://pajhome.org.uk/crypt/md5 for details.\n\t     */\n\t\n\t    /* jshint undef: true, unused: true:, noarg: true, latedef: false */\n\t    /* global define */\n\t\n\t    /* Some functions and variables have been stripped for use with Strophe */\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-sha1', [], function () {\n\t                return factory();\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            root.SHA1 = factory();\n\t        }\n\t    })(this, function () {\n\t\n\t        /*\n\t         * Calculate the SHA-1 of an array of big-endian words, and a bit length\n\t         */\n\t        function core_sha1(x, len) {\n\t            /* append padding */\n\t            x[len >> 5] |= 0x80 << 24 - len % 32;\n\t            x[(len + 64 >> 9 << 4) + 15] = len;\n\t\n\t            var w = new Array(80);\n\t            var a = 1732584193;\n\t            var b = -271733879;\n\t            var c = -1732584194;\n\t            var d = 271733878;\n\t            var e = -1009589776;\n\t\n\t            var i, j, t, olda, oldb, oldc, oldd, olde;\n\t            for (i = 0; i < x.length; i += 16) {\n\t                olda = a;\n\t                oldb = b;\n\t                oldc = c;\n\t                oldd = d;\n\t                olde = e;\n\t\n\t                for (j = 0; j < 80; j++) {\n\t                    if (j < 16) {\n\t                        w[j] = x[i + j];\n\t                    } else {\n\t                        w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n\t                    }\n\t                    t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));\n\t                    e = d;\n\t                    d = c;\n\t                    c = rol(b, 30);\n\t                    b = a;\n\t                    a = t;\n\t                }\n\t\n\t                a = safe_add(a, olda);\n\t                b = safe_add(b, oldb);\n\t                c = safe_add(c, oldc);\n\t                d = safe_add(d, oldd);\n\t                e = safe_add(e, olde);\n\t            }\n\t            return [a, b, c, d, e];\n\t        }\n\t\n\t        /*\n\t         * Perform the appropriate triplet combination function for the current\n\t         * iteration\n\t         */\n\t        function sha1_ft(t, b, c, d) {\n\t            if (t < 20) {\n\t                return b & c | ~b & d;\n\t            }\n\t            if (t < 40) {\n\t                return b ^ c ^ d;\n\t            }\n\t            if (t < 60) {\n\t                return b & c | b & d | c & d;\n\t            }\n\t            return b ^ c ^ d;\n\t        }\n\t\n\t        /*\n\t         * Determine the appropriate additive constant for the current iteration\n\t         */\n\t        function sha1_kt(t) {\n\t            return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;\n\t        }\n\t\n\t        /*\n\t         * Calculate the HMAC-SHA1 of a key and some data\n\t         */\n\t        function core_hmac_sha1(key, data) {\n\t            var bkey = str2binb(key);\n\t            if (bkey.length > 16) {\n\t                bkey = core_sha1(bkey, key.length * 8);\n\t            }\n\t\n\t            var ipad = new Array(16),\n\t                opad = new Array(16);\n\t            for (var i = 0; i < 16; i++) {\n\t                ipad[i] = bkey[i] ^ 0x36363636;\n\t                opad[i] = bkey[i] ^ 0x5C5C5C5C;\n\t            }\n\t\n\t            var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\n\t            return core_sha1(opad.concat(hash), 512 + 160);\n\t        }\n\t\n\t        /*\n\t         * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n\t         * to work around bugs in some JS interpreters.\n\t         */\n\t        function safe_add(x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n\t            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return msw << 16 | lsw & 0xFFFF;\n\t        }\n\t\n\t        /*\n\t         * Bitwise rotate a 32-bit number to the left.\n\t         */\n\t        function rol(num, cnt) {\n\t            return num << cnt | num >>> 32 - cnt;\n\t        }\n\t\n\t        /*\n\t         * Convert an 8-bit or 16-bit string to an array of big-endian words\n\t         * In 8-bit function, characters >255 have their hi-byte silently ignored.\n\t         */\n\t        function str2binb(str) {\n\t            var bin = [];\n\t            var mask = 255;\n\t            for (var i = 0; i < str.length * 8; i += 8) {\n\t                bin[i >> 5] |= (str.charCodeAt(i / 8) & mask) << 24 - i % 32;\n\t            }\n\t            return bin;\n\t        }\n\t\n\t        /*\n\t         * Convert an array of big-endian words to a string\n\t         */\n\t        function binb2str(bin) {\n\t            var str = \"\";\n\t            var mask = 255;\n\t            for (var i = 0; i < bin.length * 32; i += 8) {\n\t                str += String.fromCharCode(bin[i >> 5] >>> 24 - i % 32 & mask);\n\t            }\n\t            return str;\n\t        }\n\t\n\t        /*\n\t         * Convert an array of big-endian words to a base-64 string\n\t         */\n\t        function binb2b64(binarray) {\n\t            var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\t            var str = \"\";\n\t            var triplet, j;\n\t            for (var i = 0; i < binarray.length * 4; i += 3) {\n\t                triplet = (binarray[i >> 2] >> 8 * (3 - i % 4) & 0xFF) << 16 | (binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 0xFF) << 8 | binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 0xFF;\n\t                for (j = 0; j < 4; j++) {\n\t                    if (i * 8 + j * 6 > binarray.length * 32) {\n\t                        str += \"=\";\n\t                    } else {\n\t                        str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);\n\t                    }\n\t                }\n\t            }\n\t            return str;\n\t        }\n\t\n\t        /*\n\t         * These are the functions you'll usually want to call\n\t         * They take string arguments and return either hex or base-64 encoded strings\n\t         */\n\t        return {\n\t            b64_hmac_sha1: function b64_hmac_sha1(key, data) {\n\t                return binb2b64(core_hmac_sha1(key, data));\n\t            },\n\t            b64_sha1: function b64_sha1(s) {\n\t                return binb2b64(core_sha1(str2binb(s), s.length * 8));\n\t            },\n\t            binb2str: binb2str,\n\t            core_hmac_sha1: core_hmac_sha1,\n\t            str_hmac_sha1: function str_hmac_sha1(key, data) {\n\t                return binb2str(core_hmac_sha1(key, data));\n\t            },\n\t            str_sha1: function str_sha1(s) {\n\t                return binb2str(core_sha1(str2binb(s), s.length * 8));\n\t            }\n\t        };\n\t    });\n\t\n\t    /*\n\t     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n\t     * Digest Algorithm, as defined in RFC 1321.\n\t     * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n\t     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n\t     * Distributed under the BSD License\n\t     * See http://pajhome.org.uk/crypt/md5 for more info.\n\t     */\n\t    /*\n\t     * Everything that isn't used by Strophe has been stripped here!\n\t     */\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-md5', [], function () {\n\t                return factory();\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            root.MD5 = factory();\n\t        }\n\t    })(this, function () {\n\t        /*\n\t         * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n\t         * to work around bugs in some JS interpreters.\n\t         */\n\t        var safe_add = function safe_add(x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n\t            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return msw << 16 | lsw & 0xFFFF;\n\t        };\n\t\n\t        /*\n\t         * Bitwise rotate a 32-bit number to the left.\n\t         */\n\t        var bit_rol = function bit_rol(num, cnt) {\n\t            return num << cnt | num >>> 32 - cnt;\n\t        };\n\t\n\t        /*\n\t         * Convert a string to an array of little-endian words\n\t         */\n\t        var str2binl = function str2binl(str) {\n\t            var bin = [];\n\t            for (var i = 0; i < str.length * 8; i += 8) {\n\t                bin[i >> 5] |= (str.charCodeAt(i / 8) & 255) << i % 32;\n\t            }\n\t            return bin;\n\t        };\n\t\n\t        /*\n\t         * Convert an array of little-endian words to a string\n\t         */\n\t        var binl2str = function binl2str(bin) {\n\t            var str = \"\";\n\t            for (var i = 0; i < bin.length * 32; i += 8) {\n\t                str += String.fromCharCode(bin[i >> 5] >>> i % 32 & 255);\n\t            }\n\t            return str;\n\t        };\n\t\n\t        /*\n\t         * Convert an array of little-endian words to a hex string.\n\t         */\n\t        var binl2hex = function binl2hex(binarray) {\n\t            var hex_tab = \"0123456789abcdef\";\n\t            var str = \"\";\n\t            for (var i = 0; i < binarray.length * 4; i++) {\n\t                str += hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 + 4 & 0xF) + hex_tab.charAt(binarray[i >> 2] >> i % 4 * 8 & 0xF);\n\t            }\n\t            return str;\n\t        };\n\t\n\t        /*\n\t         * These functions implement the four basic operations the algorithm uses.\n\t         */\n\t        var md5_cmn = function md5_cmn(q, a, b, x, s, t) {\n\t            return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n\t        };\n\t\n\t        var md5_ff = function md5_ff(a, b, c, d, x, s, t) {\n\t            return md5_cmn(b & c | ~b & d, a, b, x, s, t);\n\t        };\n\t\n\t        var md5_gg = function md5_gg(a, b, c, d, x, s, t) {\n\t            return md5_cmn(b & d | c & ~d, a, b, x, s, t);\n\t        };\n\t\n\t        var md5_hh = function md5_hh(a, b, c, d, x, s, t) {\n\t            return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n\t        };\n\t\n\t        var md5_ii = function md5_ii(a, b, c, d, x, s, t) {\n\t            return md5_cmn(c ^ (b | ~d), a, b, x, s, t);\n\t        };\n\t\n\t        /*\n\t         * Calculate the MD5 of an array of little-endian words, and a bit length\n\t         */\n\t        var core_md5 = function core_md5(x, len) {\n\t            /* append padding */\n\t            x[len >> 5] |= 0x80 << len % 32;\n\t            x[(len + 64 >>> 9 << 4) + 14] = len;\n\t\n\t            var a = 1732584193;\n\t            var b = -271733879;\n\t            var c = -1732584194;\n\t            var d = 271733878;\n\t\n\t            var olda, oldb, oldc, oldd;\n\t            for (var i = 0; i < x.length; i += 16) {\n\t                olda = a;\n\t                oldb = b;\n\t                oldc = c;\n\t                oldd = d;\n\t\n\t                a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\n\t                d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n\t                c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n\t                b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n\t                a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n\t                d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n\t                c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n\t                b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n\t                a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n\t                d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n\t                c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n\t                b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n\t                a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n\t                d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n\t                c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n\t                b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\t\n\t                a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n\t                d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n\t                c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n\t                b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\n\t                a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n\t                d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n\t                c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n\t                b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n\t                a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n\t                d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n\t                c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n\t                b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n\t                a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n\t                d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n\t                c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n\t                b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\t\n\t                a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n\t                d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n\t                c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n\t                b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n\t                a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n\t                d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n\t                c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n\t                b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n\t                a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n\t                d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\n\t                c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n\t                b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n\t                a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n\t                d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n\t                c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n\t                b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n\t\n\t                a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\n\t                d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n\t                c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n\t                b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n\t                a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n\t                d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n\t                c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n\t                b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n\t                a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n\t                d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n\t                c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n\t                b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n\t                a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n\t                d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n\t                c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n\t                b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n\t\n\t                a = safe_add(a, olda);\n\t                b = safe_add(b, oldb);\n\t                c = safe_add(c, oldc);\n\t                d = safe_add(d, oldd);\n\t            }\n\t            return [a, b, c, d];\n\t        };\n\t\n\t        var obj = {\n\t            /*\n\t             * These are the functions you'll usually want to call.\n\t             * They take string arguments and return either hex or base-64 encoded\n\t             * strings.\n\t             */\n\t            hexdigest: function hexdigest(s) {\n\t                return binl2hex(core_md5(str2binl(s), s.length * 8));\n\t            },\n\t\n\t            hash: function hash(s) {\n\t                return binl2str(core_md5(str2binl(s), s.length * 8));\n\t            }\n\t        };\n\t        return obj;\n\t    });\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-utils', [], function () {\n\t                return factory();\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            root.stropheUtils = factory();\n\t        }\n\t    })(this, function () {\n\t\n\t        var utils = {\n\t\n\t            utf16to8: function utf16to8(str) {\n\t                var i, c;\n\t                var out = \"\";\n\t                var len = str.length;\n\t                for (i = 0; i < len; i++) {\n\t                    c = str.charCodeAt(i);\n\t                    if (c >= 0x0000 && c <= 0x007F) {\n\t                        out += str.charAt(i);\n\t                    } else if (c > 0x07FF) {\n\t                        out += String.fromCharCode(0xE0 | c >> 12 & 0x0F);\n\t                        out += String.fromCharCode(0x80 | c >> 6 & 0x3F);\n\t                        out += String.fromCharCode(0x80 | c >> 0 & 0x3F);\n\t                    } else {\n\t                        out += String.fromCharCode(0xC0 | c >> 6 & 0x1F);\n\t                        out += String.fromCharCode(0x80 | c >> 0 & 0x3F);\n\t                    }\n\t                }\n\t                return out;\n\t            },\n\t\n\t            addCookies: function addCookies(cookies) {\n\t                /* Parameters:\n\t                 *  (Object) cookies - either a map of cookie names\n\t                 *    to string values or to maps of cookie values.\n\t                 *\n\t                 * For example:\n\t                 * { \"myCookie\": \"1234\" }\n\t                 *\n\t                 * or:\n\t                 * { \"myCookie\": {\n\t                 *      \"value\": \"1234\",\n\t                 *      \"domain\": \".example.org\",\n\t                 *      \"path\": \"/\",\n\t                 *      \"expires\": expirationDate\n\t                 *      }\n\t                 *  }\n\t                 *\n\t                 *  These values get passed to Strophe.Connection via\n\t                 *   options.cookies\n\t                 */\n\t                var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;\n\t                for (cookieName in cookies || {}) {\n\t                    expires = '';\n\t                    domain = '';\n\t                    path = '';\n\t                    cookieObj = cookies[cookieName];\n\t                    isObj = (typeof cookieObj === 'undefined' ? 'undefined' : _typeof(cookieObj)) === \"object\";\n\t                    cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\n\t                    if (isObj) {\n\t                        expires = cookieObj.expires ? \";expires=\" + cookieObj.expires : '';\n\t                        domain = cookieObj.domain ? \";domain=\" + cookieObj.domain : '';\n\t                        path = cookieObj.path ? \";path=\" + cookieObj.path : '';\n\t                    }\n\t                    document.cookie = cookieName + '=' + cookieValue + expires + domain + path;\n\t                }\n\t            }\n\t        };\n\t        return utils;\n\t    });\n\t\n\t    /*\n\t        This program is distributed under the terms of the MIT license.\n\t        Please see the LICENSE file for details.\n\t    \n\t        Copyright 2006-2008, OGG, LLC\n\t    */\n\t\n\t    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n\t    /*global define, document, sessionStorage, setTimeout, clearTimeout, ActiveXObject, DOMParser, btoa, atob */\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-core', ['strophe-sha1', 'strophe-md5', 'strophe-utils'], function () {\n\t                return factory.apply(this, arguments);\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            var o = factory(root.SHA1, root.MD5, root.stropheUtils);\n\t            root.Strophe = o.Strophe;\n\t            root.$build = o.$build;\n\t            root.$iq = o.$iq;\n\t            root.$msg = o.$msg;\n\t            root.$pres = o.$pres;\n\t            root.SHA1 = o.SHA1;\n\t            root.MD5 = o.MD5;\n\t            root.b64_hmac_sha1 = o.SHA1.b64_hmac_sha1;\n\t            root.b64_sha1 = o.SHA1.b64_sha1;\n\t            root.str_hmac_sha1 = o.SHA1.str_hmac_sha1;\n\t            root.str_sha1 = o.SHA1.str_sha1;\n\t        }\n\t    })(this, function (SHA1, MD5, utils) {\n\t\n\t        var Strophe;\n\t\n\t        /** Function: $build\n\t         *  Create a Strophe.Builder.\n\t         *  This is an alias for 'new Strophe.Builder(name, attrs)'.\n\t         *\n\t         *  Parameters:\n\t         *    (String) name - The root element name.\n\t         *    (Object) attrs - The attributes for the root element in object notation.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Builder object.\n\t         */\n\t        function $build(name, attrs) {\n\t            return new Strophe.Builder(name, attrs);\n\t        }\n\t\n\t        /** Function: $msg\n\t         *  Create a Strophe.Builder with a <message/> element as the root.\n\t         *\n\t         *  Parameters:\n\t         *    (Object) attrs - The <message/> element attributes in object notation.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Builder object.\n\t         */\n\t        function $msg(attrs) {\n\t            return new Strophe.Builder(\"message\", attrs);\n\t        }\n\t\n\t        /** Function: $iq\n\t         *  Create a Strophe.Builder with an <iq/> element as the root.\n\t         *\n\t         *  Parameters:\n\t         *    (Object) attrs - The <iq/> element attributes in object notation.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Builder object.\n\t         */\n\t        function $iq(attrs) {\n\t            return new Strophe.Builder(\"iq\", attrs);\n\t        }\n\t\n\t        /** Function: $pres\n\t         *  Create a Strophe.Builder with a <presence/> element as the root.\n\t         *\n\t         *  Parameters:\n\t         *    (Object) attrs - The <presence/> element attributes in object notation.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Builder object.\n\t         */\n\t        function $pres(attrs) {\n\t            return new Strophe.Builder(\"presence\", attrs);\n\t        }\n\t\n\t        /** Class: Strophe\n\t         *  An object container for all Strophe library functions.\n\t         *\n\t         *  This class is just a container for all the objects and constants\n\t         *  used in the library.  It is not meant to be instantiated, but to\n\t         *  provide a namespace for library objects, constants, and functions.\n\t         */\n\t        Strophe = {\n\t            /** Constant: VERSION */\n\t            VERSION: \"1.2.14\",\n\t\n\t            /** Constants: XMPP Namespace Constants\n\t             *  Common namespace constants from the XMPP RFCs and XEPs.\n\t             *\n\t             *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\n\t             *  NS.BOSH - BOSH namespace from XEP 206.\n\t             *  NS.CLIENT - Main XMPP client namespace.\n\t             *  NS.AUTH - Legacy authentication namespace.\n\t             *  NS.ROSTER - Roster operations namespace.\n\t             *  NS.PROFILE - Profile namespace.\n\t             *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\n\t             *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\n\t             *  NS.MUC - Multi-User Chat namespace from XEP 45.\n\t             *  NS.SASL - XMPP SASL namespace from RFC 3920.\n\t             *  NS.STREAM - XMPP Streams namespace from RFC 3920.\n\t             *  NS.BIND - XMPP Binding namespace from RFC 3920.\n\t             *  NS.SESSION - XMPP Session namespace from RFC 3920.\n\t             *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\n\t             *  NS.XHTML - XHTML body namespace from XEP 71.\n\t             */\n\t            NS: {\n\t                HTTPBIND: \"http://jabber.org/protocol/httpbind\",\n\t                BOSH: \"urn:xmpp:xbosh\",\n\t                CLIENT: \"jabber:client\",\n\t                AUTH: \"jabber:iq:auth\",\n\t                ROSTER: \"jabber:iq:roster\",\n\t                PROFILE: \"jabber:iq:profile\",\n\t                DISCO_INFO: \"http://jabber.org/protocol/disco#info\",\n\t                DISCO_ITEMS: \"http://jabber.org/protocol/disco#items\",\n\t                MUC: \"http://jabber.org/protocol/muc\",\n\t                SASL: \"urn:ietf:params:xml:ns:xmpp-sasl\",\n\t                STREAM: \"http://etherx.jabber.org/streams\",\n\t                FRAMING: \"urn:ietf:params:xml:ns:xmpp-framing\",\n\t                BIND: \"urn:ietf:params:xml:ns:xmpp-bind\",\n\t                SESSION: \"urn:ietf:params:xml:ns:xmpp-session\",\n\t                VERSION: \"jabber:iq:version\",\n\t                STANZAS: \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n\t                XHTML_IM: \"http://jabber.org/protocol/xhtml-im\",\n\t                XHTML: \"http://www.w3.org/1999/xhtml\"\n\t            },\n\t\n\t            /** Constants: XHTML_IM Namespace\n\t             *  contains allowed tags, tag attributes, and css properties.\n\t             *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\n\t             *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\n\t             *  allowed tags and their attributes.\n\t             */\n\t            XHTML: {\n\t                tags: ['a', 'blockquote', 'br', 'cite', 'em', 'img', 'li', 'ol', 'p', 'span', 'strong', 'ul', 'body'],\n\t                attributes: {\n\t                    'a': ['href'],\n\t                    'blockquote': ['style'],\n\t                    'br': [],\n\t                    'cite': ['style'],\n\t                    'em': [],\n\t                    'img': ['src', 'alt', 'style', 'height', 'width'],\n\t                    'li': ['style'],\n\t                    'ol': ['style'],\n\t                    'p': ['style'],\n\t                    'span': ['style'],\n\t                    'strong': [],\n\t                    'ul': ['style'],\n\t                    'body': []\n\t                },\n\t                css: ['background-color', 'color', 'font-family', 'font-size', 'font-style', 'font-weight', 'margin-left', 'margin-right', 'text-align', 'text-decoration'],\n\t                /** Function: XHTML.validTag\n\t                 *\n\t                 * Utility method to determine whether a tag is allowed\n\t                 * in the XHTML_IM namespace.\n\t                 *\n\t                 * XHTML tag names are case sensitive and must be lower case.\n\t                 */\n\t                validTag: function validTag(tag) {\n\t                    for (var i = 0; i < Strophe.XHTML.tags.length; i++) {\n\t                        if (tag === Strophe.XHTML.tags[i]) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    return false;\n\t                },\n\t                /** Function: XHTML.validAttribute\n\t                 *\n\t                 * Utility method to determine whether an attribute is allowed\n\t                 * as recommended per XEP-0071\n\t                 *\n\t                 * XHTML attribute names are case sensitive and must be lower case.\n\t                 */\n\t                validAttribute: function validAttribute(tag, attribute) {\n\t                    if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\n\t                        for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n\t                            if (attribute === Strophe.XHTML.attributes[tag][i]) {\n\t                                return true;\n\t                            }\n\t                        }\n\t                    }\n\t                    return false;\n\t                },\n\t                validCSS: function validCSS(style) {\n\t                    for (var i = 0; i < Strophe.XHTML.css.length; i++) {\n\t                        if (style === Strophe.XHTML.css[i]) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    return false;\n\t                }\n\t            },\n\t\n\t            /** Constants: Connection Status Constants\n\t             *  Connection status constants for use by the connection handler\n\t             *  callback.\n\t             *\n\t             *  Status.ERROR - An error has occurred\n\t             *  Status.CONNECTING - The connection is currently being made\n\t             *  Status.CONNFAIL - The connection attempt failed\n\t             *  Status.AUTHENTICATING - The connection is authenticating\n\t             *  Status.AUTHFAIL - The authentication attempt failed\n\t             *  Status.CONNECTED - The connection has succeeded\n\t             *  Status.DISCONNECTED - The connection has been terminated\n\t             *  Status.DISCONNECTING - The connection is currently being terminated\n\t             *  Status.ATTACHED - The connection has been attached\n\t             *  Status.REDIRECT - The connection has been redirected\n\t             *  Status.CONNTIMEOUT - The connection has timed out\n\t             */\n\t            Status: {\n\t                ERROR: 0,\n\t                CONNECTING: 1,\n\t                CONNFAIL: 2,\n\t                AUTHENTICATING: 3,\n\t                AUTHFAIL: 4,\n\t                CONNECTED: 5,\n\t                DISCONNECTED: 6,\n\t                DISCONNECTING: 7,\n\t                ATTACHED: 8,\n\t                REDIRECT: 9,\n\t                CONNTIMEOUT: 10\n\t            },\n\t\n\t            /** Constants: Log Level Constants\n\t             *  Logging level indicators.\n\t             *\n\t             *  LogLevel.DEBUG - Debug output\n\t             *  LogLevel.INFO - Informational output\n\t             *  LogLevel.WARN - Warnings\n\t             *  LogLevel.ERROR - Errors\n\t             *  LogLevel.FATAL - Fatal errors\n\t             */\n\t            LogLevel: {\n\t                DEBUG: 0,\n\t                INFO: 1,\n\t                WARN: 2,\n\t                ERROR: 3,\n\t                FATAL: 4\n\t            },\n\t\n\t            /** PrivateConstants: DOM Element Type Constants\n\t             *  DOM element types.\n\t             *\n\t             *  ElementType.NORMAL - Normal element.\n\t             *  ElementType.TEXT - Text data element.\n\t             *  ElementType.FRAGMENT - XHTML fragment element.\n\t             */\n\t            ElementType: {\n\t                NORMAL: 1,\n\t                TEXT: 3,\n\t                CDATA: 4,\n\t                FRAGMENT: 11\n\t            },\n\t\n\t            /** PrivateConstants: Timeout Values\n\t             *  Timeout values for error states.  These values are in seconds.\n\t             *  These should not be changed unless you know exactly what you are\n\t             *  doing.\n\t             *\n\t             *  TIMEOUT - Timeout multiplier. A waiting request will be considered\n\t             *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\n\t             *      This defaults to 1.1, and with default wait, 66 seconds.\n\t             *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\n\t             *      Strophe can detect early failure, it will consider the request\n\t             *      failed if it doesn't return after\n\t             *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\n\t             *      This defaults to 0.1, and with default wait, 6 seconds.\n\t             */\n\t            TIMEOUT: 1.1,\n\t            SECONDARY_TIMEOUT: 0.1,\n\t\n\t            /** Function: addNamespace\n\t             *  This function is used to extend the current namespaces in\n\t             *  Strophe.NS.  It takes a key and a value with the key being the\n\t             *  name of the new namespace, with its actual value.\n\t             *  For example:\n\t             *  Strophe.addNamespace('PUBSUB', \"http://jabber.org/protocol/pubsub\");\n\t             *\n\t             *  Parameters:\n\t             *    (String) name - The name under which the namespace will be\n\t             *      referenced under Strophe.NS\n\t             *    (String) value - The actual namespace.\n\t             */\n\t            addNamespace: function addNamespace(name, value) {\n\t                Strophe.NS[name] = value;\n\t            },\n\t\n\t            /** Function: forEachChild\n\t             *  Map a function over some or all child elements of a given element.\n\t             *\n\t             *  This is a small convenience function for mapping a function over\n\t             *  some or all of the children of an element.  If elemName is null, all\n\t             *  children will be passed to the function, otherwise only children\n\t             *  whose tag names match elemName will be passed.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The element to operate on.\n\t             *    (String) elemName - The child element tag name filter.\n\t             *    (Function) func - The function to apply to each child.  This\n\t             *      function should take a single argument, a DOM element.\n\t             */\n\t            forEachChild: function forEachChild(elem, elemName, func) {\n\t                var i, childNode;\n\t                for (i = 0; i < elem.childNodes.length; i++) {\n\t                    childNode = elem.childNodes[i];\n\t                    if (childNode.nodeType === Strophe.ElementType.NORMAL && (!elemName || this.isTagEqual(childNode, elemName))) {\n\t                        func(childNode);\n\t                    }\n\t                }\n\t            },\n\t\n\t            /** Function: isTagEqual\n\t             *  Compare an element's tag name with a string.\n\t             *\n\t             *  This function is case sensitive.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) el - A DOM element.\n\t             *    (String) name - The element name.\n\t             *\n\t             *  Returns:\n\t             *    true if the element's tag name matches _el_, and false\n\t             *    otherwise.\n\t             */\n\t            isTagEqual: function isTagEqual(el, name) {\n\t                return el.tagName === name;\n\t            },\n\t\n\t            /** PrivateVariable: _xmlGenerator\n\t             *  _Private_ variable that caches a DOM document to\n\t             *  generate elements.\n\t             */\n\t            _xmlGenerator: null,\n\t\n\t            /** PrivateFunction: _makeGenerator\n\t             *  _Private_ function that creates a dummy XML DOM document to serve as\n\t             *  an element and text node generator.\n\t             */\n\t            _makeGenerator: function _makeGenerator() {\n\t                var doc;\n\t                // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\n\t                // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\n\t                // less than 10 in the case of IE9 and below.\n\t                if (document.implementation.createDocument === undefined || document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\n\t                    doc = this._getIEXmlDom();\n\t                    doc.appendChild(doc.createElement('strophe'));\n\t                } else {\n\t                    doc = document.implementation.createDocument('jabber:client', 'strophe', null);\n\t                }\n\t                return doc;\n\t            },\n\t\n\t            /** Function: xmlGenerator\n\t             *  Get the DOM document to generate elements.\n\t             *\n\t             *  Returns:\n\t             *    The currently used DOM document.\n\t             */\n\t            xmlGenerator: function xmlGenerator() {\n\t                if (!Strophe._xmlGenerator) {\n\t                    Strophe._xmlGenerator = Strophe._makeGenerator();\n\t                }\n\t                return Strophe._xmlGenerator;\n\t            },\n\t\n\t            /** PrivateFunction: _getIEXmlDom\n\t             *  Gets IE xml doc object\n\t             *\n\t             *  Returns:\n\t             *    A Microsoft XML DOM Object\n\t             *  See Also:\n\t             *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\n\t             */\n\t            _getIEXmlDom: function _getIEXmlDom() {\n\t                var doc = null;\n\t                var docStrings = [\"Msxml2.DOMDocument.6.0\", \"Msxml2.DOMDocument.5.0\", \"Msxml2.DOMDocument.4.0\", \"MSXML2.DOMDocument.3.0\", \"MSXML2.DOMDocument\", \"MSXML.DOMDocument\", \"Microsoft.XMLDOM\"];\n\t\n\t                for (var d = 0; d < docStrings.length; d++) {\n\t                    if (doc === null) {\n\t                        try {\n\t                            doc = new ActiveXObject(docStrings[d]);\n\t                        } catch (e) {\n\t                            doc = null;\n\t                        }\n\t                    } else {\n\t                        break;\n\t                    }\n\t                }\n\t                return doc;\n\t            },\n\t\n\t            /** Function: xmlElement\n\t             *  Create an XML DOM element.\n\t             *\n\t             *  This function creates an XML DOM element correctly across all\n\t             *  implementations. Note that these are not HTML DOM elements, which\n\t             *  aren't appropriate for XMPP stanzas.\n\t             *\n\t             *  Parameters:\n\t             *    (String) name - The name for the element.\n\t             *    (Array|Object) attrs - An optional array or object containing\n\t             *      key/value pairs to use as element attributes. The object should\n\t             *      be in the format {'key': 'value'} or {key: 'value'}. The array\n\t             *      should have the format [['key1', 'value1'], ['key2', 'value2']].\n\t             *    (String) text - The text child data for the element.\n\t             *\n\t             *  Returns:\n\t             *    A new XML DOM element.\n\t             */\n\t            xmlElement: function xmlElement(name) {\n\t                if (!name) {\n\t                    return null;\n\t                }\n\t\n\t                var node = Strophe.xmlGenerator().createElement(name);\n\t                // FIXME: this should throw errors if args are the wrong type or\n\t                // there are more than two optional args\n\t                var a, i, k;\n\t                for (a = 1; a < arguments.length; a++) {\n\t                    var arg = arguments[a];\n\t                    if (!arg) {\n\t                        continue;\n\t                    }\n\t                    if (typeof arg === \"string\" || typeof arg === \"number\") {\n\t                        node.appendChild(Strophe.xmlTextNode(arg));\n\t                    } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\" && typeof arg.sort === \"function\") {\n\t                        for (i = 0; i < arg.length; i++) {\n\t                            var attr = arg[i];\n\t                            if ((typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === \"object\" && typeof attr.sort === \"function\" && attr[1] !== undefined && attr[1] !== null) {\n\t                                node.setAttribute(attr[0], attr[1]);\n\t                            }\n\t                        }\n\t                    } else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === \"object\") {\n\t                        for (k in arg) {\n\t                            if (arg.hasOwnProperty(k)) {\n\t                                if (arg[k] !== undefined && arg[k] !== null) {\n\t                                    node.setAttribute(k, arg[k]);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                return node;\n\t            },\n\t\n\t            /*  Function: xmlescape\n\t             *  Excapes invalid xml characters.\n\t             *\n\t             *  Parameters:\n\t             *     (String) text - text to escape.\n\t             *\n\t             *  Returns:\n\t             *      Escaped text.\n\t             */\n\t            xmlescape: function xmlescape(text) {\n\t                text = text.replace(/\\&/g, \"&amp;\");\n\t                text = text.replace(/</g, \"&lt;\");\n\t                text = text.replace(/>/g, \"&gt;\");\n\t                text = text.replace(/'/g, \"&apos;\");\n\t                text = text.replace(/\"/g, \"&quot;\");\n\t                return text;\n\t            },\n\t\n\t            /*  Function: xmlunescape\n\t            *  Unexcapes invalid xml characters.\n\t            *\n\t            *  Parameters:\n\t            *     (String) text - text to unescape.\n\t            *\n\t            *  Returns:\n\t            *      Unescaped text.\n\t            */\n\t            xmlunescape: function xmlunescape(text) {\n\t                text = text.replace(/\\&amp;/g, \"&\");\n\t                text = text.replace(/&lt;/g, \"<\");\n\t                text = text.replace(/&gt;/g, \">\");\n\t                text = text.replace(/&apos;/g, \"'\");\n\t                text = text.replace(/&quot;/g, \"\\\"\");\n\t                return text;\n\t            },\n\t\n\t            /** Function: xmlTextNode\n\t             *  Creates an XML DOM text node.\n\t             *\n\t             *  Provides a cross implementation version of document.createTextNode.\n\t             *\n\t             *  Parameters:\n\t             *    (String) text - The content of the text node.\n\t             *\n\t             *  Returns:\n\t             *    A new XML DOM text node.\n\t             */\n\t            xmlTextNode: function xmlTextNode(text) {\n\t                return Strophe.xmlGenerator().createTextNode(text);\n\t            },\n\t\n\t            /** Function: xmlHtmlNode\n\t             *  Creates an XML DOM html node.\n\t             *\n\t             *  Parameters:\n\t             *    (String) html - The content of the html node.\n\t             *\n\t             *  Returns:\n\t             *    A new XML DOM text node.\n\t             */\n\t            xmlHtmlNode: function xmlHtmlNode(html) {\n\t                var node;\n\t                //ensure text is escaped\n\t                if (DOMParser) {\n\t                    var parser = new DOMParser();\n\t                    node = parser.parseFromString(html, \"text/xml\");\n\t                } else {\n\t                    node = new ActiveXObject(\"Microsoft.XMLDOM\");\n\t                    node.async = \"false\";\n\t                    node.loadXML(html);\n\t                }\n\t                return node;\n\t            },\n\t\n\t            /** Function: getText\n\t             *  Get the concatenation of all text children of an element.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - A DOM element.\n\t             *\n\t             *  Returns:\n\t             *    A String with the concatenated text of all text element children.\n\t             */\n\t            getText: function getText(elem) {\n\t                if (!elem) {\n\t                    return null;\n\t                }\n\t\n\t                var str = \"\";\n\t                if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {\n\t                    str += elem.nodeValue;\n\t                }\n\t\n\t                for (var i = 0; i < elem.childNodes.length; i++) {\n\t                    if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {\n\t                        str += elem.childNodes[i].nodeValue;\n\t                    }\n\t                }\n\t\n\t                return Strophe.xmlescape(str);\n\t            },\n\t\n\t            /** Function: copyElement\n\t             *  Copy an XML DOM element.\n\t             *\n\t             *  This function copies a DOM element and all its descendants and returns\n\t             *  the new copy.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - A DOM element.\n\t             *\n\t             *  Returns:\n\t             *    A new, copied DOM element tree.\n\t             */\n\t            copyElement: function copyElement(elem) {\n\t                var i, el;\n\t                if (elem.nodeType === Strophe.ElementType.NORMAL) {\n\t                    el = Strophe.xmlElement(elem.tagName);\n\t\n\t                    for (i = 0; i < elem.attributes.length; i++) {\n\t                        el.setAttribute(elem.attributes[i].nodeName, elem.attributes[i].value);\n\t                    }\n\t\n\t                    for (i = 0; i < elem.childNodes.length; i++) {\n\t                        el.appendChild(Strophe.copyElement(elem.childNodes[i]));\n\t                    }\n\t                } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n\t                    el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\n\t                }\n\t                return el;\n\t            },\n\t\n\t            /** Function: createHtml\n\t             *  Copy an HTML DOM element into an XML DOM.\n\t             *\n\t             *  This function copies a DOM element and all its descendants and returns\n\t             *  the new copy.\n\t             *\n\t             *  Parameters:\n\t             *    (HTMLElement) elem - A DOM element.\n\t             *\n\t             *  Returns:\n\t             *    A new, copied DOM element tree.\n\t             */\n\t            createHtml: function createHtml(elem) {\n\t                var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;\n\t                if (elem.nodeType === Strophe.ElementType.NORMAL) {\n\t                    tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\n\t                    if (Strophe.XHTML.validTag(tag)) {\n\t                        try {\n\t                            el = Strophe.xmlElement(tag);\n\t                            for (i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n\t                                attribute = Strophe.XHTML.attributes[tag][i];\n\t                                value = elem.getAttribute(attribute);\n\t                                if (typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {\n\t                                    continue;\n\t                                }\n\t                                if (attribute === 'style' && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t                                    if (typeof value.cssText !== 'undefined') {\n\t                                        value = value.cssText; // we're dealing with IE, need to get CSS out\n\t                                    }\n\t                                }\n\t                                // filter out invalid css styles\n\t                                if (attribute === 'style') {\n\t                                    css = [];\n\t                                    cssAttrs = value.split(';');\n\t                                    for (j = 0; j < cssAttrs.length; j++) {\n\t                                        attr = cssAttrs[j].split(':');\n\t                                        cssName = attr[0].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").toLowerCase();\n\t                                        if (Strophe.XHTML.validCSS(cssName)) {\n\t                                            cssValue = attr[1].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n\t                                            css.push(cssName + ': ' + cssValue);\n\t                                        }\n\t                                    }\n\t                                    if (css.length > 0) {\n\t                                        value = css.join('; ');\n\t                                        el.setAttribute(attribute, value);\n\t                                    }\n\t                                } else {\n\t                                    el.setAttribute(attribute, value);\n\t                                }\n\t                            }\n\t\n\t                            for (i = 0; i < elem.childNodes.length; i++) {\n\t                                el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n\t                            }\n\t                        } catch (e) {\n\t                            // invalid elements\n\t                            el = Strophe.xmlTextNode('');\n\t                        }\n\t                    } else {\n\t                        el = Strophe.xmlGenerator().createDocumentFragment();\n\t                        for (i = 0; i < elem.childNodes.length; i++) {\n\t                            el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n\t                        }\n\t                    }\n\t                } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {\n\t                    el = Strophe.xmlGenerator().createDocumentFragment();\n\t                    for (i = 0; i < elem.childNodes.length; i++) {\n\t                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n\t                    }\n\t                } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n\t                    el = Strophe.xmlTextNode(elem.nodeValue);\n\t                }\n\t                return el;\n\t            },\n\t\n\t            /** Function: escapeNode\n\t             *  Escape the node part (also called local part) of a JID.\n\t             *\n\t             *  Parameters:\n\t             *    (String) node - A node (or local part).\n\t             *\n\t             *  Returns:\n\t             *    An escaped node (or local part).\n\t             */\n\t            escapeNode: function escapeNode(node) {\n\t                if (typeof node !== \"string\") {\n\t                    return node;\n\t                }\n\t                return node.replace(/^\\s+|\\s+$/g, '').replace(/\\\\/g, \"\\\\5c\").replace(/ /g, \"\\\\20\").replace(/\\\"/g, \"\\\\22\").replace(/\\&/g, \"\\\\26\").replace(/\\'/g, \"\\\\27\").replace(/\\//g, \"\\\\2f\").replace(/:/g, \"\\\\3a\").replace(/</g, \"\\\\3c\").replace(/>/g, \"\\\\3e\").replace(/@/g, \"\\\\40\");\n\t            },\n\t\n\t            /** Function: unescapeNode\n\t             *  Unescape a node part (also called local part) of a JID.\n\t             *\n\t             *  Parameters:\n\t             *    (String) node - A node (or local part).\n\t             *\n\t             *  Returns:\n\t             *    An unescaped node (or local part).\n\t             */\n\t            unescapeNode: function unescapeNode(node) {\n\t                if (typeof node !== \"string\") {\n\t                    return node;\n\t                }\n\t                return node.replace(/\\\\20/g, \" \").replace(/\\\\22/g, '\"').replace(/\\\\26/g, \"&\").replace(/\\\\27/g, \"'\").replace(/\\\\2f/g, \"/\").replace(/\\\\3a/g, \":\").replace(/\\\\3c/g, \"<\").replace(/\\\\3e/g, \">\").replace(/\\\\40/g, \"@\").replace(/\\\\5c/g, \"\\\\\");\n\t            },\n\t\n\t            /** Function: getNodeFromJid\n\t             *  Get the node portion of a JID String.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - A JID.\n\t             *\n\t             *  Returns:\n\t             *    A String containing the node.\n\t             */\n\t            getNodeFromJid: function getNodeFromJid(jid) {\n\t                if (jid.indexOf(\"@\") < 0) {\n\t                    return null;\n\t                }\n\t                return jid.split(\"@\")[0];\n\t            },\n\t\n\t            /** Function: getDomainFromJid\n\t             *  Get the domain portion of a JID String.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - A JID.\n\t             *\n\t             *  Returns:\n\t             *    A String containing the domain.\n\t             */\n\t            getDomainFromJid: function getDomainFromJid(jid) {\n\t                var bare = Strophe.getBareJidFromJid(jid);\n\t                if (bare.indexOf(\"@\") < 0) {\n\t                    return bare;\n\t                } else {\n\t                    var parts = bare.split(\"@\");\n\t                    parts.splice(0, 1);\n\t                    return parts.join('@');\n\t                }\n\t            },\n\t\n\t            /** Function: getResourceFromJid\n\t             *  Get the resource portion of a JID String.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - A JID.\n\t             *\n\t             *  Returns:\n\t             *    A String containing the resource.\n\t             */\n\t            getResourceFromJid: function getResourceFromJid(jid) {\n\t                var s = jid.split(\"/\");\n\t                if (s.length < 2) {\n\t                    return null;\n\t                }\n\t                s.splice(0, 1);\n\t                return s.join('/');\n\t            },\n\t\n\t            /** Function: getBareJidFromJid\n\t             *  Get the bare JID from a JID String.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - A JID.\n\t             *\n\t             *  Returns:\n\t             *    A String containing the bare JID.\n\t             */\n\t            getBareJidFromJid: function getBareJidFromJid(jid) {\n\t                return jid ? jid.split(\"/\")[0] : null;\n\t            },\n\t\n\t            /** PrivateFunction: _handleError\n\t             *  _Private_ function that properly logs an error to the console\n\t             */\n\t            _handleError: function _handleError(e) {\n\t                if (typeof e.stack !== \"undefined\") {\n\t                    Strophe.fatal(e.stack);\n\t                }\n\t                if (e.sourceURL) {\n\t                    Strophe.fatal(\"error: \" + this.handler + \" \" + e.sourceURL + \":\" + e.line + \" - \" + e.name + \": \" + e.message);\n\t                } else if (e.fileName) {\n\t                    Strophe.fatal(\"error: \" + this.handler + \" \" + e.fileName + \":\" + e.lineNumber + \" - \" + e.name + \": \" + e.message);\n\t                } else {\n\t                    Strophe.fatal(\"error: \" + e.message);\n\t                }\n\t            },\n\t\n\t            /** Function: log\n\t             *  User overrideable logging function.\n\t             *\n\t             *  This function is called whenever the Strophe library calls any\n\t             *  of the logging functions.  The default implementation of this\n\t             *  function does nothing.  If client code wishes to handle the logging\n\t             *  messages, it should override this with\n\t             *  > Strophe.log = function (level, msg) {\n\t             *  >   (user code here)\n\t             *  > };\n\t             *\n\t             *  Please note that data sent and received over the wire is logged\n\t             *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\n\t             *\n\t             *  The different levels and their meanings are\n\t             *\n\t             *    DEBUG - Messages useful for debugging purposes.\n\t             *    INFO - Informational messages.  This is mostly information like\n\t             *      'disconnect was called' or 'SASL auth succeeded'.\n\t             *    WARN - Warnings about potential problems.  This is mostly used\n\t             *      to report transient connection errors like request timeouts.\n\t             *    ERROR - Some error occurred.\n\t             *    FATAL - A non-recoverable fatal error occurred.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) level - The log level of the log message.  This will\n\t             *      be one of the values in Strophe.LogLevel.\n\t             *    (String) msg - The log message.\n\t             */\n\t            /* jshint ignore:start */\n\t            log: function log(level, msg) {\n\t                return;\n\t            },\n\t            /* jshint ignore:end */\n\t\n\t            /** Function: debug\n\t             *  Log a message at the Strophe.LogLevel.DEBUG level.\n\t             *\n\t             *  Parameters:\n\t             *    (String) msg - The log message.\n\t             */\n\t            debug: function debug(msg) {\n\t                this.log(this.LogLevel.DEBUG, msg);\n\t            },\n\t\n\t            /** Function: info\n\t             *  Log a message at the Strophe.LogLevel.INFO level.\n\t             *\n\t             *  Parameters:\n\t             *    (String) msg - The log message.\n\t             */\n\t            info: function info(msg) {\n\t                this.log(this.LogLevel.INFO, msg);\n\t            },\n\t\n\t            /** Function: warn\n\t             *  Log a message at the Strophe.LogLevel.WARN level.\n\t             *\n\t             *  Parameters:\n\t             *    (String) msg - The log message.\n\t             */\n\t            warn: function warn(msg) {\n\t                this.log(this.LogLevel.WARN, msg);\n\t            },\n\t\n\t            /** Function: error\n\t             *  Log a message at the Strophe.LogLevel.ERROR level.\n\t             *\n\t             *  Parameters:\n\t             *    (String) msg - The log message.\n\t             */\n\t            error: function error(msg) {\n\t                this.log(this.LogLevel.ERROR, msg);\n\t            },\n\t\n\t            /** Function: fatal\n\t             *  Log a message at the Strophe.LogLevel.FATAL level.\n\t             *\n\t             *  Parameters:\n\t             *    (String) msg - The log message.\n\t             */\n\t            fatal: function fatal(msg) {\n\t                this.log(this.LogLevel.FATAL, msg);\n\t            },\n\t\n\t            /** Function: serialize\n\t             *  Render a DOM element and all descendants to a String.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - A DOM element.\n\t             *\n\t             *  Returns:\n\t             *    The serialized element tree as a String.\n\t             */\n\t            serialize: function serialize(elem) {\n\t                var result;\n\t\n\t                if (!elem) {\n\t                    return null;\n\t                }\n\t\n\t                if (typeof elem.tree === \"function\") {\n\t                    elem = elem.tree();\n\t                }\n\t\n\t                var nodeName = elem.nodeName;\n\t                var i, child;\n\t\n\t                if (elem.getAttribute(\"_realname\")) {\n\t                    nodeName = elem.getAttribute(\"_realname\");\n\t                }\n\t\n\t                result = \"<\" + nodeName;\n\t                for (i = 0; i < elem.attributes.length; i++) {\n\t                    if (elem.attributes[i].nodeName !== \"_realname\") {\n\t                        result += \" \" + elem.attributes[i].nodeName + \"='\" + Strophe.xmlescape(elem.attributes[i].value) + \"'\";\n\t                    }\n\t                }\n\t\n\t                if (elem.childNodes.length > 0) {\n\t                    result += \">\";\n\t                    for (i = 0; i < elem.childNodes.length; i++) {\n\t                        child = elem.childNodes[i];\n\t                        switch (child.nodeType) {\n\t                            case Strophe.ElementType.NORMAL:\n\t                                // normal element, so recurse\n\t                                result += Strophe.serialize(child);\n\t                                break;\n\t                            case Strophe.ElementType.TEXT:\n\t                                // text element to escape values\n\t                                result += Strophe.xmlescape(child.nodeValue);\n\t                                break;\n\t                            case Strophe.ElementType.CDATA:\n\t                                // cdata section so don't escape values\n\t                                result += \"<![CDATA[\" + child.nodeValue + \"]]>\";\n\t                        }\n\t                    }\n\t                    result += \"</\" + nodeName + \">\";\n\t                } else {\n\t                    result += \"/>\";\n\t                }\n\t\n\t                return result;\n\t            },\n\t\n\t            /** PrivateVariable: _requestId\n\t             *  _Private_ variable that keeps track of the request ids for\n\t             *  connections.\n\t             */\n\t            _requestId: 0,\n\t\n\t            /** PrivateVariable: Strophe.connectionPlugins\n\t             *  _Private_ variable Used to store plugin names that need\n\t             *  initialization on Strophe.Connection construction.\n\t             */\n\t            _connectionPlugins: {},\n\t\n\t            /** Function: addConnectionPlugin\n\t             *  Extends the Strophe.Connection object with the given plugin.\n\t             *\n\t             *  Parameters:\n\t             *    (String) name - The name of the extension.\n\t             *    (Object) ptype - The plugin's prototype.\n\t             */\n\t            addConnectionPlugin: function addConnectionPlugin(name, ptype) {\n\t                Strophe._connectionPlugins[name] = ptype;\n\t            }\n\t        };\n\t\n\t        /** Class: Strophe.Builder\n\t         *  XML DOM builder.\n\t         *\n\t         *  This object provides an interface similar to JQuery but for building\n\t         *  DOM elements easily and rapidly.  All the functions except for toString()\n\t         *  and tree() return the object, so calls can be chained.  Here's an\n\t         *  example using the $iq() builder helper.\n\t         *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\n\t         *  >     .c('query', {xmlns: 'strophe:example'})\n\t         *  >     .c('example')\n\t         *  >     .toString()\n\t         *\n\t         *  The above generates this XML fragment\n\t         *  > <iq to='you' from='me' type='get' id='1'>\n\t         *  >   <query xmlns='strophe:example'>\n\t         *  >     <example/>\n\t         *  >   </query>\n\t         *  > </iq>\n\t         *  The corresponding DOM manipulations to get a similar fragment would be\n\t         *  a lot more tedious and probably involve several helper variables.\n\t         *\n\t         *  Since adding children makes new operations operate on the child, up()\n\t         *  is provided to traverse up the tree.  To add two children, do\n\t         *  > builder.c('child1', ...).up().c('child2', ...)\n\t         *  The next operation on the Builder will be relative to the second child.\n\t         */\n\t\n\t        /** Constructor: Strophe.Builder\n\t         *  Create a Strophe.Builder object.\n\t         *\n\t         *  The attributes should be passed in object notation.  For example\n\t         *  > var b = new Builder('message', {to: 'you', from: 'me'});\n\t         *  or\n\t         *  > var b = new Builder('messsage', {'xml:lang': 'en'});\n\t         *\n\t         *  Parameters:\n\t         *    (String) name - The name of the root element.\n\t         *    (Object) attrs - The attributes for the root element in object notation.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Builder.\n\t         */\n\t        Strophe.Builder = function (name, attrs) {\n\t            // Set correct namespace for jabber:client elements\n\t            if (name === \"presence\" || name === \"message\" || name === \"iq\") {\n\t                if (attrs && !attrs.xmlns) {\n\t                    attrs.xmlns = Strophe.NS.CLIENT;\n\t                } else if (!attrs) {\n\t                    attrs = { xmlns: Strophe.NS.CLIENT };\n\t                }\n\t            }\n\t\n\t            // Holds the tree being built.\n\t            this.nodeTree = Strophe.xmlElement(name, attrs);\n\t\n\t            // Points to the current operation node.\n\t            this.node = this.nodeTree;\n\t        };\n\t\n\t        Strophe.Builder.prototype = {\n\t            /** Function: tree\n\t             *  Return the DOM tree.\n\t             *\n\t             *  This function returns the current DOM tree as an element object.  This\n\t             *  is suitable for passing to functions like Strophe.Connection.send().\n\t             *\n\t             *  Returns:\n\t             *    The DOM tree as a element object.\n\t             */\n\t            tree: function tree() {\n\t                return this.nodeTree;\n\t            },\n\t\n\t            /** Function: toString\n\t             *  Serialize the DOM tree to a String.\n\t             *\n\t             *  This function returns a string serialization of the current DOM\n\t             *  tree.  It is often used internally to pass data to a\n\t             *  Strophe.Request object.\n\t             *\n\t             *  Returns:\n\t             *    The serialized DOM tree in a String.\n\t             */\n\t            toString: function toString() {\n\t                return Strophe.serialize(this.nodeTree);\n\t            },\n\t\n\t            /** Function: up\n\t             *  Make the current parent element the new current element.\n\t             *\n\t             *  This function is often used after c() to traverse back up the tree.\n\t             *  For example, to add two children to the same element\n\t             *  > builder.c('child1', {}).up().c('child2', {});\n\t             *\n\t             *  Returns:\n\t             *    The Stophe.Builder object.\n\t             */\n\t            up: function up() {\n\t                this.node = this.node.parentNode;\n\t                return this;\n\t            },\n\t\n\t            /** Function: root\n\t             *  Make the root element the new current element.\n\t             *\n\t             *  When at a deeply nested element in the tree, this function can be used\n\t             *  to jump back to the root of the tree, instead of having to repeatedly\n\t             *  call up().\n\t             *\n\t             *  Returns:\n\t             *    The Stophe.Builder object.\n\t             */\n\t            root: function root() {\n\t                this.node = this.nodeTree;\n\t                return this;\n\t            },\n\t\n\t            /** Function: attrs\n\t             *  Add or modify attributes of the current element.\n\t             *\n\t             *  The attributes should be passed in object notation.  This function\n\t             *  does not move the current element pointer.\n\t             *\n\t             *  Parameters:\n\t             *    (Object) moreattrs - The attributes to add/modify in object notation.\n\t             *\n\t             *  Returns:\n\t             *    The Strophe.Builder object.\n\t             */\n\t            attrs: function attrs(moreattrs) {\n\t                for (var k in moreattrs) {\n\t                    if (moreattrs.hasOwnProperty(k)) {\n\t                        if (moreattrs[k] === undefined) {\n\t                            this.node.removeAttribute(k);\n\t                        } else {\n\t                            this.node.setAttribute(k, moreattrs[k]);\n\t                        }\n\t                    }\n\t                }\n\t                return this;\n\t            },\n\t\n\t            /** Function: c\n\t             *  Add a child to the current element and make it the new current\n\t             *  element.\n\t             *\n\t             *  This function moves the current element pointer to the child,\n\t             *  unless text is provided.  If you need to add another child, it\n\t             *  is necessary to use up() to go back to the parent in the tree.\n\t             *\n\t             *  Parameters:\n\t             *    (String) name - The name of the child.\n\t             *    (Object) attrs - The attributes of the child in object notation.\n\t             *    (String) text - The text to add to the child.\n\t             *\n\t             *  Returns:\n\t             *    The Strophe.Builder object.\n\t             */\n\t            c: function c(name, attrs, text) {\n\t                var child = Strophe.xmlElement(name, attrs, text);\n\t                this.node.appendChild(child);\n\t                if (typeof text !== \"string\" && typeof text !== \"number\") {\n\t                    this.node = child;\n\t                }\n\t                return this;\n\t            },\n\t\n\t            /** Function: cnode\n\t             *  Add a child to the current element and make it the new current\n\t             *  element.\n\t             *\n\t             *  This function is the same as c() except that instead of using a\n\t             *  name and an attributes object to create the child it uses an\n\t             *  existing DOM element object.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - A DOM element.\n\t             *\n\t             *  Returns:\n\t             *    The Strophe.Builder object.\n\t             */\n\t            cnode: function cnode(elem) {\n\t                var impNode;\n\t                var xmlGen = Strophe.xmlGenerator();\n\t                try {\n\t                    impNode = xmlGen.importNode !== undefined;\n\t                } catch (e) {\n\t                    impNode = false;\n\t                }\n\t                var newElem = impNode ? xmlGen.importNode(elem, true) : Strophe.copyElement(elem);\n\t                this.node.appendChild(newElem);\n\t                this.node = newElem;\n\t                return this;\n\t            },\n\t\n\t            /** Function: t\n\t             *  Add a child text element.\n\t             *\n\t             *  This *does not* make the child the new current element since there\n\t             *  are no children of text elements.\n\t             *\n\t             *  Parameters:\n\t             *    (String) text - The text data to append to the current element.\n\t             *\n\t             *  Returns:\n\t             *    The Strophe.Builder object.\n\t             */\n\t            t: function t(text) {\n\t                var child = Strophe.xmlTextNode(text);\n\t                this.node.appendChild(child);\n\t                return this;\n\t            },\n\t\n\t            /** Function: h\n\t             *  Replace current element contents with the HTML passed in.\n\t             *\n\t             *  This *does not* make the child the new current element\n\t             *\n\t             *  Parameters:\n\t             *    (String) html - The html to insert as contents of current element.\n\t             *\n\t             *  Returns:\n\t             *    The Strophe.Builder object.\n\t             */\n\t            h: function h(html) {\n\t                var fragment = document.createElement('body');\n\t\n\t                // force the browser to try and fix any invalid HTML tags\n\t                fragment.innerHTML = html;\n\t\n\t                // copy cleaned html into an xml dom\n\t                var xhtml = Strophe.createHtml(fragment);\n\t\n\t                while (xhtml.childNodes.length > 0) {\n\t                    this.node.appendChild(xhtml.childNodes[0]);\n\t                }\n\t                return this;\n\t            }\n\t        };\n\t\n\t        /** PrivateClass: Strophe.Handler\n\t         *  _Private_ helper class for managing stanza handlers.\n\t         *\n\t         *  A Strophe.Handler encapsulates a user provided callback function to be\n\t         *  executed when matching stanzas are received by the connection.\n\t         *  Handlers can be either one-off or persistant depending on their\n\t         *  return value. Returning true will cause a Handler to remain active, and\n\t         *  returning false will remove the Handler.\n\t         *\n\t         *  Users will not use Strophe.Handler objects directly, but instead they\n\t         *  will use Strophe.Connection.addHandler() and\n\t         *  Strophe.Connection.deleteHandler().\n\t         */\n\t\n\t        /** PrivateConstructor: Strophe.Handler\n\t         *  Create and initialize a new Strophe.Handler.\n\t         *\n\t         *  Parameters:\n\t         *    (Function) handler - A function to be executed when the handler is run.\n\t         *    (String) ns - The namespace to match.\n\t         *    (String) name - The element name to match.\n\t         *    (String) type - The element type to match.\n\t         *    (String) id - The element id attribute to match.\n\t         *    (String) from - The element from attribute to match.\n\t         *    (Object) options - Handler options\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Handler object.\n\t         */\n\t        Strophe.Handler = function (handler, ns, name, type, id, from, options) {\n\t            this.handler = handler;\n\t            this.ns = ns;\n\t            this.name = name;\n\t            this.type = type;\n\t            this.id = id;\n\t            this.options = options || { 'matchBareFromJid': false, 'ignoreNamespaceFragment': false };\n\t            // BBB: Maintain backward compatibility with old `matchBare` option\n\t            if (this.options.matchBare) {\n\t                Strophe.warn('The \"matchBare\" option is deprecated, use \"matchBareFromJid\" instead.');\n\t                this.options.matchBareFromJid = this.options.matchBare;\n\t                delete this.options.matchBare;\n\t            }\n\t\n\t            if (this.options.matchBareFromJid) {\n\t                this.from = from ? Strophe.getBareJidFromJid(from) : null;\n\t            } else {\n\t                this.from = from;\n\t            }\n\t            // whether the handler is a user handler or a system handler\n\t            this.user = true;\n\t        };\n\t\n\t        Strophe.Handler.prototype = {\n\t            /** PrivateFunction: getNamespace\n\t             *  Returns the XML namespace attribute on an element.\n\t             *  If `ignoreNamespaceFragment` was passed in for this handler, then the\n\t             *  URL fragment will be stripped.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The XML element with the namespace.\n\t             *\n\t             *  Returns:\n\t             *    The namespace, with optionally the fragment stripped.\n\t             */\n\t            getNamespace: function getNamespace(elem) {\n\t                var elNamespace = elem.getAttribute(\"xmlns\");\n\t                if (elNamespace && this.options.ignoreNamespaceFragment) {\n\t                    elNamespace = elNamespace.split('#')[0];\n\t                }\n\t                return elNamespace;\n\t            },\n\t\n\t            /** PrivateFunction: namespaceMatch\n\t             *  Tests if a stanza matches the namespace set for this Strophe.Handler.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The XML element to test.\n\t             *\n\t             *  Returns:\n\t             *    true if the stanza matches and false otherwise.\n\t             */\n\t            namespaceMatch: function namespaceMatch(elem) {\n\t                var nsMatch = false;\n\t                if (!this.ns) {\n\t                    return true;\n\t                } else {\n\t                    var that = this;\n\t                    Strophe.forEachChild(elem, null, function (elem) {\n\t                        if (that.getNamespace(elem) === that.ns) {\n\t                            nsMatch = true;\n\t                        }\n\t                    });\n\t                    nsMatch = nsMatch || this.getNamespace(elem) === this.ns;\n\t                }\n\t                return nsMatch;\n\t            },\n\t\n\t            /** PrivateFunction: isMatch\n\t             *  Tests if a stanza matches the Strophe.Handler.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The XML element to test.\n\t             *\n\t             *  Returns:\n\t             *    true if the stanza matches and false otherwise.\n\t             */\n\t            isMatch: function isMatch(elem) {\n\t                var from = elem.getAttribute('from');\n\t                if (this.options.matchBareFromJid) {\n\t                    from = Strophe.getBareJidFromJid(from);\n\t                }\n\t                var elem_type = elem.getAttribute(\"type\");\n\t                if (this.namespaceMatch(elem) && (!this.name || Strophe.isTagEqual(elem, this.name)) && (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) && (!this.id || elem.getAttribute(\"id\") === this.id) && (!this.from || from === this.from)) {\n\t                    return true;\n\t                }\n\t                return false;\n\t            },\n\t\n\t            /** PrivateFunction: run\n\t             *  Run the callback on a matching stanza.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The DOM element that triggered the\n\t             *      Strophe.Handler.\n\t             *\n\t             *  Returns:\n\t             *    A boolean indicating if the handler should remain active.\n\t             */\n\t            run: function run(elem) {\n\t                var result = null;\n\t                try {\n\t                    result = this.handler(elem);\n\t                } catch (e) {\n\t                    Strophe._handleError(e);\n\t                    throw e;\n\t                }\n\t                return result;\n\t            },\n\t\n\t            /** PrivateFunction: toString\n\t             *  Get a String representation of the Strophe.Handler object.\n\t             *\n\t             *  Returns:\n\t             *    A String.\n\t             */\n\t            toString: function toString() {\n\t                return \"{Handler: \" + this.handler + \"(\" + this.name + \",\" + this.id + \",\" + this.ns + \")}\";\n\t            }\n\t        };\n\t\n\t        /** PrivateClass: Strophe.TimedHandler\n\t         *  _Private_ helper class for managing timed handlers.\n\t         *\n\t         *  A Strophe.TimedHandler encapsulates a user provided callback that\n\t         *  should be called after a certain period of time or at regular\n\t         *  intervals.  The return value of the callback determines whether the\n\t         *  Strophe.TimedHandler will continue to fire.\n\t         *\n\t         *  Users will not use Strophe.TimedHandler objects directly, but instead\n\t         *  they will use Strophe.Connection.addTimedHandler() and\n\t         *  Strophe.Connection.deleteTimedHandler().\n\t         */\n\t\n\t        /** PrivateConstructor: Strophe.TimedHandler\n\t         *  Create and initialize a new Strophe.TimedHandler object.\n\t         *\n\t         *  Parameters:\n\t         *    (Integer) period - The number of milliseconds to wait before the\n\t         *      handler is called.\n\t         *    (Function) handler - The callback to run when the handler fires.  This\n\t         *      function should take no arguments.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.TimedHandler object.\n\t         */\n\t        Strophe.TimedHandler = function (period, handler) {\n\t            this.period = period;\n\t            this.handler = handler;\n\t            this.lastCalled = new Date().getTime();\n\t            this.user = true;\n\t        };\n\t\n\t        Strophe.TimedHandler.prototype = {\n\t            /** PrivateFunction: run\n\t             *  Run the callback for the Strophe.TimedHandler.\n\t             *\n\t             *  Returns:\n\t             *    true if the Strophe.TimedHandler should be called again, and false\n\t             *      otherwise.\n\t             */\n\t            run: function run() {\n\t                this.lastCalled = new Date().getTime();\n\t                return this.handler();\n\t            },\n\t\n\t            /** PrivateFunction: reset\n\t             *  Reset the last called time for the Strophe.TimedHandler.\n\t             */\n\t            reset: function reset() {\n\t                this.lastCalled = new Date().getTime();\n\t            },\n\t\n\t            /** PrivateFunction: toString\n\t             *  Get a string representation of the Strophe.TimedHandler object.\n\t             *\n\t             *  Returns:\n\t             *    The string representation.\n\t             */\n\t            toString: function toString() {\n\t                return \"{TimedHandler: \" + this.handler + \"(\" + this.period + \")}\";\n\t            }\n\t        };\n\t\n\t        /** Class: Strophe.Connection\n\t         *  XMPP Connection manager.\n\t         *\n\t         *  This class is the main part of Strophe.  It manages a BOSH or websocket\n\t         *  connection to an XMPP server and dispatches events to the user callbacks\n\t         *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\n\t         *  and legacy authentication.\n\t         *\n\t         *  After creating a Strophe.Connection object, the user will typically\n\t         *  call connect() with a user supplied callback to handle connection level\n\t         *  events like authentication failure, disconnection, or connection\n\t         *  complete.\n\t         *\n\t         *  The user will also have several event handlers defined by using\n\t         *  addHandler() and addTimedHandler().  These will allow the user code to\n\t         *  respond to interesting stanzas or do something periodically with the\n\t         *  connection. These handlers will be active once authentication is\n\t         *  finished.\n\t         *\n\t         *  To send data to the connection, use send().\n\t         */\n\t\n\t        /** Constructor: Strophe.Connection\n\t         *  Create and initialize a Strophe.Connection object.\n\t         *\n\t         *  The transport-protocol for this connection will be chosen automatically\n\t         *  based on the given service parameter. URLs starting with \"ws://\" or\n\t         *  \"wss://\" will use WebSockets, URLs starting with \"http://\", \"https://\"\n\t         *  or without a protocol will use BOSH.\n\t         *\n\t         *  To make Strophe connect to the current host you can leave out the protocol\n\t         *  and host part and just pass the path, e.g.\n\t         *\n\t         *  > var conn = new Strophe.Connection(\"/http-bind/\");\n\t         *\n\t         *  Options common to both Websocket and BOSH:\n\t         *  ------------------------------------------\n\t         *\n\t         *  cookies:\n\t         *\n\t         *  The *cookies* option allows you to pass in cookies to be added to the\n\t         *  document. These cookies will then be included in the BOSH XMLHttpRequest\n\t         *  or in the websocket connection.\n\t         *\n\t         *  The passed in value must be a map of cookie names and string values.\n\t         *\n\t         *  > { \"myCookie\": {\n\t         *  >     \"value\": \"1234\",\n\t         *  >     \"domain\": \".example.org\",\n\t         *  >     \"path\": \"/\",\n\t         *  >     \"expires\": expirationDate\n\t         *  >     }\n\t         *  > }\n\t         *\n\t         *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\n\t         *  Those cookies need to be set under those domains, for example they can be\n\t         *  set server-side by making a XHR call to that domain to ask it to set any\n\t         *  necessary cookies.\n\t         *\n\t         *  mechanisms:\n\t         *\n\t         *  The *mechanisms* option allows you to specify the SASL mechanisms that this\n\t         *  instance of Strophe.Connection (and therefore your XMPP client) will\n\t         *  support.\n\t         *\n\t         *  The value must be an array of objects with Strophe.SASLMechanism\n\t         *  prototypes.\n\t         *\n\t         *  If nothing is specified, then the following mechanisms (and their\n\t         *  priorities) are registered:\n\t         *\n\t         *      OAUTHBEARER - 60\n\t         *      SCRAM-SHA1 - 50\n\t         *      DIGEST-MD5 - 40\n\t         *      PLAIN - 30\n\t         *      ANONYMOUS - 20\n\t         *      EXTERNAL - 10\n\t         *\n\t         *  WebSocket options:\n\t         *  ------------------\n\t         *\n\t         *  If you want to connect to the current host with a WebSocket connection you\n\t         *  can tell Strophe to use WebSockets through a \"protocol\" attribute in the\n\t         *  optional options parameter. Valid values are \"ws\" for WebSocket and \"wss\"\n\t         *  for Secure WebSocket.\n\t         *  So to connect to \"wss://CURRENT_HOSTNAME/xmpp-websocket\" you would call\n\t         *\n\t         *  > var conn = new Strophe.Connection(\"/xmpp-websocket/\", {protocol: \"wss\"});\n\t         *\n\t         *  Note that relative URLs _NOT_ starting with a \"/\" will also include the path\n\t         *  of the current site.\n\t         *\n\t         *  Also because downgrading security is not permitted by browsers, when using\n\t         *  relative URLs both BOSH and WebSocket connections will use their secure\n\t         *  variants if the current connection to the site is also secure (https).\n\t         *\n\t         *  BOSH options:\n\t         *  -------------\n\t         *\n\t         *  By adding \"sync\" to the options, you can control if requests will\n\t         *  be made synchronously or not. The default behaviour is asynchronous.\n\t         *  If you want to make requests synchronous, make \"sync\" evaluate to true.\n\t         *  > var conn = new Strophe.Connection(\"/http-bind/\", {sync: true});\n\t         *\n\t         *  You can also toggle this on an already established connection.\n\t         *  > conn.options.sync = true;\n\t         *\n\t         *  The *customHeaders* option can be used to provide custom HTTP headers to be\n\t         *  included in the XMLHttpRequests made.\n\t         *\n\t         *  The *keepalive* option can be used to instruct Strophe to maintain the\n\t         *  current BOSH session across interruptions such as webpage reloads.\n\t         *\n\t         *  It will do this by caching the sessions tokens in sessionStorage, and when\n\t         *  \"restore\" is called it will check whether there are cached tokens with\n\t         *  which it can resume an existing session.\n\t         *\n\t         *  The *withCredentials* option should receive a Boolean value and is used to\n\t         *  indicate wether cookies should be included in ajax requests (by default\n\t         *  they're not).\n\t         *  Set this value to true if you are connecting to a BOSH service\n\t         *  and for some reason need to send cookies to it.\n\t         *  In order for this to work cross-domain, the server must also enable\n\t         *  credentials by setting the Access-Control-Allow-Credentials response header\n\t         *  to \"true\". For most usecases however this setting should be false (which\n\t         *  is the default).\n\t         *  Additionally, when using Access-Control-Allow-Credentials, the\n\t         *  Access-Control-Allow-Origin header can't be set to the wildcard \"*\", but\n\t         *  instead must be restricted to actual domains.\n\t         *\n\t         *  The *contentType* option can be set to change the default Content-Type\n\t         *  of \"text/xml; charset=utf-8\", which can be useful to reduce the amount of\n\t         *  CORS preflight requests that are sent to the server.\n\t         *\n\t         *  Parameters:\n\t         *    (String) service - The BOSH or WebSocket service URL.\n\t         *    (Object) options - A hash of configuration options\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Connection object.\n\t         */\n\t        Strophe.Connection = function (service, options) {\n\t            // The service URL\n\t            this.service = service;\n\t            // Configuration options\n\t            this.options = options || {};\n\t            var proto = this.options.protocol || \"\";\n\t\n\t            // Select protocal based on service or options\n\t            if (service.indexOf(\"ws:\") === 0 || service.indexOf(\"wss:\") === 0 || proto.indexOf(\"ws\") === 0) {\n\t                this._proto = new Strophe.Websocket(this);\n\t            } else {\n\t                this._proto = new Strophe.Bosh(this);\n\t            }\n\t\n\t            /* The connected JID. */\n\t            this.jid = \"\";\n\t            /* the JIDs domain */\n\t            this.domain = null;\n\t            /* stream:features */\n\t            this.features = null;\n\t\n\t            // SASL\n\t            this._sasl_data = {};\n\t            this.do_session = false;\n\t            this.do_bind = false;\n\t\n\t            // handler lists\n\t            this.timedHandlers = [];\n\t            this.handlers = [];\n\t            this.removeTimeds = [];\n\t            this.removeHandlers = [];\n\t            this.addTimeds = [];\n\t            this.addHandlers = [];\n\t            this.protocolErrorHandlers = {\n\t                'HTTP': {},\n\t                'websocket': {}\n\t            };\n\t\n\t            this._idleTimeout = null;\n\t            this._disconnectTimeout = null;\n\t\n\t            this.authenticated = false;\n\t            this.connected = false;\n\t            this.disconnecting = false;\n\t            this.do_authentication = true;\n\t            this.paused = false;\n\t            this.restored = false;\n\t\n\t            this._data = [];\n\t            this._uniqueId = 0;\n\t\n\t            this._sasl_success_handler = null;\n\t            this._sasl_failure_handler = null;\n\t            this._sasl_challenge_handler = null;\n\t\n\t            // Max retries before disconnecting\n\t            this.maxRetries = 5;\n\t\n\t            // Call onIdle callback every 1/10th of a second\n\t            // XXX: setTimeout should be called only with function expressions (23974bc1)\n\t            this._idleTimeout = setTimeout(function () {\n\t                this._onIdle();\n\t            }.bind(this), 100);\n\t\n\t            utils.addCookies(this.options.cookies);\n\t            this.registerSASLMechanisms(this.options.mechanisms);\n\t\n\t            // initialize plugins\n\t            for (var k in Strophe._connectionPlugins) {\n\t                if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n\t                    var ptype = Strophe._connectionPlugins[k];\n\t                    // jslint complaints about the below line, but this is fine\n\t                    var F = function F() {}; // jshint ignore:line\n\t                    F.prototype = ptype;\n\t                    this[k] = new F();\n\t                    this[k].init(this);\n\t                }\n\t            }\n\t        };\n\t\n\t        Strophe.Connection.prototype = {\n\t            /** Function: reset\n\t             *  Reset the connection.\n\t             *\n\t             *  This function should be called after a connection is disconnected\n\t             *  before that connection is reused.\n\t             */\n\t            reset: function reset() {\n\t                this._proto._reset();\n\t\n\t                // SASL\n\t                this.do_session = false;\n\t                this.do_bind = false;\n\t\n\t                // handler lists\n\t                this.timedHandlers = [];\n\t                this.handlers = [];\n\t                this.removeTimeds = [];\n\t                this.removeHandlers = [];\n\t                this.addTimeds = [];\n\t                this.addHandlers = [];\n\t\n\t                this.authenticated = false;\n\t                this.connected = false;\n\t                this.disconnecting = false;\n\t                this.restored = false;\n\t\n\t                this._data = [];\n\t                this._requests = [];\n\t                this._uniqueId = 0;\n\t            },\n\t\n\t            /** Function: pause\n\t             *  Pause the request manager.\n\t             *\n\t             *  This will prevent Strophe from sending any more requests to the\n\t             *  server.  This is very useful for temporarily pausing\n\t             *  BOSH-Connections while a lot of send() calls are happening quickly.\n\t             *  This causes Strophe to send the data in a single request, saving\n\t             *  many request trips.\n\t             */\n\t            pause: function pause() {\n\t                this.paused = true;\n\t            },\n\t\n\t            /** Function: resume\n\t             *  Resume the request manager.\n\t             *\n\t             *  This resumes after pause() has been called.\n\t             */\n\t            resume: function resume() {\n\t                this.paused = false;\n\t            },\n\t\n\t            /** Function: getUniqueId\n\t             *  Generate a unique ID for use in <iq/> elements.\n\t             *\n\t             *  All <iq/> stanzas are required to have unique id attributes.  This\n\t             *  function makes creating these easy.  Each connection instance has\n\t             *  a counter which starts from zero, and the value of this counter\n\t             *  plus a colon followed by the suffix becomes the unique id. If no\n\t             *  suffix is supplied, the counter is used as the unique id.\n\t             *\n\t             *  Suffixes are used to make debugging easier when reading the stream\n\t             *  data, and their use is recommended.  The counter resets to 0 for\n\t             *  every new connection for the same reason.  For connections to the\n\t             *  same server that authenticate the same way, all the ids should be\n\t             *  the same, which makes it easy to see changes.  This is useful for\n\t             *  automated testing as well.\n\t             *\n\t             *  Parameters:\n\t             *    (String) suffix - A optional suffix to append to the id.\n\t             *\n\t             *  Returns:\n\t             *    A unique string to be used for the id attribute.\n\t             */\n\t            getUniqueId: function getUniqueId(suffix) {\n\t                var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t                    var r = Math.random() * 16 | 0,\n\t                        v = c === 'x' ? r : r & 0x3 | 0x8;\n\t                    return v.toString(16);\n\t                });\n\t                if (typeof suffix === \"string\" || typeof suffix === \"number\") {\n\t                    return uuid + \":\" + suffix;\n\t                } else {\n\t                    return uuid + \"\";\n\t                }\n\t            },\n\t\n\t            /** Function: addProtocolErrorHandler\n\t             *  Register a handler function for when a protocol (websocker or HTTP)\n\t             *  error occurs.\n\t             *\n\t             *  NOTE: Currently only HTTP errors for BOSH requests are handled.\n\t             *  Patches that handle websocket errors would be very welcome.\n\t             *\n\t             *  Parameters:\n\t             *    (String) protocol - 'HTTP' or 'websocket'\n\t             *    (Integer) status_code - Error status code (e.g 500, 400 or 404)\n\t             *    (Function) callback - Function that will fire on Http error\n\t             *\n\t             *  Example:\n\t             *  function onError(err_code){\n\t             *    //do stuff\n\t             *  }\n\t             *\n\t             *  var conn = Strophe.connect('http://example.com/http-bind');\n\t             *  conn.addProtocolErrorHandler('HTTP', 500, onError);\n\t             *  // Triggers HTTP 500 error and onError handler will be called\n\t             *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);\n\t             */\n\t            addProtocolErrorHandler: function addProtocolErrorHandler(protocol, status_code, callback) {\n\t                this.protocolErrorHandlers[protocol][status_code] = callback;\n\t            },\n\t\n\t            /** Function: connect\n\t             *  Starts the connection process.\n\t             *\n\t             *  As the connection process proceeds, the user supplied callback will\n\t             *  be triggered multiple times with status updates.  The callback\n\t             *  should take two arguments - the status code and the error condition.\n\t             *\n\t             *  The status code will be one of the values in the Strophe.Status\n\t             *  constants.  The error condition will be one of the conditions\n\t             *  defined in RFC 3920 or the condition 'strophe-parsererror'.\n\t             *\n\t             *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\n\t             *  for BOSH connections. Please see XEP 124 for a more detailed explanation\n\t             *  of the optional parameters.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - The user's JID.  This may be a bare JID,\n\t             *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or\n\t             *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will\n\t             *      process the provided password value as an access token).\n\t             *    (String) pass - The user's password.\n\t             *    (Function) callback - The connect callback function.\n\t             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n\t             *      time the server will wait before returning an empty result for\n\t             *      a request.  The default setting of 60 seconds is recommended.\n\t             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n\t             *      number of connections the server will hold at one time.  This\n\t             *      should almost always be set to 1 (the default).\n\t             *    (String) route - The optional route value.\n\t             *    (String) authcid - The optional alternative authentication identity\n\t             *      (username) if intending to impersonate another user.\n\t             *      When using the SASL-EXTERNAL authentication mechanism, for example\n\t             *      with client certificates, then the authcid value is used to\n\t             *      determine whether an authorization JID (authzid) should be sent to\n\t             *      the server. The authzid should not be sent to the server if the\n\t             *      authzid and authcid are the same. So to prevent it from being sent\n\t             *      (for example when the JID is already contained in the client\n\t             *      certificate), set authcid to that same JID. See XEP-178 for more\n\t             *      details.\n\t             */\n\t            connect: function connect(jid, pass, callback, wait, hold, route, authcid) {\n\t                this.jid = jid;\n\t                /** Variable: authzid\n\t                 *  Authorization identity.\n\t                 */\n\t                this.authzid = Strophe.getBareJidFromJid(this.jid);\n\t\n\t                /** Variable: authcid\n\t                 *  Authentication identity (User name).\n\t                 */\n\t                this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\n\t\n\t                /** Variable: pass\n\t                 *  Authentication identity (User password).\n\t                 */\n\t                this.pass = pass;\n\t\n\t                /** Variable: servtype\n\t                 *  Digest MD5 compatibility.\n\t                 */\n\t                this.servtype = \"xmpp\";\n\t\n\t                this.connect_callback = callback;\n\t                this.disconnecting = false;\n\t                this.connected = false;\n\t                this.authenticated = false;\n\t                this.restored = false;\n\t\n\t                // parse jid for domain\n\t                this.domain = Strophe.getDomainFromJid(this.jid);\n\t\n\t                this._changeConnectStatus(Strophe.Status.CONNECTING, null);\n\t\n\t                this._proto._connect(wait, hold, route);\n\t            },\n\t\n\t            /** Function: attach\n\t             *  Attach to an already created and authenticated BOSH session.\n\t             *\n\t             *  This function is provided to allow Strophe to attach to BOSH\n\t             *  sessions which have been created externally, perhaps by a Web\n\t             *  application.  This is often used to support auto-login type features\n\t             *  without putting user credentials into the page.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - The full JID that is bound by the session.\n\t             *    (String) sid - The SID of the BOSH session.\n\t             *    (String) rid - The current RID of the BOSH session.  This RID\n\t             *      will be used by the next request.\n\t             *    (Function) callback The connect callback function.\n\t             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n\t             *      time the server will wait before returning an empty result for\n\t             *      a request.  The default setting of 60 seconds is recommended.\n\t             *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n\t             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n\t             *      number of connections the server will hold at one time.  This\n\t             *      should almost always be set to 1 (the default).\n\t             *    (Integer) wind - The optional HTTBIND window value.  This is the\n\t             *      allowed range of request ids that are valid.  The default is 5.\n\t             */\n\t            attach: function attach(jid, sid, rid, callback, wait, hold, wind) {\n\t                if (this._proto instanceof Strophe.Bosh) {\n\t                    this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\n\t                } else {\n\t                    throw {\n\t                        name: 'StropheSessionError',\n\t                        message: 'The \"attach\" method can only be used with a BOSH connection.'\n\t                    };\n\t                }\n\t            },\n\t\n\t            /** Function: restore\n\t             *  Attempt to restore a cached BOSH session.\n\t             *\n\t             *  This function is only useful in conjunction with providing the\n\t             *  \"keepalive\":true option when instantiating a new Strophe.Connection.\n\t             *\n\t             *  When \"keepalive\" is set to true, Strophe will cache the BOSH tokens\n\t             *  RID (Request ID) and SID (Session ID) and then when this function is\n\t             *  called, it will attempt to restore the session from those cached\n\t             *  tokens.\n\t             *\n\t             *  This function must therefore be called instead of connect or attach.\n\t             *\n\t             *  For an example on how to use it, please see examples/restore.js\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\n\t             *    (Function) callback - The connect callback function.\n\t             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n\t             *      time the server will wait before returning an empty result for\n\t             *      a request.  The default setting of 60 seconds is recommended.\n\t             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n\t             *      number of connections the server will hold at one time.  This\n\t             *      should almost always be set to 1 (the default).\n\t             *    (Integer) wind - The optional HTTBIND window value.  This is the\n\t             *      allowed range of request ids that are valid.  The default is 5.\n\t             */\n\t            restore: function restore(jid, callback, wait, hold, wind) {\n\t                if (this._sessionCachingSupported()) {\n\t                    this._proto._restore(jid, callback, wait, hold, wind);\n\t                } else {\n\t                    throw {\n\t                        name: 'StropheSessionError',\n\t                        message: 'The \"restore\" method can only be used with a BOSH connection.'\n\t                    };\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _sessionCachingSupported\n\t             * Checks whether sessionStorage and JSON are supported and whether we're\n\t             * using BOSH.\n\t             */\n\t            _sessionCachingSupported: function _sessionCachingSupported() {\n\t                if (this._proto instanceof Strophe.Bosh) {\n\t                    if (!JSON) {\n\t                        return false;\n\t                    }\n\t                    try {\n\t                        sessionStorage.setItem('_strophe_', '_strophe_');\n\t                        sessionStorage.removeItem('_strophe_');\n\t                    } catch (e) {\n\t                        return false;\n\t                    }\n\t                    return true;\n\t                }\n\t                return false;\n\t            },\n\t\n\t            /** Function: xmlInput\n\t             *  User overrideable function that receives XML data coming into the\n\t             *  connection.\n\t             *\n\t             *  The default function does nothing.  User code can override this with\n\t             *  > Strophe.Connection.xmlInput = function (elem) {\n\t             *  >   (user code)\n\t             *  > };\n\t             *\n\t             *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n\t             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n\t             *\n\t             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n\t             *  <Strophe.Bosh.strip> if you want to strip this tag.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The XML data received by the connection.\n\t             */\n\t            /* jshint unused:false */\n\t            xmlInput: function xmlInput(elem) {\n\t                return;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** Function: xmlOutput\n\t             *  User overrideable function that receives XML data sent to the\n\t             *  connection.\n\t             *\n\t             *  The default function does nothing.  User code can override this with\n\t             *  > Strophe.Connection.xmlOutput = function (elem) {\n\t             *  >   (user code)\n\t             *  > };\n\t             *\n\t             *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n\t             *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n\t             *\n\t             *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n\t             *  <Strophe.Bosh.strip> if you want to strip this tag.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The XMLdata sent by the connection.\n\t             */\n\t            /* jshint unused:false */\n\t            xmlOutput: function xmlOutput(elem) {\n\t                return;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** Function: rawInput\n\t             *  User overrideable function that receives raw data coming into the\n\t             *  connection.\n\t             *\n\t             *  The default function does nothing.  User code can override this with\n\t             *  > Strophe.Connection.rawInput = function (data) {\n\t             *  >   (user code)\n\t             *  > };\n\t             *\n\t             *  Parameters:\n\t             *    (String) data - The data received by the connection.\n\t             */\n\t            /* jshint unused:false */\n\t            rawInput: function rawInput(data) {\n\t                return;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** Function: rawOutput\n\t             *  User overrideable function that receives raw data sent to the\n\t             *  connection.\n\t             *\n\t             *  The default function does nothing.  User code can override this with\n\t             *  > Strophe.Connection.rawOutput = function (data) {\n\t             *  >   (user code)\n\t             *  > };\n\t             *\n\t             *  Parameters:\n\t             *    (String) data - The data sent by the connection.\n\t             */\n\t            /* jshint unused:false */\n\t            rawOutput: function rawOutput(data) {\n\t                return;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** Function: nextValidRid\n\t             *  User overrideable function that receives the new valid rid.\n\t             *\n\t             *  The default function does nothing. User code can override this with\n\t             *  > Strophe.Connection.nextValidRid = function (rid) {\n\t             *  >    (user code)\n\t             *  > };\n\t             *\n\t             *  Parameters:\n\t             *    (Number) rid - The next valid rid\n\t             */\n\t            /* jshint unused:false */\n\t            nextValidRid: function nextValidRid(rid) {\n\t                return;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** Function: send\n\t             *  Send a stanza.\n\t             *\n\t             *  This function is called to push data onto the send queue to\n\t             *  go out over the wire.  Whenever a request is sent to the BOSH\n\t             *  server, all pending data is sent and the queue is flushed.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement |\n\t             *     [XMLElement] |\n\t             *     Strophe.Builder) elem - The stanza to send.\n\t             */\n\t            send: function send(elem) {\n\t                if (elem === null) {\n\t                    return;\n\t                }\n\t                if (typeof elem.sort === \"function\") {\n\t                    for (var i = 0; i < elem.length; i++) {\n\t                        this._queueData(elem[i]);\n\t                    }\n\t                } else if (typeof elem.tree === \"function\") {\n\t                    this._queueData(elem.tree());\n\t                } else {\n\t                    this._queueData(elem);\n\t                }\n\t\n\t                this._proto._send();\n\t            },\n\t\n\t            /** Function: flush\n\t             *  Immediately send any pending outgoing data.\n\t             *\n\t             *  Normally send() queues outgoing data until the next idle period\n\t             *  (100ms), which optimizes network use in the common cases when\n\t             *  several send()s are called in succession. flush() can be used to\n\t             *  immediately send all pending data.\n\t             */\n\t            flush: function flush() {\n\t                // cancel the pending idle period and run the idle function\n\t                // immediately\n\t                clearTimeout(this._idleTimeout);\n\t                this._onIdle();\n\t            },\n\t\n\t            /** Function: sendPresence\n\t             *  Helper function to send presence stanzas. The main benefit is for\n\t             *  sending presence stanzas for which you expect a responding presence\n\t             *  stanza with the same id (for example when leaving a chat room).\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The stanza to send.\n\t             *    (Function) callback - The callback function for a successful request.\n\t             *    (Function) errback - The callback function for a failed or timed\n\t             *      out request.  On timeout, the stanza will be null.\n\t             *    (Integer) timeout - The time specified in milliseconds for a\n\t             *      timeout to occur.\n\t             *\n\t             *  Returns:\n\t             *    The id used to send the presence.\n\t             */\n\t            sendPresence: function sendPresence(elem, callback, errback, timeout) {\n\t                var timeoutHandler = null;\n\t                var that = this;\n\t                if (typeof elem.tree === \"function\") {\n\t                    elem = elem.tree();\n\t                }\n\t                var id = elem.getAttribute('id');\n\t                if (!id) {\n\t                    // inject id if not found\n\t                    id = this.getUniqueId(\"sendPresence\");\n\t                    elem.setAttribute(\"id\", id);\n\t                }\n\t\n\t                if (typeof callback === \"function\" || typeof errback === \"function\") {\n\t                    var handler = this.addHandler(function (stanza) {\n\t                        // remove timeout handler if there is one\n\t                        if (timeoutHandler) {\n\t                            that.deleteTimedHandler(timeoutHandler);\n\t                        }\n\t                        var type = stanza.getAttribute('type');\n\t                        if (type === 'error') {\n\t                            if (errback) {\n\t                                errback(stanza);\n\t                            }\n\t                        } else if (callback) {\n\t                            callback(stanza);\n\t                        }\n\t                    }, null, 'presence', null, id);\n\t\n\t                    // if timeout specified, set up a timeout handler.\n\t                    if (timeout) {\n\t                        timeoutHandler = this.addTimedHandler(timeout, function () {\n\t                            // get rid of normal handler\n\t                            that.deleteHandler(handler);\n\t                            // call errback on timeout with null stanza\n\t                            if (errback) {\n\t                                errback(null);\n\t                            }\n\t                            return false;\n\t                        });\n\t                    }\n\t                }\n\t                this.send(elem);\n\t                return id;\n\t            },\n\t\n\t            /** Function: sendIQ\n\t             *  Helper function to send IQ stanzas.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The stanza to send.\n\t             *    (Function) callback - The callback function for a successful request.\n\t             *    (Function) errback - The callback function for a failed or timed\n\t             *      out request.  On timeout, the stanza will be null.\n\t             *    (Integer) timeout - The time specified in milliseconds for a\n\t             *      timeout to occur.\n\t             *\n\t             *  Returns:\n\t             *    The id used to send the IQ.\n\t            */\n\t            sendIQ: function sendIQ(elem, callback, errback, timeout) {\n\t                var timeoutHandler = null;\n\t                var that = this;\n\t                if (typeof elem.tree === \"function\") {\n\t                    elem = elem.tree();\n\t                }\n\t                var id = elem.getAttribute('id');\n\t                if (!id) {\n\t                    // inject id if not found\n\t                    id = this.getUniqueId(\"sendIQ\");\n\t                    elem.setAttribute(\"id\", id);\n\t                }\n\t\n\t                if (typeof callback === \"function\" || typeof errback === \"function\") {\n\t                    var handler = this.addHandler(function (stanza) {\n\t                        // remove timeout handler if there is one\n\t                        if (timeoutHandler) {\n\t                            that.deleteTimedHandler(timeoutHandler);\n\t                        }\n\t                        var iqtype = stanza.getAttribute('type');\n\t                        if (iqtype === 'result') {\n\t                            if (callback) {\n\t                                callback(stanza);\n\t                            }\n\t                        } else if (iqtype === 'error') {\n\t                            if (errback) {\n\t                                errback(stanza);\n\t                            }\n\t                        } else {\n\t                            throw {\n\t                                name: \"StropheError\",\n\t                                message: \"Got bad IQ type of \" + iqtype\n\t                            };\n\t                        }\n\t                    }, null, 'iq', ['error', 'result'], id);\n\t\n\t                    // if timeout specified, set up a timeout handler.\n\t                    if (timeout) {\n\t                        timeoutHandler = this.addTimedHandler(timeout, function () {\n\t                            // get rid of normal handler\n\t                            that.deleteHandler(handler);\n\t                            // call errback on timeout with null stanza\n\t                            if (errback) {\n\t                                errback(null);\n\t                            }\n\t                            return false;\n\t                        });\n\t                    }\n\t                }\n\t                this.send(elem);\n\t                return id;\n\t            },\n\t\n\t            /** PrivateFunction: _queueData\n\t             *  Queue outgoing data for later sending.  Also ensures that the data\n\t             *  is a DOMElement.\n\t             */\n\t            _queueData: function _queueData(element) {\n\t                if (element === null || !element.tagName || !element.childNodes) {\n\t                    throw {\n\t                        name: \"StropheError\",\n\t                        message: \"Cannot queue non-DOMElement.\"\n\t                    };\n\t                }\n\t                this._data.push(element);\n\t            },\n\t\n\t            /** PrivateFunction: _sendRestart\n\t             *  Send an xmpp:restart stanza.\n\t             */\n\t            _sendRestart: function _sendRestart() {\n\t                this._data.push(\"restart\");\n\t                this._proto._sendRestart();\n\t                // XXX: setTimeout should be called only with function expressions (23974bc1)\n\t                this._idleTimeout = setTimeout(function () {\n\t                    this._onIdle();\n\t                }.bind(this), 100);\n\t            },\n\t\n\t            /** Function: addTimedHandler\n\t             *  Add a timed handler to the connection.\n\t             *\n\t             *  This function adds a timed handler.  The provided handler will\n\t             *  be called every period milliseconds until it returns false,\n\t             *  the connection is terminated, or the handler is removed.  Handlers\n\t             *  that wish to continue being invoked should return true.\n\t             *\n\t             *  Because of method binding it is necessary to save the result of\n\t             *  this function if you wish to remove a handler with\n\t             *  deleteTimedHandler().\n\t             *\n\t             *  Note that user handlers are not active until authentication is\n\t             *  successful.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) period - The period of the handler.\n\t             *    (Function) handler - The callback function.\n\t             *\n\t             *  Returns:\n\t             *    A reference to the handler that can be used to remove it.\n\t             */\n\t            addTimedHandler: function addTimedHandler(period, handler) {\n\t                var thand = new Strophe.TimedHandler(period, handler);\n\t                this.addTimeds.push(thand);\n\t                return thand;\n\t            },\n\t\n\t            /** Function: deleteTimedHandler\n\t             *  Delete a timed handler for a connection.\n\t             *\n\t             *  This function removes a timed handler from the connection.  The\n\t             *  handRef parameter is *not* the function passed to addTimedHandler(),\n\t             *  but is the reference returned from addTimedHandler().\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.TimedHandler) handRef - The handler reference.\n\t             */\n\t            deleteTimedHandler: function deleteTimedHandler(handRef) {\n\t                // this must be done in the Idle loop so that we don't change\n\t                // the handlers during iteration\n\t                this.removeTimeds.push(handRef);\n\t            },\n\t\n\t            /** Function: addHandler\n\t             *  Add a stanza handler for the connection.\n\t             *\n\t             *  This function adds a stanza handler to the connection.  The\n\t             *  handler callback will be called for any stanza that matches\n\t             *  the parameters.  Note that if multiple parameters are supplied,\n\t             *  they must all match for the handler to be invoked.\n\t             *\n\t             *  The handler will receive the stanza that triggered it as its argument.\n\t             *  *The handler should return true if it is to be invoked again;\n\t             *  returning false will remove the handler after it returns.*\n\t             *\n\t             *  As a convenience, the ns parameters applies to the top level element\n\t             *  and also any of its immediate children.  This is primarily to make\n\t             *  matching /iq/query elements easy.\n\t             *\n\t             *  Options\n\t             *  ~~~~~~~\n\t             *  With the options argument, you can specify boolean flags that affect how\n\t             *  matches are being done.\n\t             *\n\t             *  Currently two flags exist:\n\t             *\n\t             *  - matchBareFromJid:\n\t             *      When set to true, the from parameter and the\n\t             *      from attribute on the stanza will be matched as bare JIDs instead\n\t             *      of full JIDs. To use this, pass {matchBareFromJid: true} as the\n\t             *      value of options. The default value for matchBareFromJid is false.\n\t             *\n\t             *  - ignoreNamespaceFragment:\n\t             *      When set to true, a fragment specified on the stanza's namespace\n\t             *      URL will be ignored when it's matched with the one configured for\n\t             *      the handler.\n\t             *\n\t             *      This means that if you register like this:\n\t             *      >   connection.addHandler(\n\t             *      >       handler,\n\t             *      >       'http://jabber.org/protocol/muc',\n\t             *      >       null, null, null, null,\n\t             *      >       {'ignoreNamespaceFragment': true}\n\t             *      >   );\n\t             *\n\t             *      Then a stanza with XML namespace of\n\t             *      'http://jabber.org/protocol/muc#user' will also be matched. If\n\t             *      'ignoreNamespaceFragment' is false, then only stanzas with\n\t             *      'http://jabber.org/protocol/muc' will be matched.\n\t             *\n\t             *  Deleting the handler\n\t             *  ~~~~~~~~~~~~~~~~~~~~\n\t             *  The return value should be saved if you wish to remove the handler\n\t             *  with deleteHandler().\n\t             *\n\t             *  Parameters:\n\t             *    (Function) handler - The user callback.\n\t             *    (String) ns - The namespace to match.\n\t             *    (String) name - The stanza name to match.\n\t             *    (String|Array) type - The stanza type (or types if an array) to match.\n\t             *    (String) id - The stanza id attribute to match.\n\t             *    (String) from - The stanza from attribute to match.\n\t             *    (String) options - The handler options\n\t             *\n\t             *  Returns:\n\t             *    A reference to the handler that can be used to remove it.\n\t             */\n\t            addHandler: function addHandler(handler, ns, name, type, id, from, options) {\n\t                var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n\t                this.addHandlers.push(hand);\n\t                return hand;\n\t            },\n\t\n\t            /** Function: deleteHandler\n\t             *  Delete a stanza handler for a connection.\n\t             *\n\t             *  This function removes a stanza handler from the connection.  The\n\t             *  handRef parameter is *not* the function passed to addHandler(),\n\t             *  but is the reference returned from addHandler().\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Handler) handRef - The handler reference.\n\t             */\n\t            deleteHandler: function deleteHandler(handRef) {\n\t                // this must be done in the Idle loop so that we don't change\n\t                // the handlers during iteration\n\t                this.removeHandlers.push(handRef);\n\t                // If a handler is being deleted while it is being added,\n\t                // prevent it from getting added\n\t                var i = this.addHandlers.indexOf(handRef);\n\t                if (i >= 0) {\n\t                    this.addHandlers.splice(i, 1);\n\t                }\n\t            },\n\t\n\t            /** Function: registerSASLMechanisms\n\t             *\n\t             * Register the SASL mechanisms which will be supported by this instance of\n\t             * Strophe.Connection (i.e. which this XMPP client will support).\n\t             *\n\t             *  Parameters:\n\t             *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes\n\t             *\n\t             */\n\t            registerSASLMechanisms: function registerSASLMechanisms(mechanisms) {\n\t                this.mechanisms = {};\n\t                mechanisms = mechanisms || [Strophe.SASLAnonymous, Strophe.SASLExternal, Strophe.SASLMD5, Strophe.SASLOAuthBearer, Strophe.SASLPlain, Strophe.SASLSHA1];\n\t                mechanisms.forEach(this.registerSASLMechanism.bind(this));\n\t            },\n\t\n\t            /** Function: registerSASLMechanism\n\t             *\n\t             * Register a single SASL mechanism, to be supported by this client.\n\t             *\n\t             *  Parameters:\n\t             *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype\n\t             *\n\t             */\n\t            registerSASLMechanism: function registerSASLMechanism(mechanism) {\n\t                this.mechanisms[mechanism.prototype.name] = mechanism;\n\t            },\n\t\n\t            /** Function: disconnect\n\t             *  Start the graceful disconnection process.\n\t             *\n\t             *  This function starts the disconnection process.  This process starts\n\t             *  by sending unavailable presence and sending BOSH body of type\n\t             *  terminate.  A timeout handler makes sure that disconnection happens\n\t             *  even if the BOSH server does not respond.\n\t             *  If the Connection object isn't connected, at least tries to abort all pending requests\n\t             *  so the connection object won't generate successful requests (which were already opened).\n\t             *\n\t             *  The user supplied connection callback will be notified of the\n\t             *  progress as this process happens.\n\t             *\n\t             *  Parameters:\n\t             *    (String) reason - The reason the disconnect is occuring.\n\t             */\n\t            disconnect: function disconnect(reason) {\n\t                this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\n\t\n\t                Strophe.info(\"Disconnect was called because: \" + reason);\n\t                if (this.connected) {\n\t                    var pres = false;\n\t                    this.disconnecting = true;\n\t                    if (this.authenticated) {\n\t                        pres = $pres({\n\t                            xmlns: Strophe.NS.CLIENT,\n\t                            type: 'unavailable'\n\t                        });\n\t                    }\n\t                    // setup timeout handler\n\t                    this._disconnectTimeout = this._addSysTimedHandler(3000, this._onDisconnectTimeout.bind(this));\n\t                    this._proto._disconnect(pres);\n\t                } else {\n\t                    Strophe.info(\"Disconnect was called before Strophe connected to the server\");\n\t                    this._proto._abortAllRequests();\n\t                    this._doDisconnect();\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _changeConnectStatus\n\t             *  _Private_ helper function that makes sure plugins and the user's\n\t             *  callback are notified of connection status changes.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) status - the new connection status, one of the values\n\t             *      in Strophe.Status\n\t             *    (String) condition - the error condition or null\n\t             */\n\t            _changeConnectStatus: function _changeConnectStatus(status, condition) {\n\t                // notify all plugins listening for status changes\n\t                for (var k in Strophe._connectionPlugins) {\n\t                    if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n\t                        var plugin = this[k];\n\t                        if (plugin.statusChanged) {\n\t                            try {\n\t                                plugin.statusChanged(status, condition);\n\t                            } catch (err) {\n\t                                Strophe.error(\"\" + k + \" plugin caused an exception \" + \"changing status: \" + err);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                // notify the user's callback\n\t                if (this.connect_callback) {\n\t                    try {\n\t                        this.connect_callback(status, condition);\n\t                    } catch (e) {\n\t                        Strophe._handleError(e);\n\t                        Strophe.error(\"User connection callback caused an \" + \"exception: \" + e);\n\t                    }\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _doDisconnect\n\t             *  _Private_ function to disconnect.\n\t             *\n\t             *  This is the last piece of the disconnection logic.  This resets the\n\t             *  connection and alerts the user's connection callback.\n\t             */\n\t            _doDisconnect: function _doDisconnect(condition) {\n\t                if (typeof this._idleTimeout === \"number\") {\n\t                    clearTimeout(this._idleTimeout);\n\t                }\n\t\n\t                // Cancel Disconnect Timeout\n\t                if (this._disconnectTimeout !== null) {\n\t                    this.deleteTimedHandler(this._disconnectTimeout);\n\t                    this._disconnectTimeout = null;\n\t                }\n\t\n\t                Strophe.info(\"_doDisconnect was called\");\n\t                this._proto._doDisconnect();\n\t\n\t                this.authenticated = false;\n\t                this.disconnecting = false;\n\t                this.restored = false;\n\t\n\t                // delete handlers\n\t                this.handlers = [];\n\t                this.timedHandlers = [];\n\t                this.removeTimeds = [];\n\t                this.removeHandlers = [];\n\t                this.addTimeds = [];\n\t                this.addHandlers = [];\n\t\n\t                // tell the parent we disconnected\n\t                this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\n\t                this.connected = false;\n\t            },\n\t\n\t            /** PrivateFunction: _dataRecv\n\t             *  _Private_ handler to processes incoming data from the the connection.\n\t             *\n\t             *  Except for _connect_cb handling the initial connection request,\n\t             *  this function handles the incoming data for all requests.  This\n\t             *  function also fires stanza handlers that match each incoming\n\t             *  stanza.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) req - The request that has data ready.\n\t             *    (string) req - The stanza a raw string (optiona).\n\t             */\n\t            _dataRecv: function _dataRecv(req, raw) {\n\t                Strophe.info(\"_dataRecv called\");\n\t                var elem = this._proto._reqToData(req);\n\t                if (elem === null) {\n\t                    return;\n\t                }\n\t\n\t                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n\t                    if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\n\t                        this.xmlInput(elem.childNodes[0]);\n\t                    } else {\n\t                        this.xmlInput(elem);\n\t                    }\n\t                }\n\t                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n\t                    if (raw) {\n\t                        this.rawInput(raw);\n\t                    } else {\n\t                        this.rawInput(Strophe.serialize(elem));\n\t                    }\n\t                }\n\t\n\t                // remove handlers scheduled for deletion\n\t                var i, hand;\n\t                while (this.removeHandlers.length > 0) {\n\t                    hand = this.removeHandlers.pop();\n\t                    i = this.handlers.indexOf(hand);\n\t                    if (i >= 0) {\n\t                        this.handlers.splice(i, 1);\n\t                    }\n\t                }\n\t\n\t                // add handlers scheduled for addition\n\t                while (this.addHandlers.length > 0) {\n\t                    this.handlers.push(this.addHandlers.pop());\n\t                }\n\t\n\t                // handle graceful disconnect\n\t                if (this.disconnecting && this._proto._emptyQueue()) {\n\t                    this._doDisconnect();\n\t                    return;\n\t                }\n\t\n\t                var type = elem.getAttribute(\"type\");\n\t                var cond, conflict;\n\t                if (type !== null && type === \"terminate\") {\n\t                    // Don't process stanzas that come in after disconnect\n\t                    if (this.disconnecting) {\n\t                        return;\n\t                    }\n\t\n\t                    // an error occurred\n\t                    cond = elem.getAttribute(\"condition\");\n\t                    conflict = elem.getElementsByTagName(\"conflict\");\n\t                    if (cond !== null) {\n\t                        if (cond === \"remote-stream-error\" && conflict.length > 0) {\n\t                            cond = \"conflict\";\n\t                        }\n\t                        this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n\t                    } else {\n\t                        this._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n\t                    }\n\t                    this._doDisconnect(cond);\n\t                    return;\n\t                }\n\t\n\t                // send each incoming stanza through the handler chain\n\t                var that = this;\n\t                Strophe.forEachChild(elem, null, function (child) {\n\t                    var i, newList;\n\t                    // process handlers\n\t                    newList = that.handlers;\n\t                    that.handlers = [];\n\t                    for (i = 0; i < newList.length; i++) {\n\t                        var hand = newList[i];\n\t                        // encapsulate 'handler.run' not to lose the whole handler list if\n\t                        // one of the handlers throws an exception\n\t                        try {\n\t                            if (hand.isMatch(child) && (that.authenticated || !hand.user)) {\n\t                                if (hand.run(child)) {\n\t                                    that.handlers.push(hand);\n\t                                }\n\t                            } else {\n\t                                that.handlers.push(hand);\n\t                            }\n\t                        } catch (e) {\n\t                            // if the handler throws an exception, we consider it as false\n\t                            Strophe.warn('Removing Strophe handlers due to uncaught exception: ' + e.message);\n\t                        }\n\t                    }\n\t                });\n\t            },\n\t\n\t            /** Attribute: mechanisms\n\t             *  SASL Mechanisms available for Connection.\n\t             */\n\t            mechanisms: {},\n\t\n\t            /** PrivateFunction: _connect_cb\n\t             *  _Private_ handler for initial connection request.\n\t             *\n\t             *  This handler is used to process the initial connection request\n\t             *  response from the BOSH server. It is used to set up authentication\n\t             *  handlers and start the authentication process.\n\t             *\n\t             *  SASL authentication will be attempted if available, otherwise\n\t             *  the code will fall back to legacy authentication.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) req - The current request.\n\t             *    (Function) _callback - low level (xmpp) connect callback function.\n\t             *      Useful for plugins with their own xmpp connect callback (when their)\n\t             *      want to do something special).\n\t             */\n\t            _connect_cb: function _connect_cb(req, _callback, raw) {\n\t                Strophe.info(\"_connect_cb was called\");\n\t                this.connected = true;\n\t\n\t                var bodyWrap;\n\t                try {\n\t                    bodyWrap = this._proto._reqToData(req);\n\t                } catch (e) {\n\t                    if (e !== \"badformat\") {\n\t                        throw e;\n\t                    }\n\t                    this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');\n\t                    this._doDisconnect('bad-format');\n\t                }\n\t                if (!bodyWrap) {\n\t                    return;\n\t                }\n\t\n\t                if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n\t                    if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\n\t                        this.xmlInput(bodyWrap.childNodes[0]);\n\t                    } else {\n\t                        this.xmlInput(bodyWrap);\n\t                    }\n\t                }\n\t                if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n\t                    if (raw) {\n\t                        this.rawInput(raw);\n\t                    } else {\n\t                        this.rawInput(Strophe.serialize(bodyWrap));\n\t                    }\n\t                }\n\t\n\t                var conncheck = this._proto._connect_cb(bodyWrap);\n\t                if (conncheck === Strophe.Status.CONNFAIL) {\n\t                    return;\n\t                }\n\t\n\t                // Check for the stream:features tag\n\t                var hasFeatures;\n\t                if (bodyWrap.getElementsByTagNameNS) {\n\t                    hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"features\").length > 0;\n\t                } else {\n\t                    hasFeatures = bodyWrap.getElementsByTagName(\"stream:features\").length > 0 || bodyWrap.getElementsByTagName(\"features\").length > 0;\n\t                }\n\t                if (!hasFeatures) {\n\t                    this._proto._no_auth_received(_callback);\n\t                    return;\n\t                }\n\t\n\t                var matched = [],\n\t                    i,\n\t                    mech;\n\t                var mechanisms = bodyWrap.getElementsByTagName(\"mechanism\");\n\t                if (mechanisms.length > 0) {\n\t                    for (i = 0; i < mechanisms.length; i++) {\n\t                        mech = Strophe.getText(mechanisms[i]);\n\t                        if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\n\t                    }\n\t                }\n\t                if (matched.length === 0) {\n\t                    if (bodyWrap.getElementsByTagName(\"auth\").length === 0) {\n\t                        // There are no matching SASL mechanisms and also no legacy\n\t                        // auth available.\n\t                        this._proto._no_auth_received(_callback);\n\t                        return;\n\t                    }\n\t                }\n\t                if (this.do_authentication !== false) {\n\t                    this.authenticate(matched);\n\t                }\n\t            },\n\t\n\t            /** Function: sortMechanismsByPriority\n\t             *\n\t             *  Sorts an array of objects with prototype SASLMechanism according to\n\t             *  their priorities.\n\t             *\n\t             *  Parameters:\n\t             *    (Array) mechanisms - Array of SASL mechanisms.\n\t             *\n\t             */\n\t            sortMechanismsByPriority: function sortMechanismsByPriority(mechanisms) {\n\t                // Sorting mechanisms according to priority.\n\t                var i, j, higher, swap;\n\t                for (i = 0; i < mechanisms.length - 1; ++i) {\n\t                    higher = i;\n\t                    for (j = i + 1; j < mechanisms.length; ++j) {\n\t                        if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {\n\t                            higher = j;\n\t                        }\n\t                    }\n\t                    if (higher !== i) {\n\t                        swap = mechanisms[i];\n\t                        mechanisms[i] = mechanisms[higher];\n\t                        mechanisms[higher] = swap;\n\t                    }\n\t                }\n\t                return mechanisms;\n\t            },\n\t\n\t            /** PrivateFunction: _attemptSASLAuth\n\t             *\n\t             *  Iterate through an array of SASL mechanisms and attempt authentication\n\t             *  with the highest priority (enabled) mechanism.\n\t             *\n\t             *  Parameters:\n\t             *    (Array) mechanisms - Array of SASL mechanisms.\n\t             *\n\t             *  Returns:\n\t             *    (Boolean) mechanism_found - true or false, depending on whether a\n\t             *          valid SASL mechanism was found with which authentication could be\n\t             *          started.\n\t             */\n\t            _attemptSASLAuth: function _attemptSASLAuth(mechanisms) {\n\t                mechanisms = this.sortMechanismsByPriority(mechanisms || []);\n\t                var i = 0,\n\t                    mechanism_found = false;\n\t                for (i = 0; i < mechanisms.length; ++i) {\n\t                    if (!mechanisms[i].prototype.test(this)) {\n\t                        continue;\n\t                    }\n\t                    this._sasl_success_handler = this._addSysHandler(this._sasl_success_cb.bind(this), null, \"success\", null, null);\n\t                    this._sasl_failure_handler = this._addSysHandler(this._sasl_failure_cb.bind(this), null, \"failure\", null, null);\n\t                    this._sasl_challenge_handler = this._addSysHandler(this._sasl_challenge_cb.bind(this), null, \"challenge\", null, null);\n\t\n\t                    this._sasl_mechanism = new mechanisms[i]();\n\t                    this._sasl_mechanism.onStart(this);\n\t\n\t                    var request_auth_exchange = $build(\"auth\", {\n\t                        xmlns: Strophe.NS.SASL,\n\t                        mechanism: this._sasl_mechanism.name\n\t                    });\n\t                    if (this._sasl_mechanism.isClientFirst) {\n\t                        var response = this._sasl_mechanism.onChallenge(this, null);\n\t                        request_auth_exchange.t(btoa(response));\n\t                    }\n\t                    this.send(request_auth_exchange.tree());\n\t                    mechanism_found = true;\n\t                    break;\n\t                }\n\t                return mechanism_found;\n\t            },\n\t\n\t            /** PrivateFunction: _attemptLegacyAuth\n\t             *\n\t             *  Attempt legacy (i.e. non-SASL) authentication.\n\t             *\n\t             */\n\t            _attemptLegacyAuth: function _attemptLegacyAuth() {\n\t                if (Strophe.getNodeFromJid(this.jid) === null) {\n\t                    // we don't have a node, which is required for non-anonymous\n\t                    // client connections\n\t                    this._changeConnectStatus(Strophe.Status.CONNFAIL, 'x-strophe-bad-non-anon-jid');\n\t                    this.disconnect('x-strophe-bad-non-anon-jid');\n\t                } else {\n\t                    // Fall back to legacy authentication\n\t                    this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\n\t                    this._addSysHandler(this._auth1_cb.bind(this), null, null, null, \"_auth_1\");\n\t                    this.send($iq({\n\t                        'type': \"get\",\n\t                        'to': this.domain,\n\t                        'id': \"_auth_1\"\n\t                    }).c(\"query\", { xmlns: Strophe.NS.AUTH }).c(\"username\", {}).t(Strophe.getNodeFromJid(this.jid)).tree());\n\t                }\n\t            },\n\t\n\t            /** Function: authenticate\n\t             * Set up authentication\n\t             *\n\t             *  Continues the initial connection request by setting up authentication\n\t             *  handlers and starting the authentication process.\n\t             *\n\t             *  SASL authentication will be attempted if available, otherwise\n\t             *  the code will fall back to legacy authentication.\n\t             *\n\t             *  Parameters:\n\t             *    (Array) matched - Array of SASL mechanisms supported.\n\t             *\n\t             */\n\t            authenticate: function authenticate(matched) {\n\t                if (!this._attemptSASLAuth(matched)) {\n\t                    this._attemptLegacyAuth();\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _sasl_challenge_cb\n\t             *  _Private_ handler for the SASL challenge\n\t             *\n\t             */\n\t            _sasl_challenge_cb: function _sasl_challenge_cb(elem) {\n\t                var challenge = atob(Strophe.getText(elem));\n\t                var response = this._sasl_mechanism.onChallenge(this, challenge);\n\t                var stanza = $build('response', {\n\t                    'xmlns': Strophe.NS.SASL\n\t                });\n\t                if (response !== \"\") {\n\t                    stanza.t(btoa(response));\n\t                }\n\t                this.send(stanza.tree());\n\t                return true;\n\t            },\n\t\n\t            /** PrivateFunction: _auth1_cb\n\t             *  _Private_ handler for legacy authentication.\n\t             *\n\t             *  This handler is called in response to the initial <iq type='get'/>\n\t             *  for legacy authentication.  It builds an authentication <iq/> and\n\t             *  sends it, creating a handler (calling back to _auth2_cb()) to\n\t             *  handle the result\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The stanza that triggered the callback.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            /* jshint unused:false */\n\t            _auth1_cb: function _auth1_cb(elem) {\n\t                // build plaintext auth iq\n\t                var iq = $iq({ type: \"set\", id: \"_auth_2\" }).c('query', { xmlns: Strophe.NS.AUTH }).c('username', {}).t(Strophe.getNodeFromJid(this.jid)).up().c('password').t(this.pass);\n\t\n\t                if (!Strophe.getResourceFromJid(this.jid)) {\n\t                    // since the user has not supplied a resource, we pick\n\t                    // a default one here.  unlike other auth methods, the server\n\t                    // cannot do this for us.\n\t                    this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\n\t                }\n\t                iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\n\t\n\t                this._addSysHandler(this._auth2_cb.bind(this), null, null, null, \"_auth_2\");\n\t                this.send(iq.tree());\n\t                return false;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** PrivateFunction: _sasl_success_cb\n\t             *  _Private_ handler for succesful SASL authentication.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The matching stanza.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            _sasl_success_cb: function _sasl_success_cb(elem) {\n\t                if (this._sasl_data[\"server-signature\"]) {\n\t                    var serverSignature;\n\t                    var success = atob(Strophe.getText(elem));\n\t                    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\t                    var matches = success.match(attribMatch);\n\t                    if (matches[1] === \"v\") {\n\t                        serverSignature = matches[2];\n\t                    }\n\t\n\t                    if (serverSignature !== this._sasl_data[\"server-signature\"]) {\n\t                        // remove old handlers\n\t                        this.deleteHandler(this._sasl_failure_handler);\n\t                        this._sasl_failure_handler = null;\n\t                        if (this._sasl_challenge_handler) {\n\t                            this.deleteHandler(this._sasl_challenge_handler);\n\t                            this._sasl_challenge_handler = null;\n\t                        }\n\t\n\t                        this._sasl_data = {};\n\t                        return this._sasl_failure_cb(null);\n\t                    }\n\t                }\n\t                Strophe.info(\"SASL authentication succeeded.\");\n\t\n\t                if (this._sasl_mechanism) {\n\t                    this._sasl_mechanism.onSuccess();\n\t                }\n\t\n\t                // remove old handlers\n\t                this.deleteHandler(this._sasl_failure_handler);\n\t                this._sasl_failure_handler = null;\n\t                if (this._sasl_challenge_handler) {\n\t                    this.deleteHandler(this._sasl_challenge_handler);\n\t                    this._sasl_challenge_handler = null;\n\t                }\n\t\n\t                var streamfeature_handlers = [];\n\t                var wrapper = function wrapper(handlers, elem) {\n\t                    while (handlers.length) {\n\t                        this.deleteHandler(handlers.pop());\n\t                    }\n\t                    this._sasl_auth1_cb.bind(this)(elem);\n\t                    return false;\n\t                };\n\t                streamfeature_handlers.push(this._addSysHandler(function (elem) {\n\t                    wrapper.bind(this)(streamfeature_handlers, elem);\n\t                }.bind(this), null, \"stream:features\", null, null));\n\t                streamfeature_handlers.push(this._addSysHandler(function (elem) {\n\t                    wrapper.bind(this)(streamfeature_handlers, elem);\n\t                }.bind(this), Strophe.NS.STREAM, \"features\", null, null));\n\t\n\t                // we must send an xmpp:restart now\n\t                this._sendRestart();\n\t\n\t                return false;\n\t            },\n\t\n\t            /** PrivateFunction: _sasl_auth1_cb\n\t             *  _Private_ handler to start stream binding.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The matching stanza.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            _sasl_auth1_cb: function _sasl_auth1_cb(elem) {\n\t                // save stream:features for future usage\n\t                this.features = elem;\n\t                var i, child;\n\t                for (i = 0; i < elem.childNodes.length; i++) {\n\t                    child = elem.childNodes[i];\n\t                    if (child.nodeName === 'bind') {\n\t                        this.do_bind = true;\n\t                    }\n\t\n\t                    if (child.nodeName === 'session') {\n\t                        this.do_session = true;\n\t                    }\n\t                }\n\t\n\t                if (!this.do_bind) {\n\t                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n\t                    return false;\n\t                } else {\n\t                    this._addSysHandler(this._sasl_bind_cb.bind(this), null, null, null, \"_bind_auth_2\");\n\t\n\t                    var resource = Strophe.getResourceFromJid(this.jid);\n\t                    if (resource) {\n\t                        this.send($iq({ type: \"set\", id: \"_bind_auth_2\" }).c('bind', { xmlns: Strophe.NS.BIND }).c('resource', {}).t(resource).tree());\n\t                    } else {\n\t                        this.send($iq({ type: \"set\", id: \"_bind_auth_2\" }).c('bind', { xmlns: Strophe.NS.BIND }).tree());\n\t                    }\n\t                }\n\t                return false;\n\t            },\n\t\n\t            /** PrivateFunction: _sasl_bind_cb\n\t             *  _Private_ handler for binding result and session start.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The matching stanza.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            _sasl_bind_cb: function _sasl_bind_cb(elem) {\n\t                if (elem.getAttribute(\"type\") === \"error\") {\n\t                    Strophe.info(\"SASL binding failed.\");\n\t                    var conflict = elem.getElementsByTagName(\"conflict\"),\n\t                        condition;\n\t                    if (conflict.length > 0) {\n\t                        condition = 'conflict';\n\t                    }\n\t                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);\n\t                    return false;\n\t                }\n\t\n\t                // TODO - need to grab errors\n\t                var bind = elem.getElementsByTagName(\"bind\");\n\t                var jidNode;\n\t                if (bind.length > 0) {\n\t                    // Grab jid\n\t                    jidNode = bind[0].getElementsByTagName(\"jid\");\n\t                    if (jidNode.length > 0) {\n\t                        this.jid = Strophe.getText(jidNode[0]);\n\t\n\t                        if (this.do_session) {\n\t                            this._addSysHandler(this._sasl_session_cb.bind(this), null, null, null, \"_session_auth_2\");\n\t\n\t                            this.send($iq({ type: \"set\", id: \"_session_auth_2\" }).c('session', { xmlns: Strophe.NS.SESSION }).tree());\n\t                        } else {\n\t                            this.authenticated = true;\n\t                            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n\t                        }\n\t                    }\n\t                } else {\n\t                    Strophe.info(\"SASL binding failed.\");\n\t                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n\t                    return false;\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _sasl_session_cb\n\t             *  _Private_ handler to finish successful SASL connection.\n\t             *\n\t             *  This sets Connection.authenticated to true on success, which\n\t             *  starts the processing of user handlers.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The matching stanza.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            _sasl_session_cb: function _sasl_session_cb(elem) {\n\t                if (elem.getAttribute(\"type\") === \"result\") {\n\t                    this.authenticated = true;\n\t                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n\t                } else if (elem.getAttribute(\"type\") === \"error\") {\n\t                    Strophe.info(\"Session creation failed.\");\n\t                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n\t                    return false;\n\t                }\n\t                return false;\n\t            },\n\t\n\t            /** PrivateFunction: _sasl_failure_cb\n\t             *  _Private_ handler for SASL authentication failure.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The matching stanza.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            /* jshint unused:false */\n\t            _sasl_failure_cb: function _sasl_failure_cb(elem) {\n\t                // delete unneeded handlers\n\t                if (this._sasl_success_handler) {\n\t                    this.deleteHandler(this._sasl_success_handler);\n\t                    this._sasl_success_handler = null;\n\t                }\n\t                if (this._sasl_challenge_handler) {\n\t                    this.deleteHandler(this._sasl_challenge_handler);\n\t                    this._sasl_challenge_handler = null;\n\t                }\n\t\n\t                if (this._sasl_mechanism) this._sasl_mechanism.onFailure();\n\t                this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n\t                return false;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** PrivateFunction: _auth2_cb\n\t             *  _Private_ handler to finish legacy authentication.\n\t             *\n\t             *  This handler is called when the result from the jabber:iq:auth\n\t             *  <iq/> stanza is returned.\n\t             *\n\t             *  Parameters:\n\t             *    (XMLElement) elem - The stanza that triggered the callback.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            _auth2_cb: function _auth2_cb(elem) {\n\t                if (elem.getAttribute(\"type\") === \"result\") {\n\t                    this.authenticated = true;\n\t                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n\t                } else if (elem.getAttribute(\"type\") === \"error\") {\n\t                    this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n\t                    this.disconnect('authentication failed');\n\t                }\n\t                return false;\n\t            },\n\t\n\t            /** PrivateFunction: _addSysTimedHandler\n\t             *  _Private_ function to add a system level timed handler.\n\t             *\n\t             *  This function is used to add a Strophe.TimedHandler for the\n\t             *  library code.  System timed handlers are allowed to run before\n\t             *  authentication is complete.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) period - The period of the handler.\n\t             *    (Function) handler - The callback function.\n\t             */\n\t            _addSysTimedHandler: function _addSysTimedHandler(period, handler) {\n\t                var thand = new Strophe.TimedHandler(period, handler);\n\t                thand.user = false;\n\t                this.addTimeds.push(thand);\n\t                return thand;\n\t            },\n\t\n\t            /** PrivateFunction: _addSysHandler\n\t             *  _Private_ function to add a system level stanza handler.\n\t             *\n\t             *  This function is used to add a Strophe.Handler for the\n\t             *  library code.  System stanza handlers are allowed to run before\n\t             *  authentication is complete.\n\t             *\n\t             *  Parameters:\n\t             *    (Function) handler - The callback function.\n\t             *    (String) ns - The namespace to match.\n\t             *    (String) name - The stanza name to match.\n\t             *    (String) type - The stanza type attribute to match.\n\t             *    (String) id - The stanza id attribute to match.\n\t             */\n\t            _addSysHandler: function _addSysHandler(handler, ns, name, type, id) {\n\t                var hand = new Strophe.Handler(handler, ns, name, type, id);\n\t                hand.user = false;\n\t                this.addHandlers.push(hand);\n\t                return hand;\n\t            },\n\t\n\t            /** PrivateFunction: _onDisconnectTimeout\n\t             *  _Private_ timeout handler for handling non-graceful disconnection.\n\t             *\n\t             *  If the graceful disconnect process does not complete within the\n\t             *  time allotted, this handler finishes the disconnect anyway.\n\t             *\n\t             *  Returns:\n\t             *    false to remove the handler.\n\t             */\n\t            _onDisconnectTimeout: function _onDisconnectTimeout() {\n\t                Strophe.info(\"_onDisconnectTimeout was called\");\n\t                this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\n\t                this._proto._onDisconnectTimeout();\n\t                // actually disconnect\n\t                this._doDisconnect();\n\t                return false;\n\t            },\n\t\n\t            /** PrivateFunction: _onIdle\n\t             *  _Private_ handler to process events during idle cycle.\n\t             *\n\t             *  This handler is called every 100ms to fire timed handlers that\n\t             *  are ready and keep poll requests going.\n\t             */\n\t            _onIdle: function _onIdle() {\n\t                var i, thand, since, newList;\n\t\n\t                // add timed handlers scheduled for addition\n\t                // NOTE: we add before remove in the case a timed handler is\n\t                // added and then deleted before the next _onIdle() call.\n\t                while (this.addTimeds.length > 0) {\n\t                    this.timedHandlers.push(this.addTimeds.pop());\n\t                }\n\t\n\t                // remove timed handlers that have been scheduled for deletion\n\t                while (this.removeTimeds.length > 0) {\n\t                    thand = this.removeTimeds.pop();\n\t                    i = this.timedHandlers.indexOf(thand);\n\t                    if (i >= 0) {\n\t                        this.timedHandlers.splice(i, 1);\n\t                    }\n\t                }\n\t\n\t                // call ready timed handlers\n\t                var now = new Date().getTime();\n\t                newList = [];\n\t                for (i = 0; i < this.timedHandlers.length; i++) {\n\t                    thand = this.timedHandlers[i];\n\t                    if (this.authenticated || !thand.user) {\n\t                        since = thand.lastCalled + thand.period;\n\t                        if (since - now <= 0) {\n\t                            if (thand.run()) {\n\t                                newList.push(thand);\n\t                            }\n\t                        } else {\n\t                            newList.push(thand);\n\t                        }\n\t                    }\n\t                }\n\t                this.timedHandlers = newList;\n\t\n\t                clearTimeout(this._idleTimeout);\n\t\n\t                this._proto._onIdle();\n\t\n\t                // reactivate the timer only if connected\n\t                if (this.connected) {\n\t                    // XXX: setTimeout should be called only with function expressions (23974bc1)\n\t                    this._idleTimeout = setTimeout(function () {\n\t                        this._onIdle();\n\t                    }.bind(this), 100);\n\t                }\n\t            }\n\t        };\n\t\n\t        /** Class: Strophe.SASLMechanism\n\t         *\n\t         *  encapsulates SASL authentication mechanisms.\n\t         *\n\t         *  User code may override the priority for each mechanism or disable it completely.\n\t         *  See <priority> for information about changing priority and <test> for informatian on\n\t         *  how to disable a mechanism.\n\t         *\n\t         *  By default, all mechanisms are enabled and the priorities are\n\t         *\n\t         *      OAUTHBEARER - 60\n\t         *      SCRAM-SHA1 - 50\n\t         *      DIGEST-MD5 - 40\n\t         *      PLAIN - 30\n\t         *      ANONYMOUS - 20\n\t         *      EXTERNAL - 10\n\t         *\n\t         *  See: Strophe.Connection.addSupportedSASLMechanisms\n\t         */\n\t\n\t        /**\n\t         * PrivateConstructor: Strophe.SASLMechanism\n\t         * SASL auth mechanism abstraction.\n\t         *\n\t         *  Parameters:\n\t         *    (String) name - SASL Mechanism name.\n\t         *    (Boolean) isClientFirst - If client should send response first without challenge.\n\t         *    (Number) priority - Priority.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.SASLMechanism object.\n\t         */\n\t        Strophe.SASLMechanism = function (name, isClientFirst, priority) {\n\t            /** PrivateVariable: name\n\t             *  Mechanism name.\n\t             */\n\t            this.name = name;\n\t            /** PrivateVariable: isClientFirst\n\t             *  If client sends response without initial server challenge.\n\t             */\n\t            this.isClientFirst = isClientFirst;\n\t            /** Variable: priority\n\t             *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\n\t             *  Users may override this to prioritize mechanisms differently.\n\t             *\n\t             *  In the default configuration the priorities are\n\t             *\n\t             *  SCRAM-SHA1 - 40\n\t             *  DIGEST-MD5 - 30\n\t             *  Plain - 20\n\t             *\n\t             *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\n\t             *\n\t             *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\n\t             *\n\t             *  See <SASL mechanisms> for a list of available mechanisms.\n\t             *\n\t             */\n\t            this.priority = priority;\n\t        };\n\t\n\t        Strophe.SASLMechanism.prototype = {\n\t            /**\n\t             *  Function: test\n\t             *  Checks if mechanism able to run.\n\t             *  To disable a mechanism, make this return false;\n\t             *\n\t             *  To disable plain authentication run\n\t             *  > Strophe.SASLPlain.test = function() {\n\t             *  >   return false;\n\t             *  > }\n\t             *\n\t             *  See <SASL mechanisms> for a list of available mechanisms.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Connection) connection - Target Connection.\n\t             *\n\t             *  Returns:\n\t             *    (Boolean) If mechanism was able to run.\n\t             */\n\t            /* jshint unused:false */\n\t            test: function test(connection) {\n\t                return true;\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** PrivateFunction: onStart\n\t             *  Called before starting mechanism on some connection.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Connection) connection - Target Connection.\n\t             */\n\t            onStart: function onStart(connection) {\n\t                this._connection = connection;\n\t            },\n\t\n\t            /** PrivateFunction: onChallenge\n\t             *  Called by protocol implementation on incoming challenge. If client is\n\t             *  first (isClientFirst === true) challenge will be null on the first call.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Connection) connection - Target Connection.\n\t             *    (String) challenge - current challenge to handle.\n\t             *\n\t             *  Returns:\n\t             *    (String) Mechanism response.\n\t             */\n\t            /* jshint unused:false */\n\t            onChallenge: function onChallenge(connection, challenge) {\n\t                throw new Error(\"You should implement challenge handling!\");\n\t            },\n\t            /* jshint unused:true */\n\t\n\t            /** PrivateFunction: onFailure\n\t             *  Protocol informs mechanism implementation about SASL failure.\n\t             */\n\t            onFailure: function onFailure() {\n\t                this._connection = null;\n\t            },\n\t\n\t            /** PrivateFunction: onSuccess\n\t             *  Protocol informs mechanism implementation about SASL success.\n\t             */\n\t            onSuccess: function onSuccess() {\n\t                this._connection = null;\n\t            }\n\t        };\n\t\n\t        /** Constants: SASL mechanisms\n\t         *  Available authentication mechanisms\n\t         *\n\t         *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\n\t         *  Strophe.SASLPlain - SASL PLAIN authentication.\n\t         *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\n\t         *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\n\t         *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\n\t         *  Strophe.SASLExternal - SASL EXTERNAL authentication\n\t         */\n\t\n\t        // Building SASL callbacks\n\t\n\t        /** PrivateConstructor: SASLAnonymous\n\t         *  SASL ANONYMOUS authentication.\n\t         */\n\t        Strophe.SASLAnonymous = function () {};\n\t        Strophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\"ANONYMOUS\", false, 20);\n\t\n\t        Strophe.SASLAnonymous.prototype.test = function (connection) {\n\t            return connection.authcid === null;\n\t        };\n\t\n\t        /** PrivateConstructor: SASLPlain\n\t         *  SASL PLAIN authentication.\n\t         */\n\t        Strophe.SASLPlain = function () {};\n\t        Strophe.SASLPlain.prototype = new Strophe.SASLMechanism(\"PLAIN\", true, 30);\n\t\n\t        Strophe.SASLPlain.prototype.test = function (connection) {\n\t            return connection.authcid !== null;\n\t        };\n\t\n\t        Strophe.SASLPlain.prototype.onChallenge = function (connection) {\n\t            var auth_str = connection.authzid;\n\t            auth_str = auth_str + '\\0';\n\t            auth_str = auth_str + connection.authcid;\n\t            auth_str = auth_str + '\\0';\n\t            auth_str = auth_str + connection.pass;\n\t            return utils.utf16to8(auth_str);\n\t        };\n\t\n\t        /** PrivateConstructor: SASLSHA1\n\t         *  SASL SCRAM SHA 1 authentication.\n\t         */\n\t        Strophe.SASLSHA1 = function () {};\n\t        Strophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\"SCRAM-SHA-1\", true, 50);\n\t\n\t        Strophe.SASLSHA1.prototype.test = function (connection) {\n\t            return connection.authcid !== null;\n\t        };\n\t\n\t        Strophe.SASLSHA1.prototype.onChallenge = function (connection, challenge, test_cnonce) {\n\t            var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);\n\t            var auth_str = \"n=\" + utils.utf16to8(connection.authcid);\n\t            auth_str += \",r=\";\n\t            auth_str += cnonce;\n\t            connection._sasl_data.cnonce = cnonce;\n\t            connection._sasl_data[\"client-first-message-bare\"] = auth_str;\n\t\n\t            auth_str = \"n,,\" + auth_str;\n\t\n\t            this.onChallenge = function (connection, challenge) {\n\t                var nonce, salt, iter, Hi, U, U_old, i, k, pass;\n\t                var clientKey, serverKey, clientSignature;\n\t                var responseText = \"c=biws,\";\n\t                var authMessage = connection._sasl_data[\"client-first-message-bare\"] + \",\" + challenge + \",\";\n\t                var cnonce = connection._sasl_data.cnonce;\n\t                var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\t\n\t                while (challenge.match(attribMatch)) {\n\t                    var matches = challenge.match(attribMatch);\n\t                    challenge = challenge.replace(matches[0], \"\");\n\t                    switch (matches[1]) {\n\t                        case \"r\":\n\t                            nonce = matches[2];\n\t                            break;\n\t                        case \"s\":\n\t                            salt = matches[2];\n\t                            break;\n\t                        case \"i\":\n\t                            iter = matches[2];\n\t                            break;\n\t                    }\n\t                }\n\t\n\t                if (nonce.substr(0, cnonce.length) !== cnonce) {\n\t                    connection._sasl_data = {};\n\t                    return connection._sasl_failure_cb();\n\t                }\n\t\n\t                responseText += \"r=\" + nonce;\n\t                authMessage += responseText;\n\t\n\t                salt = atob(salt);\n\t                salt += \"\\x00\\x00\\x00\\x01\";\n\t\n\t                pass = utils.utf16to8(connection.pass);\n\t                Hi = U_old = SHA1.core_hmac_sha1(pass, salt);\n\t                for (i = 1; i < iter; i++) {\n\t                    U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));\n\t                    for (k = 0; k < 5; k++) {\n\t                        Hi[k] ^= U[k];\n\t                    }\n\t                    U_old = U;\n\t                }\n\t                Hi = SHA1.binb2str(Hi);\n\t\n\t                clientKey = SHA1.core_hmac_sha1(Hi, \"Client Key\");\n\t                serverKey = SHA1.str_hmac_sha1(Hi, \"Server Key\");\n\t                clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);\n\t                connection._sasl_data[\"server-signature\"] = SHA1.b64_hmac_sha1(serverKey, authMessage);\n\t\n\t                for (k = 0; k < 5; k++) {\n\t                    clientKey[k] ^= clientSignature[k];\n\t                }\n\t\n\t                responseText += \",p=\" + btoa(SHA1.binb2str(clientKey));\n\t                return responseText;\n\t            }.bind(this);\n\t\n\t            return auth_str;\n\t        };\n\t\n\t        /** PrivateConstructor: SASLMD5\n\t         *  SASL DIGEST MD5 authentication.\n\t         */\n\t        Strophe.SASLMD5 = function () {};\n\t        Strophe.SASLMD5.prototype = new Strophe.SASLMechanism(\"DIGEST-MD5\", false, 40);\n\t\n\t        Strophe.SASLMD5.prototype.test = function (connection) {\n\t            return connection.authcid !== null;\n\t        };\n\t\n\t        /** PrivateFunction: _quote\n\t         *  _Private_ utility function to backslash escape and quote strings.\n\t         *\n\t         *  Parameters:\n\t         *    (String) str - The string to be quoted.\n\t         *\n\t         *  Returns:\n\t         *    quoted string\n\t         */\n\t        Strophe.SASLMD5.prototype._quote = function (str) {\n\t            return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"') + '\"';\n\t            //\" end string workaround for emacs\n\t        };\n\t\n\t        Strophe.SASLMD5.prototype.onChallenge = function (connection, challenge, test_cnonce) {\n\t            var attribMatch = /([a-z]+)=(\"[^\"]+\"|[^,\"]+)(?:,|$)/;\n\t            var cnonce = test_cnonce || MD5.hexdigest(\"\" + Math.random() * 1234567890);\n\t            var realm = \"\";\n\t            var host = null;\n\t            var nonce = \"\";\n\t            var qop = \"\";\n\t            var matches;\n\t\n\t            while (challenge.match(attribMatch)) {\n\t                matches = challenge.match(attribMatch);\n\t                challenge = challenge.replace(matches[0], \"\");\n\t                matches[2] = matches[2].replace(/^\"(.+)\"$/, \"$1\");\n\t                switch (matches[1]) {\n\t                    case \"realm\":\n\t                        realm = matches[2];\n\t                        break;\n\t                    case \"nonce\":\n\t                        nonce = matches[2];\n\t                        break;\n\t                    case \"qop\":\n\t                        qop = matches[2];\n\t                        break;\n\t                    case \"host\":\n\t                        host = matches[2];\n\t                        break;\n\t                }\n\t            }\n\t\n\t            var digest_uri = connection.servtype + \"/\" + connection.domain;\n\t            if (host !== null) {\n\t                digest_uri = digest_uri + \"/\" + host;\n\t            }\n\t\n\t            var cred = utils.utf16to8(connection.authcid + \":\" + realm + \":\" + this._connection.pass);\n\t            var A1 = MD5.hash(cred) + \":\" + nonce + \":\" + cnonce;\n\t            var A2 = 'AUTHENTICATE:' + digest_uri;\n\t\n\t            var responseText = \"\";\n\t            responseText += 'charset=utf-8,';\n\t            responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';\n\t            responseText += 'realm=' + this._quote(realm) + ',';\n\t            responseText += 'nonce=' + this._quote(nonce) + ',';\n\t            responseText += 'nc=00000001,';\n\t            responseText += 'cnonce=' + this._quote(cnonce) + ',';\n\t            responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\n\t            responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + \":\" + nonce + \":00000001:\" + cnonce + \":auth:\" + MD5.hexdigest(A2)) + \",\";\n\t            responseText += 'qop=auth';\n\t\n\t            this.onChallenge = function () {\n\t                return \"\";\n\t            };\n\t            return responseText;\n\t        };\n\t\n\t        /** PrivateConstructor: SASLOAuthBearer\n\t         *  SASL OAuth Bearer authentication.\n\t         */\n\t        Strophe.SASLOAuthBearer = function () {};\n\t        Strophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\"OAUTHBEARER\", true, 60);\n\t\n\t        Strophe.SASLOAuthBearer.prototype.test = function (connection) {\n\t            return connection.pass !== null;\n\t        };\n\t\n\t        Strophe.SASLOAuthBearer.prototype.onChallenge = function (connection) {\n\t            var auth_str = 'n,';\n\t            if (connection.authcid !== null) {\n\t                auth_str = auth_str + 'a=' + connection.authzid;\n\t            }\n\t            auth_str = auth_str + ',';\n\t            auth_str = auth_str + '\\x01';\n\t            auth_str = auth_str + 'auth=Bearer ';\n\t            auth_str = auth_str + connection.pass;\n\t            auth_str = auth_str + '\\x01';\n\t            auth_str = auth_str + '\\x01';\n\t\n\t            return utils.utf16to8(auth_str);\n\t        };\n\t\n\t        /** PrivateConstructor: SASLExternal\n\t         *  SASL EXTERNAL authentication.\n\t         *\n\t         *  The EXTERNAL mechanism allows a client to request the server to use\n\t         *  credentials established by means external to the mechanism to\n\t         *  authenticate the client. The external means may be, for instance,\n\t         *  TLS services.\n\t         */\n\t        Strophe.SASLExternal = function () {};\n\t        Strophe.SASLExternal.prototype = new Strophe.SASLMechanism(\"EXTERNAL\", true, 10);\n\t\n\t        Strophe.SASLExternal.prototype.onChallenge = function (connection) {\n\t            /** According to XEP-178, an authzid SHOULD NOT be presented when the\n\t             * authcid contained or implied in the client certificate is the JID (i.e.\n\t             * authzid) with which the user wants to log in as.\n\t             *\n\t             * To NOT send the authzid, the user should therefore set the authcid equal\n\t             * to the JID when instantiating a new Strophe.Connection object.\n\t             */\n\t            return connection.authcid === connection.authzid ? '' : connection.authzid;\n\t        };\n\t\n\t        return {\n\t            'Strophe': Strophe,\n\t            '$build': $build,\n\t            '$iq': $iq,\n\t            '$msg': $msg,\n\t            '$pres': $pres,\n\t            'SHA1': SHA1,\n\t            'MD5': MD5,\n\t            'b64_hmac_sha1': SHA1.b64_hmac_sha1,\n\t            'b64_sha1': SHA1.b64_sha1,\n\t            'str_hmac_sha1': SHA1.str_hmac_sha1,\n\t            'str_sha1': SHA1.str_sha1\n\t        };\n\t    });\n\t\n\t    /*\n\t        This program is distributed under the terms of the MIT license.\n\t        Please see the LICENSE file for details.\n\t    \n\t        Copyright 2006-2008, OGG, LLC\n\t    */\n\t\n\t    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n\t    /* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-bosh', ['strophe-core'], function (core) {\n\t                return factory(core.Strophe, core.$build);\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            return factory(Strophe, $build);\n\t        }\n\t    })(this, function (Strophe, $build) {\n\t\n\t        /** PrivateClass: Strophe.Request\n\t         *  _Private_ helper class that provides a cross implementation abstraction\n\t         *  for a BOSH related XMLHttpRequest.\n\t         *\n\t         *  The Strophe.Request class is used internally to encapsulate BOSH request\n\t         *  information.  It is not meant to be used from user's code.\n\t         */\n\t\n\t        /** PrivateConstructor: Strophe.Request\n\t         *  Create and initialize a new Strophe.Request object.\n\t         *\n\t         *  Parameters:\n\t         *    (XMLElement) elem - The XML data to be sent in the request.\n\t         *    (Function) func - The function that will be called when the\n\t         *      XMLHttpRequest readyState changes.\n\t         *    (Integer) rid - The BOSH rid attribute associated with this request.\n\t         *    (Integer) sends - The number of times this same request has been sent.\n\t         */\n\t        Strophe.Request = function (elem, func, rid, sends) {\n\t            this.id = ++Strophe._requestId;\n\t            this.xmlData = elem;\n\t            this.data = Strophe.serialize(elem);\n\t            // save original function in case we need to make a new request\n\t            // from this one.\n\t            this.origFunc = func;\n\t            this.func = func;\n\t            this.rid = rid;\n\t            this.date = NaN;\n\t            this.sends = sends || 0;\n\t            this.abort = false;\n\t            this.dead = null;\n\t\n\t            this.age = function () {\n\t                if (!this.date) {\n\t                    return 0;\n\t                }\n\t                var now = new Date();\n\t                return (now - this.date) / 1000;\n\t            };\n\t            this.timeDead = function () {\n\t                if (!this.dead) {\n\t                    return 0;\n\t                }\n\t                var now = new Date();\n\t                return (now - this.dead) / 1000;\n\t            };\n\t            this.xhr = this._newXHR();\n\t        };\n\t\n\t        Strophe.Request.prototype = {\n\t            /** PrivateFunction: getResponse\n\t             *  Get a response from the underlying XMLHttpRequest.\n\t             *\n\t             *  This function attempts to get a response from the request and checks\n\t             *  for errors.\n\t             *\n\t             *  Throws:\n\t             *    \"parsererror\" - A parser error occured.\n\t             *    \"badformat\" - The entity has sent XML that cannot be processed.\n\t             *\n\t             *  Returns:\n\t             *    The DOM element tree of the response.\n\t             */\n\t            getResponse: function getResponse() {\n\t                var node = null;\n\t                if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\n\t                    node = this.xhr.responseXML.documentElement;\n\t                    if (node.tagName === \"parsererror\") {\n\t                        Strophe.error(\"invalid response received\");\n\t                        Strophe.error(\"responseText: \" + this.xhr.responseText);\n\t                        Strophe.error(\"responseXML: \" + Strophe.serialize(this.xhr.responseXML));\n\t                        throw \"parsererror\";\n\t                    }\n\t                } else if (this.xhr.responseText) {\n\t                    Strophe.error(\"invalid response received\");\n\t                    Strophe.error(\"responseText: \" + this.xhr.responseText);\n\t                    throw \"badformat\";\n\t                }\n\t\n\t                return node;\n\t            },\n\t\n\t            /** PrivateFunction: _newXHR\n\t             *  _Private_ helper function to create XMLHttpRequests.\n\t             *\n\t             *  This function creates XMLHttpRequests across all implementations.\n\t             *\n\t             *  Returns:\n\t             *    A new XMLHttpRequest.\n\t             */\n\t            _newXHR: function _newXHR() {\n\t                var xhr = null;\n\t                if (window.XMLHttpRequest) {\n\t                    xhr = new XMLHttpRequest();\n\t                    if (xhr.overrideMimeType) {\n\t                        xhr.overrideMimeType(\"text/xml; charset=utf-8\");\n\t                    }\n\t                } else if (window.ActiveXObject) {\n\t                    xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n\t                }\n\t                // use Function.bind() to prepend ourselves as an argument\n\t                xhr.onreadystatechange = this.func.bind(null, this);\n\t                return xhr;\n\t            }\n\t        };\n\t\n\t        /** Class: Strophe.Bosh\n\t         *  _Private_ helper class that handles BOSH Connections\n\t         *\n\t         *  The Strophe.Bosh class is used internally by Strophe.Connection\n\t         *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\n\t         */\n\t\n\t        /** File: bosh.js\n\t         *  A JavaScript library to enable BOSH in Strophejs.\n\t         *\n\t         *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\n\t         *  to emulate a persistent, stateful, two-way connection to an XMPP server.\n\t         *  More information on BOSH can be found in XEP 124.\n\t         */\n\t\n\t        /** PrivateConstructor: Strophe.Bosh\n\t         *  Create and initialize a Strophe.Bosh object.\n\t         *\n\t         *  Parameters:\n\t         *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.Bosh object.\n\t         */\n\t        Strophe.Bosh = function (connection) {\n\t            this._conn = connection;\n\t            /* request id for body tags */\n\t            this.rid = Math.floor(Math.random() * 4294967295);\n\t            /* The current session ID. */\n\t            this.sid = null;\n\t\n\t            // default BOSH values\n\t            this.hold = 1;\n\t            this.wait = 60;\n\t            this.window = 5;\n\t            this.errors = 0;\n\t            this.inactivity = null;\n\t\n\t            this._requests = [];\n\t        };\n\t\n\t        Strophe.Bosh.prototype = {\n\t            /** Variable: strip\n\t             *\n\t             *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\n\t             *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\n\t             *  To strip this tag, User code can set <Strophe.Bosh.strip> to \"body\":\n\t             *\n\t             *  > Strophe.Bosh.prototype.strip = \"body\";\n\t             *\n\t             *  This will enable stripping of the body tag in both\n\t             *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\n\t             */\n\t            strip: null,\n\t\n\t            /** PrivateFunction: _buildBody\n\t             *  _Private_ helper function to generate the <body/> wrapper for BOSH.\n\t             *\n\t             *  Returns:\n\t             *    A Strophe.Builder with a <body/> element.\n\t             */\n\t            _buildBody: function _buildBody() {\n\t                var bodyWrap = $build('body', {\n\t                    rid: this.rid++,\n\t                    xmlns: Strophe.NS.HTTPBIND\n\t                });\n\t                if (this.sid !== null) {\n\t                    bodyWrap.attrs({ sid: this.sid });\n\t                }\n\t                if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\n\t                    this._cacheSession();\n\t                }\n\t                return bodyWrap;\n\t            },\n\t\n\t            /** PrivateFunction: _reset\n\t             *  Reset the connection.\n\t             *\n\t             *  This function is called by the reset function of the Strophe Connection\n\t             */\n\t            _reset: function _reset() {\n\t                this.rid = Math.floor(Math.random() * 4294967295);\n\t                this.sid = null;\n\t                this.errors = 0;\n\t                if (this._conn._sessionCachingSupported()) {\n\t                    window.sessionStorage.removeItem('strophe-bosh-session');\n\t                }\n\t\n\t                this._conn.nextValidRid(this.rid);\n\t            },\n\t\n\t            /** PrivateFunction: _connect\n\t             *  _Private_ function that initializes the BOSH connection.\n\t             *\n\t             *  Creates and sends the Request that initializes the BOSH connection.\n\t             */\n\t            _connect: function _connect(wait, hold, route) {\n\t                this.wait = wait || this.wait;\n\t                this.hold = hold || this.hold;\n\t                this.errors = 0;\n\t\n\t                // build the body tag\n\t                var body = this._buildBody().attrs({\n\t                    to: this._conn.domain,\n\t                    \"xml:lang\": \"en\",\n\t                    wait: this.wait,\n\t                    hold: this.hold,\n\t                    content: \"text/xml; charset=utf-8\",\n\t                    ver: \"1.6\",\n\t                    \"xmpp:version\": \"1.0\",\n\t                    \"xmlns:xmpp\": Strophe.NS.BOSH\n\t                });\n\t\n\t                if (route) {\n\t                    body.attrs({\n\t                        route: route\n\t                    });\n\t                }\n\t\n\t                var _connect_cb = this._conn._connect_cb;\n\t\n\t                this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _connect_cb.bind(this._conn)), body.tree().getAttribute(\"rid\")));\n\t                this._throttledRequestHandler();\n\t            },\n\t\n\t            /** PrivateFunction: _attach\n\t             *  Attach to an already created and authenticated BOSH session.\n\t             *\n\t             *  This function is provided to allow Strophe to attach to BOSH\n\t             *  sessions which have been created externally, perhaps by a Web\n\t             *  application.  This is often used to support auto-login type features\n\t             *  without putting user credentials into the page.\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - The full JID that is bound by the session.\n\t             *    (String) sid - The SID of the BOSH session.\n\t             *    (String) rid - The current RID of the BOSH session.  This RID\n\t             *      will be used by the next request.\n\t             *    (Function) callback The connect callback function.\n\t             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n\t             *      time the server will wait before returning an empty result for\n\t             *      a request.  The default setting of 60 seconds is recommended.\n\t             *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n\t             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n\t             *      number of connections the server will hold at one time.  This\n\t             *      should almost always be set to 1 (the default).\n\t             *    (Integer) wind - The optional HTTBIND window value.  This is the\n\t             *      allowed range of request ids that are valid.  The default is 5.\n\t             */\n\t            _attach: function _attach(jid, sid, rid, callback, wait, hold, wind) {\n\t                this._conn.jid = jid;\n\t                this.sid = sid;\n\t                this.rid = rid;\n\t\n\t                this._conn.connect_callback = callback;\n\t\n\t                this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\n\t\n\t                this._conn.authenticated = true;\n\t                this._conn.connected = true;\n\t\n\t                this.wait = wait || this.wait;\n\t                this.hold = hold || this.hold;\n\t                this.window = wind || this.window;\n\t\n\t                this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\n\t            },\n\t\n\t            /** PrivateFunction: _restore\n\t             *  Attempt to restore a cached BOSH session\n\t             *\n\t             *  Parameters:\n\t             *    (String) jid - The full JID that is bound by the session.\n\t             *      This parameter is optional but recommended, specifically in cases\n\t             *      where prebinded BOSH sessions are used where it's important to know\n\t             *      that the right session is being restored.\n\t             *    (Function) callback The connect callback function.\n\t             *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n\t             *      time the server will wait before returning an empty result for\n\t             *      a request.  The default setting of 60 seconds is recommended.\n\t             *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n\t             *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n\t             *      number of connections the server will hold at one time.  This\n\t             *      should almost always be set to 1 (the default).\n\t             *    (Integer) wind - The optional HTTBIND window value.  This is the\n\t             *      allowed range of request ids that are valid.  The default is 5.\n\t             */\n\t            _restore: function _restore(jid, callback, wait, hold, wind) {\n\t                var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\n\t                if (typeof session !== \"undefined\" && session !== null && session.rid && session.sid && session.jid && (typeof jid === \"undefined\" || jid === null || Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) ||\n\t                // If authcid is null, then it's an anonymous login, so\n\t                // we compare only the domains:\n\t                Strophe.getNodeFromJid(jid) === null && Strophe.getDomainFromJid(session.jid) === jid)) {\n\t                    this._conn.restored = true;\n\t                    this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\n\t                } else {\n\t                    throw { name: \"StropheSessionError\", message: \"_restore: no restoreable session.\" };\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _cacheSession\n\t             *  _Private_ handler for the beforeunload event.\n\t             *\n\t             *  This handler is used to process the Bosh-part of the initial request.\n\t             *  Parameters:\n\t             *    (Strophe.Request) bodyWrap - The received stanza.\n\t             */\n\t            _cacheSession: function _cacheSession() {\n\t                if (this._conn.authenticated) {\n\t                    if (this._conn.jid && this.rid && this.sid) {\n\t                        window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\n\t                            'jid': this._conn.jid,\n\t                            'rid': this.rid,\n\t                            'sid': this.sid\n\t                        }));\n\t                    }\n\t                } else {\n\t                    window.sessionStorage.removeItem('strophe-bosh-session');\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _connect_cb\n\t             *  _Private_ handler for initial connection request.\n\t             *\n\t             *  This handler is used to process the Bosh-part of the initial request.\n\t             *  Parameters:\n\t             *    (Strophe.Request) bodyWrap - The received stanza.\n\t             */\n\t            _connect_cb: function _connect_cb(bodyWrap) {\n\t                var typ = bodyWrap.getAttribute(\"type\");\n\t                var cond, conflict;\n\t                if (typ !== null && typ === \"terminate\") {\n\t                    // an error occurred\n\t                    cond = bodyWrap.getAttribute(\"condition\");\n\t                    Strophe.error(\"BOSH-Connection failed: \" + cond);\n\t                    conflict = bodyWrap.getElementsByTagName(\"conflict\");\n\t                    if (cond !== null) {\n\t                        if (cond === \"remote-stream-error\" && conflict.length > 0) {\n\t                            cond = \"conflict\";\n\t                        }\n\t                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n\t                    } else {\n\t                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n\t                    }\n\t                    this._conn._doDisconnect(cond);\n\t                    return Strophe.Status.CONNFAIL;\n\t                }\n\t\n\t                // check to make sure we don't overwrite these if _connect_cb is\n\t                // called multiple times in the case of missing stream:features\n\t                if (!this.sid) {\n\t                    this.sid = bodyWrap.getAttribute(\"sid\");\n\t                }\n\t                var wind = bodyWrap.getAttribute('requests');\n\t                if (wind) {\n\t                    this.window = parseInt(wind, 10);\n\t                }\n\t                var hold = bodyWrap.getAttribute('hold');\n\t                if (hold) {\n\t                    this.hold = parseInt(hold, 10);\n\t                }\n\t                var wait = bodyWrap.getAttribute('wait');\n\t                if (wait) {\n\t                    this.wait = parseInt(wait, 10);\n\t                }\n\t                var inactivity = bodyWrap.getAttribute('inactivity');\n\t                if (inactivity) {\n\t                    this.inactivity = parseInt(inactivity, 10);\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _disconnect\n\t             *  _Private_ part of Connection.disconnect for Bosh\n\t             *\n\t             *  Parameters:\n\t             *    (Request) pres - This stanza will be sent before disconnecting.\n\t             */\n\t            _disconnect: function _disconnect(pres) {\n\t                this._sendTerminate(pres);\n\t            },\n\t\n\t            /** PrivateFunction: _doDisconnect\n\t             *  _Private_ function to disconnect.\n\t             *\n\t             *  Resets the SID and RID.\n\t             */\n\t            _doDisconnect: function _doDisconnect() {\n\t                this.sid = null;\n\t                this.rid = Math.floor(Math.random() * 4294967295);\n\t                if (this._conn._sessionCachingSupported()) {\n\t                    window.sessionStorage.removeItem('strophe-bosh-session');\n\t                }\n\t\n\t                this._conn.nextValidRid(this.rid);\n\t            },\n\t\n\t            /** PrivateFunction: _emptyQueue\n\t             * _Private_ function to check if the Request queue is empty.\n\t             *\n\t             *  Returns:\n\t             *    True, if there are no Requests queued, False otherwise.\n\t             */\n\t            _emptyQueue: function _emptyQueue() {\n\t                return this._requests.length === 0;\n\t            },\n\t\n\t            /** PrivateFunction: _callProtocolErrorHandlers\n\t             *  _Private_ function to call error handlers registered for HTTP errors.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) req - The request that is changing readyState.\n\t             */\n\t            _callProtocolErrorHandlers: function _callProtocolErrorHandlers(req) {\n\t                var reqStatus = this._getRequestStatus(req),\n\t                    err_callback;\n\t                err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];\n\t                if (err_callback) {\n\t                    err_callback.call(this, reqStatus);\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _hitError\n\t             *  _Private_ function to handle the error count.\n\t             *\n\t             *  Requests are resent automatically until their error count reaches\n\t             *  5.  Each time an error is encountered, this function is called to\n\t             *  increment the count and disconnect if the count is too high.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) reqStatus - The request status.\n\t             */\n\t            _hitError: function _hitError(reqStatus) {\n\t                this.errors++;\n\t                Strophe.warn(\"request errored, status: \" + reqStatus + \", number of errors: \" + this.errors);\n\t                if (this.errors > 4) {\n\t                    this._conn._onDisconnectTimeout();\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _no_auth_received\n\t             *\n\t             * Called on stream start/restart when no stream:features\n\t             * has been received and sends a blank poll request.\n\t             */\n\t            _no_auth_received: function _no_auth_received(_callback) {\n\t                if (_callback) {\n\t                    _callback = _callback.bind(this._conn);\n\t                } else {\n\t                    _callback = this._conn._connect_cb.bind(this._conn);\n\t                }\n\t                var body = this._buildBody();\n\t                this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, _callback.bind(this._conn)), body.tree().getAttribute(\"rid\")));\n\t                this._throttledRequestHandler();\n\t            },\n\t\n\t            /** PrivateFunction: _onDisconnectTimeout\n\t             *  _Private_ timeout handler for handling non-graceful disconnection.\n\t             *\n\t             *  Cancels all remaining Requests and clears the queue.\n\t             */\n\t            _onDisconnectTimeout: function _onDisconnectTimeout() {\n\t                this._abortAllRequests();\n\t            },\n\t\n\t            /** PrivateFunction: _abortAllRequests\n\t             *  _Private_ helper function that makes sure all pending requests are aborted.\n\t             */\n\t            _abortAllRequests: function _abortAllRequests() {\n\t                var req;\n\t                while (this._requests.length > 0) {\n\t                    req = this._requests.pop();\n\t                    req.abort = true;\n\t                    req.xhr.abort();\n\t                    // jslint complains, but this is fine. setting to empty func\n\t                    // is necessary for IE6\n\t                    req.xhr.onreadystatechange = function () {}; // jshint ignore:line\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _onIdle\n\t             *  _Private_ handler called by Strophe.Connection._onIdle\n\t             *\n\t             *  Sends all queued Requests or polls with empty Request if there are none.\n\t             */\n\t            _onIdle: function _onIdle() {\n\t                var data = this._conn._data;\n\t                // if no requests are in progress, poll\n\t                if (this._conn.authenticated && this._requests.length === 0 && data.length === 0 && !this._conn.disconnecting) {\n\t                    Strophe.info(\"no requests during idle cycle, sending \" + \"blank request\");\n\t                    data.push(null);\n\t                }\n\t\n\t                if (this._conn.paused) {\n\t                    return;\n\t                }\n\t\n\t                if (this._requests.length < 2 && data.length > 0) {\n\t                    var body = this._buildBody();\n\t                    for (var i = 0; i < data.length; i++) {\n\t                        if (data[i] !== null) {\n\t                            if (data[i] === \"restart\") {\n\t                                body.attrs({\n\t                                    to: this._conn.domain,\n\t                                    \"xml:lang\": \"en\",\n\t                                    \"xmpp:restart\": \"true\",\n\t                                    \"xmlns:xmpp\": Strophe.NS.BOSH\n\t                                });\n\t                            } else {\n\t                                body.cnode(data[i]).up();\n\t                            }\n\t                        }\n\t                    }\n\t                    delete this._conn._data;\n\t                    this._conn._data = [];\n\t                    this._requests.push(new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute(\"rid\")));\n\t                    this._throttledRequestHandler();\n\t                }\n\t\n\t                if (this._requests.length > 0) {\n\t                    var time_elapsed = this._requests[0].age();\n\t                    if (this._requests[0].dead !== null) {\n\t                        if (this._requests[0].timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n\t                            this._throttledRequestHandler();\n\t                        }\n\t                    }\n\t\n\t                    if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\n\t                        Strophe.warn(\"Request \" + this._requests[0].id + \" timed out, over \" + Math.floor(Strophe.TIMEOUT * this.wait) + \" seconds since last activity\");\n\t                        this._throttledRequestHandler();\n\t                    }\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _getRequestStatus\n\t             *\n\t             *  Returns the HTTP status code from a Strophe.Request\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) req - The Strophe.Request instance.\n\t             *    (Integer) def - The default value that should be returned if no\n\t             *          status value was found.\n\t             */\n\t            _getRequestStatus: function _getRequestStatus(req, def) {\n\t                var reqStatus;\n\t                if (req.xhr.readyState === 4) {\n\t                    try {\n\t                        reqStatus = req.xhr.status;\n\t                    } catch (e) {\n\t                        // ignore errors from undefined status attribute. Works\n\t                        // around a browser bug\n\t                        Strophe.error(\"Caught an error while retrieving a request's status, \" + \"reqStatus: \" + reqStatus);\n\t                    }\n\t                }\n\t                if (typeof reqStatus === \"undefined\") {\n\t                    reqStatus = typeof def === 'number' ? def : 0;\n\t                }\n\t                return reqStatus;\n\t            },\n\t\n\t            /** PrivateFunction: _onRequestStateChange\n\t             *  _Private_ handler for Strophe.Request state changes.\n\t             *\n\t             *  This function is called when the XMLHttpRequest readyState changes.\n\t             *  It contains a lot of error handling logic for the many ways that\n\t             *  requests can fail, and calls the request callback when requests\n\t             *  succeed.\n\t             *\n\t             *  Parameters:\n\t             *    (Function) func - The handler for the request.\n\t             *    (Strophe.Request) req - The request that is changing readyState.\n\t             */\n\t            _onRequestStateChange: function _onRequestStateChange(func, req) {\n\t                Strophe.debug(\"request id \" + req.id + \".\" + req.sends + \" state changed to \" + req.xhr.readyState);\n\t                if (req.abort) {\n\t                    req.abort = false;\n\t                    return;\n\t                }\n\t                if (req.xhr.readyState !== 4) {\n\t                    // The request is not yet complete\n\t                    return;\n\t                }\n\t                var reqStatus = this._getRequestStatus(req);\n\t                if (this.disconnecting && reqStatus >= 400) {\n\t                    this._hitError(reqStatus);\n\t                    this._callProtocolErrorHandlers(req);\n\t                    return;\n\t                }\n\t\n\t                var valid_request = reqStatus > 0 && reqStatus < 500;\n\t                var too_many_retries = req.sends > this._conn.maxRetries;\n\t                if (valid_request || too_many_retries) {\n\t                    // remove from internal queue\n\t                    this._removeRequest(req);\n\t                    Strophe.debug(\"request id \" + req.id + \" should now be removed\");\n\t                }\n\t\n\t                if (reqStatus === 200) {\n\t                    // request succeeded\n\t                    var reqIs0 = this._requests[0] === req;\n\t                    var reqIs1 = this._requests[1] === req;\n\t                    // if request 1 finished, or request 0 finished and request\n\t                    // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\n\t                    // restart the other - both will be in the first spot, as the\n\t                    // completed request has been removed from the queue already\n\t                    if (reqIs1 || reqIs0 && this._requests.length > 0 && this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n\t                        this._restartRequest(0);\n\t                    }\n\t                    this._conn.nextValidRid(Number(req.rid) + 1);\n\t                    Strophe.debug(\"request id \" + req.id + \".\" + req.sends + \" got 200\");\n\t                    func(req); // call handler\n\t                    this.errors = 0;\n\t                } else if (reqStatus === 0 || reqStatus >= 400 && reqStatus < 600 || reqStatus >= 12000) {\n\t                    // request failed\n\t                    Strophe.error(\"request id \" + req.id + \".\" + req.sends + \" error \" + reqStatus + \" happened\");\n\t                    this._hitError(reqStatus);\n\t                    this._callProtocolErrorHandlers(req);\n\t                    if (reqStatus >= 400 && reqStatus < 500) {\n\t                        this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\n\t                        this._conn._doDisconnect();\n\t                    }\n\t                } else {\n\t                    Strophe.error(\"request id \" + req.id + \".\" + req.sends + \" error \" + reqStatus + \" happened\");\n\t                }\n\t\n\t                if (!valid_request && !too_many_retries) {\n\t                    this._throttledRequestHandler();\n\t                } else if (too_many_retries && !this._conn.connected) {\n\t                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"giving-up\");\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _processRequest\n\t             *  _Private_ function to process a request in the queue.\n\t             *\n\t             *  This function takes requests off the queue and sends them and\n\t             *  restarts dead requests.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) i - The index of the request in the queue.\n\t             */\n\t            _processRequest: function _processRequest(i) {\n\t                var self = this;\n\t                var req = this._requests[i];\n\t                var reqStatus = this._getRequestStatus(req, -1);\n\t\n\t                // make sure we limit the number of retries\n\t                if (req.sends > this._conn.maxRetries) {\n\t                    this._conn._onDisconnectTimeout();\n\t                    return;\n\t                }\n\t\n\t                var time_elapsed = req.age();\n\t                var primaryTimeout = !isNaN(time_elapsed) && time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait);\n\t                var secondaryTimeout = req.dead !== null && req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait);\n\t                var requestCompletedWithServerError = req.xhr.readyState === 4 && (reqStatus < 1 || reqStatus >= 500);\n\t                if (primaryTimeout || secondaryTimeout || requestCompletedWithServerError) {\n\t                    if (secondaryTimeout) {\n\t                        Strophe.error(\"Request \" + this._requests[i].id + \" timed out (secondary), restarting\");\n\t                    }\n\t                    req.abort = true;\n\t                    req.xhr.abort();\n\t                    // setting to null fails on IE6, so set to empty function\n\t                    req.xhr.onreadystatechange = function () {};\n\t                    this._requests[i] = new Strophe.Request(req.xmlData, req.origFunc, req.rid, req.sends);\n\t                    req = this._requests[i];\n\t                }\n\t\n\t                if (req.xhr.readyState === 0) {\n\t                    Strophe.debug(\"request id \" + req.id + \".\" + req.sends + \" posting\");\n\t\n\t                    try {\n\t                        var contentType = this._conn.options.contentType || \"text/xml; charset=utf-8\";\n\t                        req.xhr.open(\"POST\", this._conn.service, this._conn.options.sync ? false : true);\n\t                        if (typeof req.xhr.setRequestHeader !== 'undefined') {\n\t                            // IE9 doesn't have setRequestHeader\n\t                            req.xhr.setRequestHeader(\"Content-Type\", contentType);\n\t                        }\n\t                        if (this._conn.options.withCredentials) {\n\t                            req.xhr.withCredentials = true;\n\t                        }\n\t                    } catch (e2) {\n\t                        Strophe.error(\"XHR open failed: \" + e2.toString());\n\t                        if (!this._conn.connected) {\n\t                            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"bad-service\");\n\t                        }\n\t                        this._conn.disconnect();\n\t                        return;\n\t                    }\n\t\n\t                    // Fires the XHR request -- may be invoked immediately\n\t                    // or on a gradually expanding retry window for reconnects\n\t                    var sendFunc = function sendFunc() {\n\t                        req.date = new Date();\n\t                        if (self._conn.options.customHeaders) {\n\t                            var headers = self._conn.options.customHeaders;\n\t                            for (var header in headers) {\n\t                                if (headers.hasOwnProperty(header)) {\n\t                                    req.xhr.setRequestHeader(header, headers[header]);\n\t                                }\n\t                            }\n\t                        }\n\t                        req.xhr.send(req.data);\n\t                    };\n\t\n\t                    // Implement progressive backoff for reconnects --\n\t                    // First retry (send === 1) should also be instantaneous\n\t                    if (req.sends > 1) {\n\t                        // Using a cube of the retry number creates a nicely\n\t                        // expanding retry window\n\t                        var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait), Math.pow(req.sends, 3)) * 1000;\n\t                        setTimeout(function () {\n\t                            // XXX: setTimeout should be called only with function expressions (23974bc1)\n\t                            sendFunc();\n\t                        }, backoff);\n\t                    } else {\n\t                        sendFunc();\n\t                    }\n\t\n\t                    req.sends++;\n\t\n\t                    if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\n\t                        if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\n\t                            this._conn.xmlOutput(req.xmlData.childNodes[0]);\n\t                        } else {\n\t                            this._conn.xmlOutput(req.xmlData);\n\t                        }\n\t                    }\n\t                    if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\n\t                        this._conn.rawOutput(req.data);\n\t                    }\n\t                } else {\n\t                    Strophe.debug(\"_processRequest: \" + (i === 0 ? \"first\" : \"second\") + \" request has readyState of \" + req.xhr.readyState);\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _removeRequest\n\t             *  _Private_ function to remove a request from the queue.\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) req - The request to remove.\n\t             */\n\t            _removeRequest: function _removeRequest(req) {\n\t                Strophe.debug(\"removing request\");\n\t                var i;\n\t                for (i = this._requests.length - 1; i >= 0; i--) {\n\t                    if (req === this._requests[i]) {\n\t                        this._requests.splice(i, 1);\n\t                    }\n\t                }\n\t                // IE6 fails on setting to null, so set to empty function\n\t                req.xhr.onreadystatechange = function () {};\n\t                this._throttledRequestHandler();\n\t            },\n\t\n\t            /** PrivateFunction: _restartRequest\n\t             *  _Private_ function to restart a request that is presumed dead.\n\t             *\n\t             *  Parameters:\n\t             *    (Integer) i - The index of the request in the queue.\n\t             */\n\t            _restartRequest: function _restartRequest(i) {\n\t                var req = this._requests[i];\n\t                if (req.dead === null) {\n\t                    req.dead = new Date();\n\t                }\n\t\n\t                this._processRequest(i);\n\t            },\n\t\n\t            /** PrivateFunction: _reqToData\n\t             * _Private_ function to get a stanza out of a request.\n\t             *\n\t             * Tries to extract a stanza out of a Request Object.\n\t             * When this fails the current connection will be disconnected.\n\t             *\n\t             *  Parameters:\n\t             *    (Object) req - The Request.\n\t             *\n\t             *  Returns:\n\t             *    The stanza that was passed.\n\t             */\n\t            _reqToData: function _reqToData(req) {\n\t                try {\n\t                    return req.getResponse();\n\t                } catch (e) {\n\t                    if (e !== \"parsererror\") {\n\t                        throw e;\n\t                    }\n\t                    this._conn.disconnect(\"strophe-parsererror\");\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _sendTerminate\n\t             *  _Private_ function to send initial disconnect sequence.\n\t             *\n\t             *  This is the first step in a graceful disconnect.  It sends\n\t             *  the BOSH server a terminate body and includes an unavailable\n\t             *  presence if authentication has completed.\n\t             */\n\t            _sendTerminate: function _sendTerminate(pres) {\n\t                Strophe.info(\"_sendTerminate was called\");\n\t                var body = this._buildBody().attrs({ type: \"terminate\" });\n\t                if (pres) {\n\t                    body.cnode(pres.tree());\n\t                }\n\t                var req = new Strophe.Request(body.tree(), this._onRequestStateChange.bind(this, this._conn._dataRecv.bind(this._conn)), body.tree().getAttribute(\"rid\"));\n\t                this._requests.push(req);\n\t                this._throttledRequestHandler();\n\t            },\n\t\n\t            /** PrivateFunction: _send\n\t             *  _Private_ part of the Connection.send function for BOSH\n\t             *\n\t             * Just triggers the RequestHandler to send the messages that are in the queue\n\t             */\n\t            _send: function _send() {\n\t                clearTimeout(this._conn._idleTimeout);\n\t                this._throttledRequestHandler();\n\t\n\t                // XXX: setTimeout should be called only with function expressions (23974bc1)\n\t                this._conn._idleTimeout = setTimeout(function () {\n\t                    this._onIdle();\n\t                }.bind(this._conn), 100);\n\t            },\n\t\n\t            /** PrivateFunction: _sendRestart\n\t             *\n\t             *  Send an xmpp:restart stanza.\n\t             */\n\t            _sendRestart: function _sendRestart() {\n\t                this._throttledRequestHandler();\n\t                clearTimeout(this._conn._idleTimeout);\n\t            },\n\t\n\t            /** PrivateFunction: _throttledRequestHandler\n\t             *  _Private_ function to throttle requests to the connection window.\n\t             *\n\t             *  This function makes sure we don't send requests so fast that the\n\t             *  request ids overflow the connection window in the case that one\n\t             *  request died.\n\t             */\n\t            _throttledRequestHandler: function _throttledRequestHandler() {\n\t                if (!this._requests) {\n\t                    Strophe.debug(\"_throttledRequestHandler called with \" + \"undefined requests\");\n\t                } else {\n\t                    Strophe.debug(\"_throttledRequestHandler called with \" + this._requests.length + \" requests\");\n\t                }\n\t\n\t                if (!this._requests || this._requests.length === 0) {\n\t                    return;\n\t                }\n\t\n\t                if (this._requests.length > 0) {\n\t                    this._processRequest(0);\n\t                }\n\t\n\t                if (this._requests.length > 1 && Math.abs(this._requests[0].rid - this._requests[1].rid) < this.window) {\n\t                    this._processRequest(1);\n\t                }\n\t            }\n\t        };\n\t        return Strophe;\n\t    });\n\t\n\t    /*\n\t        This program is distributed under the terms of the MIT license.\n\t        Please see the LICENSE file for details.\n\t    \n\t        Copyright 2006-2008, OGG, LLC\n\t    */\n\t\n\t    /* jshint undef: true, unused: true:, noarg: true, latedef: true */\n\t    /* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */\n\t\n\t    (function (root, factory) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe-websocket', ['strophe-core'], function (core) {\n\t                return factory(core.Strophe, core.$build);\n\t            });\n\t        } else {\n\t            // Browser globals\n\t            return factory(Strophe, $build);\n\t        }\n\t    })(this, function (Strophe, $build) {\n\t\n\t        /** Class: Strophe.WebSocket\n\t         *  _Private_ helper class that handles WebSocket Connections\n\t         *\n\t         *  The Strophe.WebSocket class is used internally by Strophe.Connection\n\t         *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\n\t         */\n\t\n\t        /** File: websocket.js\n\t         *  A JavaScript library to enable XMPP over Websocket in Strophejs.\n\t         *\n\t         *  This file implements XMPP over WebSockets for Strophejs.\n\t         *  If a Connection is established with a Websocket url (ws://...)\n\t         *  Strophe will use WebSockets.\n\t         *  For more information on XMPP-over-WebSocket see RFC 7395:\n\t         *  http://tools.ietf.org/html/rfc7395\n\t         *\n\t         *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\n\t         */\n\t\n\t        /** PrivateConstructor: Strophe.Websocket\n\t         *  Create and initialize a Strophe.WebSocket object.\n\t         *  Currently only sets the connection Object.\n\t         *\n\t         *  Parameters:\n\t         *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\n\t         *\n\t         *  Returns:\n\t         *    A new Strophe.WebSocket object.\n\t         */\n\t        Strophe.Websocket = function (connection) {\n\t            this._conn = connection;\n\t            this.strip = \"wrapper\";\n\t\n\t            var service = connection.service;\n\t            if (service.indexOf(\"ws:\") !== 0 && service.indexOf(\"wss:\") !== 0) {\n\t                // If the service is not an absolute URL, assume it is a path and put the absolute\n\t                // URL together from options, current URL and the path.\n\t                var new_service = \"\";\n\t\n\t                if (connection.options.protocol === \"ws\" && window.location.protocol !== \"https:\") {\n\t                    new_service += \"ws\";\n\t                } else {\n\t                    new_service += \"wss\";\n\t                }\n\t\n\t                new_service += \"://\" + window.location.host;\n\t\n\t                if (service.indexOf(\"/\") !== 0) {\n\t                    new_service += window.location.pathname + service;\n\t                } else {\n\t                    new_service += service;\n\t                }\n\t\n\t                connection.service = new_service;\n\t            }\n\t        };\n\t\n\t        Strophe.Websocket.prototype = {\n\t            /** PrivateFunction: _buildStream\n\t             *  _Private_ helper function to generate the <stream> start tag for WebSockets\n\t             *\n\t             *  Returns:\n\t             *    A Strophe.Builder with a <stream> element.\n\t             */\n\t            _buildStream: function _buildStream() {\n\t                return $build(\"open\", {\n\t                    \"xmlns\": Strophe.NS.FRAMING,\n\t                    \"to\": this._conn.domain,\n\t                    \"version\": '1.0'\n\t                });\n\t            },\n\t\n\t            /** PrivateFunction: _check_streamerror\n\t             * _Private_ checks a message for stream:error\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) bodyWrap - The received stanza.\n\t             *    connectstatus - The ConnectStatus that will be set on error.\n\t             *  Returns:\n\t             *     true if there was a streamerror, false otherwise.\n\t             */\n\t            _check_streamerror: function _check_streamerror(bodyWrap, connectstatus) {\n\t                var errors;\n\t                if (bodyWrap.getElementsByTagNameNS) {\n\t                    errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"error\");\n\t                } else {\n\t                    errors = bodyWrap.getElementsByTagName(\"stream:error\");\n\t                }\n\t                if (errors.length === 0) {\n\t                    return false;\n\t                }\n\t                var error = errors[0];\n\t\n\t                var condition = \"\";\n\t                var text = \"\";\n\t\n\t                var ns = \"urn:ietf:params:xml:ns:xmpp-streams\";\n\t                for (var i = 0; i < error.childNodes.length; i++) {\n\t                    var e = error.childNodes[i];\n\t                    if (e.getAttribute(\"xmlns\") !== ns) {\n\t                        break;\n\t                    }if (e.nodeName === \"text\") {\n\t                        text = e.textContent;\n\t                    } else {\n\t                        condition = e.nodeName;\n\t                    }\n\t                }\n\t\n\t                var errorString = \"WebSocket stream error: \";\n\t\n\t                if (condition) {\n\t                    errorString += condition;\n\t                } else {\n\t                    errorString += \"unknown\";\n\t                }\n\t\n\t                if (text) {\n\t                    errorString += \" - \" + text;\n\t                }\n\t\n\t                Strophe.error(errorString);\n\t\n\t                // close the connection on stream_error\n\t                this._conn._changeConnectStatus(connectstatus, condition);\n\t                this._conn._doDisconnect();\n\t                return true;\n\t            },\n\t\n\t            /** PrivateFunction: _reset\n\t             *  Reset the connection.\n\t             *\n\t             *  This function is called by the reset function of the Strophe Connection.\n\t             *  Is not needed by WebSockets.\n\t             */\n\t            _reset: function _reset() {\n\t                return;\n\t            },\n\t\n\t            /** PrivateFunction: _connect\n\t             *  _Private_ function called by Strophe.Connection.connect\n\t             *\n\t             *  Creates a WebSocket for a connection and assigns Callbacks to it.\n\t             *  Does nothing if there already is a WebSocket.\n\t             */\n\t            _connect: function _connect() {\n\t                // Ensure that there is no open WebSocket from a previous Connection.\n\t                this._closeSocket();\n\t\n\t                // Create the new WobSocket\n\t                this.socket = new WebSocket(this._conn.service, \"xmpp\");\n\t                this.socket.onopen = this._onOpen.bind(this);\n\t                this.socket.onerror = this._onError.bind(this);\n\t                this.socket.onclose = this._onClose.bind(this);\n\t                this.socket.onmessage = this._connect_cb_wrapper.bind(this);\n\t            },\n\t\n\t            /** PrivateFunction: _connect_cb\n\t             *  _Private_ function called by Strophe.Connection._connect_cb\n\t             *\n\t             * checks for stream:error\n\t             *\n\t             *  Parameters:\n\t             *    (Strophe.Request) bodyWrap - The received stanza.\n\t             */\n\t            _connect_cb: function _connect_cb(bodyWrap) {\n\t                var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\n\t                if (error) {\n\t                    return Strophe.Status.CONNFAIL;\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _handleStreamStart\n\t             * _Private_ function that checks the opening <open /> tag for errors.\n\t             *\n\t             * Disconnects if there is an error and returns false, true otherwise.\n\t             *\n\t             *  Parameters:\n\t             *    (Node) message - Stanza containing the <open /> tag.\n\t             */\n\t            _handleStreamStart: function _handleStreamStart(message) {\n\t                var error = false;\n\t\n\t                // Check for errors in the <open /> tag\n\t                var ns = message.getAttribute(\"xmlns\");\n\t                if (typeof ns !== \"string\") {\n\t                    error = \"Missing xmlns in <open />\";\n\t                } else if (ns !== Strophe.NS.FRAMING) {\n\t                    error = \"Wrong xmlns in <open />: \" + ns;\n\t                }\n\t\n\t                var ver = message.getAttribute(\"version\");\n\t                if (typeof ver !== \"string\") {\n\t                    error = \"Missing version in <open />\";\n\t                } else if (ver !== \"1.0\") {\n\t                    error = \"Wrong version in <open />: \" + ver;\n\t                }\n\t\n\t                if (error) {\n\t                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\n\t                    this._conn._doDisconnect();\n\t                    return false;\n\t                }\n\t\n\t                return true;\n\t            },\n\t\n\t            /** PrivateFunction: _connect_cb_wrapper\n\t             * _Private_ function that handles the first connection messages.\n\t             *\n\t             * On receiving an opening stream tag this callback replaces itself with the real\n\t             * message handler. On receiving a stream error the connection is terminated.\n\t             */\n\t            _connect_cb_wrapper: function _connect_cb_wrapper(message) {\n\t                if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n\t                    // Strip the XML Declaration, if there is one\n\t                    var data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n\t                    if (data === '') return;\n\t\n\t                    var streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n\t                    this._conn.xmlInput(streamStart);\n\t                    this._conn.rawInput(message.data);\n\t\n\t                    //_handleStreamSteart will check for XML errors and disconnect on error\n\t                    if (this._handleStreamStart(streamStart)) {\n\t                        //_connect_cb will check for stream:error and disconnect on error\n\t                        this._connect_cb(streamStart);\n\t                    }\n\t                } else if (message.data.indexOf(\"<close \") === 0) {\n\t                    // <close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing />\n\t                    this._conn.rawInput(message.data);\n\t                    this._conn.xmlInput(message);\n\t                    var see_uri = message.getAttribute(\"see-other-uri\");\n\t                    if (see_uri) {\n\t                        this._conn._changeConnectStatus(Strophe.Status.REDIRECT, \"Received see-other-uri, resetting connection\");\n\t                        this._conn.reset();\n\t                        this._conn.service = see_uri;\n\t                        this._connect();\n\t                    } else {\n\t                        this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"Received closing stream\");\n\t                        this._conn._doDisconnect();\n\t                    }\n\t                } else {\n\t                    var string = this._streamWrap(message.data);\n\t                    var elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n\t                    this.socket.onmessage = this._onMessage.bind(this);\n\t                    this._conn._connect_cb(elem, null, message.data);\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _disconnect\n\t             *  _Private_ function called by Strophe.Connection.disconnect\n\t             *\n\t             *  Disconnects and sends a last stanza if one is given\n\t             *\n\t             *  Parameters:\n\t             *    (Request) pres - This stanza will be sent before disconnecting.\n\t             */\n\t            _disconnect: function _disconnect(pres) {\n\t                if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\n\t                    if (pres) {\n\t                        this._conn.send(pres);\n\t                    }\n\t                    var close = $build(\"close\", { \"xmlns\": Strophe.NS.FRAMING });\n\t                    this._conn.xmlOutput(close);\n\t                    var closeString = Strophe.serialize(close);\n\t                    this._conn.rawOutput(closeString);\n\t                    try {\n\t                        this.socket.send(closeString);\n\t                    } catch (e) {\n\t                        Strophe.info(\"Couldn't send <close /> tag.\");\n\t                    }\n\t                }\n\t                this._conn._doDisconnect();\n\t            },\n\t\n\t            /** PrivateFunction: _doDisconnect\n\t             *  _Private_ function to disconnect.\n\t             *\n\t             *  Just closes the Socket for WebSockets\n\t             */\n\t            _doDisconnect: function _doDisconnect() {\n\t                Strophe.info(\"WebSockets _doDisconnect was called\");\n\t                this._closeSocket();\n\t            },\n\t\n\t            /** PrivateFunction _streamWrap\n\t             *  _Private_ helper function to wrap a stanza in a <stream> tag.\n\t             *  This is used so Strophe can process stanzas from WebSockets like BOSH\n\t             */\n\t            _streamWrap: function _streamWrap(stanza) {\n\t                return \"<wrapper>\" + stanza + '</wrapper>';\n\t            },\n\t\n\t            /** PrivateFunction: _closeSocket\n\t             *  _Private_ function to close the WebSocket.\n\t             *\n\t             *  Closes the socket if it is still open and deletes it\n\t             */\n\t            _closeSocket: function _closeSocket() {\n\t                if (this.socket) {\n\t                    try {\n\t                        this.socket.close();\n\t                    } catch (e) {}\n\t                }\n\t                this.socket = null;\n\t            },\n\t\n\t            /** PrivateFunction: _emptyQueue\n\t             * _Private_ function to check if the message queue is empty.\n\t             *\n\t             *  Returns:\n\t             *    True, because WebSocket messages are send immediately after queueing.\n\t             */\n\t            _emptyQueue: function _emptyQueue() {\n\t                return true;\n\t            },\n\t\n\t            /** PrivateFunction: _onClose\n\t             * _Private_ function to handle websockets closing.\n\t             *\n\t             * Nothing to do here for WebSockets\n\t             */\n\t            _onClose: function _onClose(e) {\n\t                if (this._conn.connected && !this._conn.disconnecting) {\n\t                    Strophe.error(\"Websocket closed unexpectedly\");\n\t                    this._conn._doDisconnect();\n\t                } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {\n\t                    // in case the onError callback was not called (Safari 10 does not\n\t                    // call onerror when the initial connection fails) we need to\n\t                    // dispatch a CONNFAIL status update to be consistent with the\n\t                    // behavior on other browsers.\n\t                    Strophe.error(\"Websocket closed unexcectedly\");\n\t                    this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"The WebSocket connection could not be established or was disconnected.\");\n\t                    this._conn._doDisconnect();\n\t                } else {\n\t                    Strophe.info(\"Websocket closed\");\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _no_auth_received\n\t             *\n\t             * Called on stream start/restart when no stream:features\n\t             * has been received.\n\t             */\n\t            _no_auth_received: function _no_auth_received(_callback) {\n\t                Strophe.error(\"Server did not send any auth methods\");\n\t                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"Server did not send any auth methods\");\n\t                if (_callback) {\n\t                    _callback = _callback.bind(this._conn);\n\t                    _callback();\n\t                }\n\t                this._conn._doDisconnect();\n\t            },\n\t\n\t            /** PrivateFunction: _onDisconnectTimeout\n\t             *  _Private_ timeout handler for handling non-graceful disconnection.\n\t             *\n\t             *  This does nothing for WebSockets\n\t             */\n\t            _onDisconnectTimeout: function _onDisconnectTimeout() {},\n\t\n\t            /** PrivateFunction: _abortAllRequests\n\t             *  _Private_ helper function that makes sure all pending requests are aborted.\n\t             */\n\t            _abortAllRequests: function _abortAllRequests() {},\n\t\n\t            /** PrivateFunction: _onError\n\t             * _Private_ function to handle websockets errors.\n\t             *\n\t             * Parameters:\n\t             * (Object) error - The websocket error.\n\t             */\n\t            _onError: function _onError(error) {\n\t                Strophe.error(\"Websocket error \" + error);\n\t                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"The WebSocket connection could not be established or was disconnected.\");\n\t                this._disconnect();\n\t            },\n\t\n\t            /** PrivateFunction: _onIdle\n\t             *  _Private_ function called by Strophe.Connection._onIdle\n\t             *\n\t             *  sends all queued stanzas\n\t             */\n\t            _onIdle: function _onIdle() {\n\t                var data = this._conn._data;\n\t                if (data.length > 0 && !this._conn.paused) {\n\t                    for (var i = 0; i < data.length; i++) {\n\t                        if (data[i] !== null) {\n\t                            var stanza, rawStanza;\n\t                            if (data[i] === \"restart\") {\n\t                                stanza = this._buildStream().tree();\n\t                            } else {\n\t                                stanza = data[i];\n\t                            }\n\t                            rawStanza = Strophe.serialize(stanza);\n\t                            this._conn.xmlOutput(stanza);\n\t                            this._conn.rawOutput(rawStanza);\n\t                            this.socket.send(rawStanza);\n\t                        }\n\t                    }\n\t                    this._conn._data = [];\n\t                }\n\t            },\n\t\n\t            /** PrivateFunction: _onMessage\n\t             * _Private_ function to handle websockets messages.\n\t             *\n\t             * This function parses each of the messages as if they are full documents.\n\t             * [TODO : We may actually want to use a SAX Push parser].\n\t             *\n\t             * Since all XMPP traffic starts with\n\t             *  <stream:stream version='1.0'\n\t             *                 xml:lang='en'\n\t             *                 xmlns='jabber:client'\n\t             *                 xmlns:stream='http://etherx.jabber.org/streams'\n\t             *                 id='3697395463'\n\t             *                 from='SERVER'>\n\t             *\n\t             * The first stanza will always fail to be parsed.\n\t             *\n\t             * Additionally, the seconds stanza will always be <stream:features> with\n\t             * the stream NS defined in the previous stanza, so we need to 'force'\n\t             * the inclusion of the NS in this stanza.\n\t             *\n\t             * Parameters:\n\t             * (string) message - The websocket message.\n\t             */\n\t            _onMessage: function _onMessage(message) {\n\t                var elem, data;\n\t                // check for closing stream\n\t                var close = '<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing\" />';\n\t                if (message.data === close) {\n\t                    this._conn.rawInput(close);\n\t                    this._conn.xmlInput(message);\n\t                    if (!this._conn.disconnecting) {\n\t                        this._conn._doDisconnect();\n\t                    }\n\t                    return;\n\t                } else if (message.data.search(\"<open \") === 0) {\n\t                    // This handles stream restarts\n\t                    elem = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n\t                    if (!this._handleStreamStart(elem)) {\n\t                        return;\n\t                    }\n\t                } else {\n\t                    data = this._streamWrap(message.data);\n\t                    elem = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n\t                }\n\t\n\t                if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\n\t                    return;\n\t                }\n\t\n\t                //handle unavailable presence stanza before disconnecting\n\t                if (this._conn.disconnecting && elem.firstChild.nodeName === \"presence\" && elem.firstChild.getAttribute(\"type\") === \"unavailable\") {\n\t                    this._conn.xmlInput(elem);\n\t                    this._conn.rawInput(Strophe.serialize(elem));\n\t                    // if we are already disconnecting we will ignore the unavailable stanza and\n\t                    // wait for the </stream:stream> tag before we close the connection\n\t                    return;\n\t                }\n\t                this._conn._dataRecv(elem, message.data);\n\t            },\n\t\n\t            /** PrivateFunction: _onOpen\n\t             * _Private_ function to handle websockets connection setup.\n\t             *\n\t             * The opening stream tag is sent here.\n\t             */\n\t            _onOpen: function _onOpen() {\n\t                Strophe.info(\"Websocket open\");\n\t                var start = this._buildStream();\n\t                this._conn.xmlOutput(start.tree());\n\t\n\t                var startString = Strophe.serialize(start);\n\t                this._conn.rawOutput(startString);\n\t                this.socket.send(startString);\n\t            },\n\t\n\t            /** PrivateFunction: _reqToData\n\t             * _Private_ function to get a stanza out of a request.\n\t             *\n\t             * WebSockets don't use requests, so the passed argument is just returned.\n\t             *\n\t             *  Parameters:\n\t             *    (Object) stanza - The stanza.\n\t             *\n\t             *  Returns:\n\t             *    The stanza that was passed.\n\t             */\n\t            _reqToData: function _reqToData(stanza) {\n\t                return stanza;\n\t            },\n\t\n\t            /** PrivateFunction: _send\n\t             *  _Private_ part of the Connection.send function for WebSocket\n\t             *\n\t             * Just flushes the messages that are in the queue\n\t             */\n\t            _send: function _send() {\n\t                this._conn.flush();\n\t            },\n\t\n\t            /** PrivateFunction: _sendRestart\n\t             *\n\t             *  Send an xmpp:restart stanza.\n\t             */\n\t            _sendRestart: function _sendRestart() {\n\t                clearTimeout(this._conn._idleTimeout);\n\t                this._conn._onIdle.bind(this._conn)();\n\t            }\n\t        };\n\t        return Strophe;\n\t    });\n\t\n\t    (function (root) {\n\t        if (typeof define === 'function' && define.amd) {\n\t            define('strophe', [\"strophe-core\", \"strophe-bosh\", \"strophe-websocket\"], function (wrapper) {\n\t                return wrapper;\n\t            });\n\t        }\n\t    })(this);\n\t\n\t    require([\"strophe-polyfill\"]);\n\t    /* jshint ignore:start */\n\t    //The modules for your project will be inlined above\n\t    //this snippet. Ask almond to synchronously require the\n\t    //module value for 'main' here and return it as the\n\t    //value to use for the public API for the built file.\n\t    return require('strophe');\n\t});\n\t/* jshint ignore:end */\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// sdk/dist/strophe-1.2.14.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c9402f91bc3dfc2c1147","/** File: strophe.js\n *  A JavaScript library for writing XMPP clients.\n *\n *  This library uses either Bidirectional-streams Over Synchronous HTTP (BOSH)\n *  to emulate a persistent, stateful, two-way connection to an XMPP server or\n *  alternatively WebSockets.\n *\n *  More information on BOSH can be found in XEP 124.\n *  For more information on XMPP-over WebSocket see this RFC:\n *  http://tools.ietf.org/html/rfc7395\n */\n\n/* All of the Strophe globals are defined in this special function below so\n * that references to the globals become closures.  This will ensure that\n * on page reload, these references will still be available to callbacks\n * that are still executing.\n */\n\n/* jshint ignore:start */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        //Allow using this built library as an AMD module\n        //in another project. That other project will only\n        //see this AMD call, not the internal modules in\n        //the closure below.\n        define([], factory);\n    } else {\n        //Browser globals case.\n        var wrapper = factory();\n        root.Strophe        = wrapper.Strophe;\n        root.$build         = wrapper.$build;\n        root.$iq            = wrapper.$iq;\n        root.$msg           = wrapper.$msg;\n        root.$pres          = wrapper.$pres;\n        root.SHA1           = wrapper.SHA1;\n        root.MD5            = wrapper.MD5;\n        root.b64_hmac_sha1  = wrapper.b64_hmac_sha1;\n        root.b64_sha1       = wrapper.b64_sha1;\n        root.str_hmac_sha1  = wrapper.str_hmac_sha1;\n        root.str_sha1       = wrapper.str_sha1;\n    }\n}(this, function () {\n    //almond, and your modules will be inlined here\n/* jshint ignore:end */\n/**\n * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name) {\n            name = name.split('/');\n            lastIndex = name.length - 1;\n\n            // If wanting node ID compatibility, strip .js from end\n            // of IDs. Have to do this here, and not in nameToUrl\n            // because node allows either .js or non .js to map\n            // to same file.\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n            }\n\n            // Starts with a '.' so need the baseName\n            if (name[0].charAt(0) === '.' && baseParts) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that 'directory' and not name of the baseName's\n                //module. For instance, baseName of 'one/two/three', maps to\n                //'one/two/three.js', but we want the directory, 'one/two' for\n                //this normalization.\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                name = normalizedBaseParts.concat(name);\n            }\n\n            //start trimDots\n            for (i = 0; i < name.length; i++) {\n                part = name[i];\n                if (part === '.') {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        name.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n            //end trimDots\n\n            name = name.join('/');\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not require('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    //Creates a parts array for a relName where first part is plugin ID,\n    //second part is resource ID. Assumes relName has already been normalized.\n    function makeRelParts(relName) {\n        return relName ? splitPrefix(relName) : [];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relParts) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0],\n            relResourceName = relParts[1];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relResourceName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relResourceName));\n            } else {\n                name = normalize(name, relResourceName);\n            }\n        } else {\n            name = normalize(name, relResourceName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i, relParts,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n        relParts = makeRelParts(relName);\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relParts);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, makeRelParts(callback)).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"node_modules/almond/almond.js\", function(){});\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/* global define */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-polyfill',[], function () {\n            return factory(root);\n        });\n    } else {\n        // Browser globals\n        return factory(root);\n    }\n}(this, function (root) {\n\n/** Function: Function.prototype.bind\n *  Bind a function to an instance.\n *\n *  This Function object extension method creates a bound method similar\n *  to those in Python.  This means that the 'this' object will point\n *  to the instance you want.  See <MDC's bind() documentation at https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind>\n *  and <Bound Functions and Function Imports in JavaScript at http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/>\n *  for a complete explanation.\n *\n *  This extension already exists in some browsers (namely, Firefox 3), but\n *  we provide it to support those that don't.\n *\n *  Parameters:\n *    (Object) obj - The object that will become 'this' in the bound function.\n *    (Object) argN - An option argument that will be prepended to the\n *      arguments given for the function call\n *\n *  Returns:\n *    The bound function.\n */\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function (obj /*, arg1, arg2, ... */) {\n        var func = this;\n        var _slice = Array.prototype.slice;\n        var _concat = Array.prototype.concat;\n        var _args = _slice.call(arguments, 1);\n        return function () {\n            return func.apply(obj ? obj : this, _concat.call(_args, _slice.call(arguments, 0)));\n        };\n    };\n}\n\n/** Function: Array.isArray\n *  This is a polyfill for the ES5 Array.isArray method.\n */\nif (!Array.isArray) {\n    Array.isArray = function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n}\n\n/** Function: Array.prototype.indexOf\n *  Return the index of an object in an array.\n *\n *  This function is not supplied by some JavaScript implementations, so\n *  we provide it if it is missing.  This code is from:\n *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf\n *\n *  Parameters:\n *    (Object) elt - The object to look for.\n *    (Integer) from - The index from which to start looking. (optional).\n *\n *  Returns:\n *    The index of elt in the array or -1 if not found.\n */\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(elt /*, from*/) {\n        var len = this.length;\n        var from = Number(arguments[1]) || 0;\n        from = (from < 0) ? Math.ceil(from) : Math.floor(from);\n        if (from < 0) {\n            from += len;\n        }\n\n        for (; from < len; from++) {\n            if (from in this && this[from] === elt) {\n                return from;\n            }\n        }\n        return -1;\n    };\n}\n\n/** Function: Array.prototype.forEach\n *\n *  This function is not available in IE < 9\n *\n *  See <forEach on developer.mozilla.org at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach>\n */\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function(callback, thisArg) {\n        var T, k;\n        if (this === null) {\n            throw new TypeError(' this is null or not defined');\n        }\n        // 1. Let O be the result of calling toObject() passing the\n        // |this| value as the argument.\n        var O = Object(this);\n        // 2. Let lenValue be the result of calling the Get() internal\n        // method of O with the argument \"length\".\n        // 3. Let len be toUint32(lenValue).\n        var len = O.length >>> 0;\n        // 4. If isCallable(callback) is false, throw a TypeError exception.\n        // See: http://es5.github.com/#x9.11\n        if (typeof callback !== \"function\") {\n            throw new TypeError(callback + ' is not a function');\n        }\n        // 5. If thisArg was supplied, let T be thisArg; else let\n        // T be undefined.\n        if (arguments.length > 1) {\n            T = thisArg;\n        }\n        // 6. Let k be 0\n        k = 0;\n        // 7. Repeat, while k < len\n        while (k < len) {\n            var kValue;\n            // a. Let Pk be ToString(k).\n            //        This is implicit for LHS operands of the in operator\n            // b. Let kPresent be the result of calling the HasProperty\n            //        internal method of O with argument Pk.\n            //        This step can be combined with c\n            // c. If kPresent is true, then\n            if (k in O) {\n                // i. Let kValue be the result of calling the Get internal\n                // method of O with argument Pk.\n                kValue = O[k];\n                // ii. Call the Call internal method of callback with T as\n                // the this value and argument list containing kValue, k, and O.\n                callback.call(T, kValue, k, O);\n            }\n            // d. Increase k by 1.\n            k++;\n        }\n        // 8. return undefined\n    };\n}\n\n// This code was written by Tyler Akins and has been placed in the\n// public domain.  It would be nice if you left this header intact.\n// Base64 code from Tyler Akins -- http://rumkin.com\nvar keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nif (!root.btoa) {\n    root.btoa = function (input) {\n        /**\n         * Encodes a string in base64\n         * @param {String} input The string to encode in base64.\n         */\n        var output = \"\";\n        var chr1, chr2, chr3;\n        var enc1, enc2, enc3, enc4;\n        var i = 0;\n        do {\n            chr1 = input.charCodeAt(i++);\n            chr2 = input.charCodeAt(i++);\n            chr3 = input.charCodeAt(i++);\n\n            enc1 = chr1 >> 2;\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n            enc4 = chr3 & 63;\n\n            if (isNaN(chr2)) {\n                enc2 = ((chr1 & 3) << 4);\n                enc3 = enc4 = 64;\n            } else if (isNaN(chr3)) {\n                enc4 = 64;\n            }\n            output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +\n                keyStr.charAt(enc3) + keyStr.charAt(enc4);\n        } while (i < input.length);\n        return output;\n    };\n}\n\nif (!root.atob) {\n    root.atob = function (input) {\n        /**\n         * Decodes a base64 string.\n         * @param {String} input The string to decode.\n         */\n        var output = \"\";\n        var chr1, chr2, chr3;\n        var enc1, enc2, enc3, enc4;\n        var i = 0;\n        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n        input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n        do {\n            enc1 = keyStr.indexOf(input.charAt(i++));\n            enc2 = keyStr.indexOf(input.charAt(i++));\n            enc3 = keyStr.indexOf(input.charAt(i++));\n            enc4 = keyStr.indexOf(input.charAt(i++));\n\n            chr1 = (enc1 << 2) | (enc2 >> 4);\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n            chr3 = ((enc3 & 3) << 6) | enc4;\n\n            output = output + String.fromCharCode(chr1);\n\n            if (enc3 !== 64) {\n                output = output + String.fromCharCode(chr2);\n            }\n            if (enc4 !== 64) {\n                output = output + String.fromCharCode(chr3);\n            }\n        } while (i < input.length);\n        return output;\n    };\n}\n}));\n\n/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: false */\n/* global define */\n\n/* Some functions and variables have been stripped for use with Strophe */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-sha1', [],function () {\n            return factory();\n        });\n    } else {\n        // Browser globals\n        root.SHA1 = factory();\n    }\n}(this, function () {\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = new Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  var i, j, t, olda, oldb, oldc, oldd, olde;\n  for (i = 0; i < x.length; i += 16)\n  {\n    olda = a;\n    oldb = b;\n    oldc = c;\n    oldd = d;\n    olde = e;\n\n    for (j = 0; j < 80; j++)\n    {\n      if (j < 16) { w[j] = x[i + j]; }\n      else { w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1); }\n      t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return [a, b, c, d, e];\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if (t < 20) { return (b & c) | ((~b) & d); }\n  if (t < 40) { return b ^ c ^ d; }\n  if (t < 60) { return (b & c) | (b & d) | (c & d); }\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if (bkey.length > 16) { bkey = core_sha1(bkey, key.length * 8); }\n\n  var ipad = new Array(16), opad = new Array(16);\n  for (var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * 8);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = [];\n  var mask = 255;\n  for (var i = 0; i < str.length * 8; i += 8)\n  {\n    bin[i>>5] |= (str.charCodeAt(i / 8) & mask) << (24 - i%32);\n  }\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = 255;\n  for (var i = 0; i < bin.length * 32; i += 8)\n  {\n    str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  var triplet, j;\n  for (var i = 0; i < binarray.length * 4; i += 3)\n  {\n    triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16) |\n              (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 ) |\n               ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for (j = 0; j < 4; j++)\n    {\n      if (i * 8 + j * 6 > binarray.length * 32) { str += \"=\"; }\n      else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }\n    }\n  }\n  return str;\n}\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nreturn {\n    b64_hmac_sha1:  function (key, data){ return binb2b64(core_hmac_sha1(key, data)); },\n    b64_sha1:       function (s) { return binb2b64(core_sha1(str2binb(s),s.length * 8)); },\n    binb2str:       binb2str,\n    core_hmac_sha1: core_hmac_sha1,\n    str_hmac_sha1:  function (key, data){ return binb2str(core_hmac_sha1(key, data)); },\n    str_sha1:       function (s) { return binb2str(core_sha1(str2binb(s),s.length * 8)); },\n};\n}));\n\n/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n/*\n * Everything that isn't used by Strophe has been stripped here!\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-md5',[], function () {\n            return factory();\n        });\n    } else {\n        // Browser globals\n        root.MD5 = factory();\n    }\n}(this, function () {\n    /*\n     * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n     * to work around bugs in some JS interpreters.\n     */\n    var safe_add = function (x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    };\n\n    /*\n     * Bitwise rotate a 32-bit number to the left.\n     */\n    var bit_rol = function (num, cnt) {\n        return (num << cnt) | (num >>> (32 - cnt));\n    };\n\n    /*\n     * Convert a string to an array of little-endian words\n     */\n    var str2binl = function (str) {\n        var bin = [];\n        for(var i = 0; i < str.length * 8; i += 8)\n        {\n            bin[i>>5] |= (str.charCodeAt(i / 8) & 255) << (i%32);\n        }\n        return bin;\n    };\n\n    /*\n     * Convert an array of little-endian words to a string\n     */\n    var binl2str = function (bin) {\n        var str = \"\";\n        for(var i = 0; i < bin.length * 32; i += 8)\n        {\n            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & 255);\n        }\n        return str;\n    };\n\n    /*\n     * Convert an array of little-endian words to a hex string.\n     */\n    var binl2hex = function (binarray) {\n        var hex_tab = \"0123456789abcdef\";\n        var str = \"\";\n        for(var i = 0; i < binarray.length * 4; i++)\n        {\n            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n        }\n        return str;\n    };\n\n    /*\n     * These functions implement the four basic operations the algorithm uses.\n     */\n    var md5_cmn = function (q, a, b, x, s, t) {\n        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);\n    };\n\n    var md5_ff = function (a, b, c, d, x, s, t) {\n        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    };\n\n    var md5_gg = function (a, b, c, d, x, s, t) {\n        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    };\n\n    var md5_hh = function (a, b, c, d, x, s, t) {\n        return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n    };\n\n    var md5_ii = function (a, b, c, d, x, s, t) {\n        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n    };\n\n    /*\n     * Calculate the MD5 of an array of little-endian words, and a bit length\n     */\n    var core_md5 = function (x, len) {\n        /* append padding */\n        x[len >> 5] |= 0x80 << ((len) % 32);\n        x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n        var a =  1732584193;\n        var b = -271733879;\n        var c = -1732584194;\n        var d =  271733878;\n\n        var olda, oldb, oldc, oldd;\n        for (var i = 0; i < x.length; i += 16)\n        {\n            olda = a;\n            oldb = b;\n            oldc = c;\n            oldd = d;\n\n            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n            a = safe_add(a, olda);\n            b = safe_add(b, oldb);\n            c = safe_add(c, oldc);\n            d = safe_add(d, oldd);\n        }\n        return [a, b, c, d];\n    };\n\n    var obj = {\n        /*\n         * These are the functions you'll usually want to call.\n         * They take string arguments and return either hex or base-64 encoded\n         * strings.\n         */\n        hexdigest: function (s) {\n            return binl2hex(core_md5(str2binl(s), s.length * 8));\n        },\n\n        hash: function (s) {\n            return binl2str(core_md5(str2binl(s), s.length * 8));\n        }\n    };\n    return obj;\n}));\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-utils',[], function () {\n            return factory();\n        });\n    } else {\n        // Browser globals\n        root.stropheUtils = factory();\n    }\n}(this, function () {\n\n    var utils = {\n\n        utf16to8: function (str) {\n            var i, c;\n            var out = \"\";\n            var len = str.length;\n            for (i = 0; i < len; i++) {\n                c = str.charCodeAt(i);\n                if ((c >= 0x0000) && (c <= 0x007F)) {\n                    out += str.charAt(i);\n                } else if (c > 0x07FF) {\n                    out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                    out += String.fromCharCode(0x80 | ((c >>  6) & 0x3F));\n                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\n                } else {\n                    out += String.fromCharCode(0xC0 | ((c >>  6) & 0x1F));\n                    out += String.fromCharCode(0x80 | ((c >>  0) & 0x3F));\n                }\n            }\n            return out;\n        },\n\n        addCookies: function (cookies) {\n            /* Parameters:\n             *  (Object) cookies - either a map of cookie names\n             *    to string values or to maps of cookie values.\n             *\n             * For example:\n             * { \"myCookie\": \"1234\" }\n             *\n             * or:\n             * { \"myCookie\": {\n             *      \"value\": \"1234\",\n             *      \"domain\": \".example.org\",\n             *      \"path\": \"/\",\n             *      \"expires\": expirationDate\n             *      }\n             *  }\n             *\n             *  These values get passed to Strophe.Connection via\n             *   options.cookies\n             */\n            var cookieName, cookieObj, isObj, cookieValue, expires, domain, path;\n            for (cookieName in (cookies || {})) {\n                expires = '';\n                domain = '';\n                path = '';\n                cookieObj = cookies[cookieName];\n                isObj = typeof cookieObj === \"object\";\n                cookieValue = escape(unescape(isObj ? cookieObj.value : cookieObj));\n                if (isObj) {\n                    expires = cookieObj.expires ? \";expires=\"+cookieObj.expires : '';\n                    domain = cookieObj.domain ? \";domain=\"+cookieObj.domain : '';\n                    path = cookieObj.path ? \";path=\"+cookieObj.path : '';\n                }\n                document.cookie =\n                    cookieName+'='+cookieValue + expires + domain + path;\n            }\n        }\n    };\n    return utils;\n}));\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/*global define, document, sessionStorage, setTimeout, clearTimeout, ActiveXObject, DOMParser, btoa, atob */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-core',[\n            'strophe-sha1',\n            'strophe-md5',\n            'strophe-utils'\n        ], function () {\n            return factory.apply(this, arguments);\n        });\n    } else {\n        // Browser globals\n        var o = factory(root.SHA1, root.MD5, root.stropheUtils);\n        root.Strophe =        o.Strophe;\n        root.$build =         o.$build;\n        root.$iq =            o.$iq;\n        root.$msg =           o.$msg;\n        root.$pres =          o.$pres;\n        root.SHA1 =           o.SHA1;\n        root.MD5 =            o.MD5;\n        root.b64_hmac_sha1 =  o.SHA1.b64_hmac_sha1;\n        root.b64_sha1 =       o.SHA1.b64_sha1;\n        root.str_hmac_sha1 =  o.SHA1.str_hmac_sha1;\n        root.str_sha1 =       o.SHA1.str_sha1;\n    }\n}(this, function (SHA1, MD5, utils) {\n\nvar Strophe;\n\n/** Function: $build\n *  Create a Strophe.Builder.\n *  This is an alias for 'new Strophe.Builder(name, attrs)'.\n *\n *  Parameters:\n *    (String) name - The root element name.\n *    (Object) attrs - The attributes for the root element in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $build(name, attrs) { return new Strophe.Builder(name, attrs); }\n\n/** Function: $msg\n *  Create a Strophe.Builder with a <message/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <message/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $msg(attrs) { return new Strophe.Builder(\"message\", attrs); }\n\n/** Function: $iq\n *  Create a Strophe.Builder with an <iq/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <iq/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $iq(attrs) { return new Strophe.Builder(\"iq\", attrs); }\n\n/** Function: $pres\n *  Create a Strophe.Builder with a <presence/> element as the root.\n *\n *  Parameters:\n *    (Object) attrs - The <presence/> element attributes in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder object.\n */\nfunction $pres(attrs) { return new Strophe.Builder(\"presence\", attrs); }\n\n/** Class: Strophe\n *  An object container for all Strophe library functions.\n *\n *  This class is just a container for all the objects and constants\n *  used in the library.  It is not meant to be instantiated, but to\n *  provide a namespace for library objects, constants, and functions.\n */\nStrophe = {\n    /** Constant: VERSION */\n    VERSION: \"1.2.14\",\n\n    /** Constants: XMPP Namespace Constants\n     *  Common namespace constants from the XMPP RFCs and XEPs.\n     *\n     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.\n     *  NS.BOSH - BOSH namespace from XEP 206.\n     *  NS.CLIENT - Main XMPP client namespace.\n     *  NS.AUTH - Legacy authentication namespace.\n     *  NS.ROSTER - Roster operations namespace.\n     *  NS.PROFILE - Profile namespace.\n     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.\n     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.\n     *  NS.MUC - Multi-User Chat namespace from XEP 45.\n     *  NS.SASL - XMPP SASL namespace from RFC 3920.\n     *  NS.STREAM - XMPP Streams namespace from RFC 3920.\n     *  NS.BIND - XMPP Binding namespace from RFC 3920.\n     *  NS.SESSION - XMPP Session namespace from RFC 3920.\n     *  NS.XHTML_IM - XHTML-IM namespace from XEP 71.\n     *  NS.XHTML - XHTML body namespace from XEP 71.\n     */\n    NS: {\n        HTTPBIND: \"http://jabber.org/protocol/httpbind\",\n        BOSH: \"urn:xmpp:xbosh\",\n        CLIENT: \"jabber:client\",\n        AUTH: \"jabber:iq:auth\",\n        ROSTER: \"jabber:iq:roster\",\n        PROFILE: \"jabber:iq:profile\",\n        DISCO_INFO: \"http://jabber.org/protocol/disco#info\",\n        DISCO_ITEMS: \"http://jabber.org/protocol/disco#items\",\n        MUC: \"http://jabber.org/protocol/muc\",\n        SASL: \"urn:ietf:params:xml:ns:xmpp-sasl\",\n        STREAM: \"http://etherx.jabber.org/streams\",\n        FRAMING: \"urn:ietf:params:xml:ns:xmpp-framing\",\n        BIND: \"urn:ietf:params:xml:ns:xmpp-bind\",\n        SESSION: \"urn:ietf:params:xml:ns:xmpp-session\",\n        VERSION: \"jabber:iq:version\",\n        STANZAS: \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n        XHTML_IM: \"http://jabber.org/protocol/xhtml-im\",\n        XHTML: \"http://www.w3.org/1999/xhtml\"\n    },\n\n    /** Constants: XHTML_IM Namespace\n     *  contains allowed tags, tag attributes, and css properties.\n     *  Used in the createHtml function to filter incoming html into the allowed XHTML-IM subset.\n     *  See http://xmpp.org/extensions/xep-0071.html#profile-summary for the list of recommended\n     *  allowed tags and their attributes.\n     */\n    XHTML: {\n        tags: ['a','blockquote','br','cite','em','img','li','ol','p','span','strong','ul','body'],\n        attributes: {\n            'a':          ['href'],\n            'blockquote': ['style'],\n            'br':         [],\n            'cite':       ['style'],\n            'em':         [],\n            'img':        ['src', 'alt', 'style', 'height', 'width'],\n            'li':         ['style'],\n            'ol':         ['style'],\n            'p':          ['style'],\n            'span':       ['style'],\n            'strong':     [],\n            'ul':         ['style'],\n            'body':       []\n        },\n        css: ['background-color','color','font-family','font-size','font-style','font-weight','margin-left','margin-right','text-align','text-decoration'],\n        /** Function: XHTML.validTag\n         *\n         * Utility method to determine whether a tag is allowed\n         * in the XHTML_IM namespace.\n         *\n         * XHTML tag names are case sensitive and must be lower case.\n         */\n        validTag: function(tag) {\n            for (var i = 0; i < Strophe.XHTML.tags.length; i++) {\n                if (tag === Strophe.XHTML.tags[i]) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        /** Function: XHTML.validAttribute\n         *\n         * Utility method to determine whether an attribute is allowed\n         * as recommended per XEP-0071\n         *\n         * XHTML attribute names are case sensitive and must be lower case.\n         */\n        validAttribute: function(tag, attribute) {\n            if (typeof Strophe.XHTML.attributes[tag] !== 'undefined' && Strophe.XHTML.attributes[tag].length > 0) {\n                for (var i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                    if (attribute === Strophe.XHTML.attributes[tag][i]) {\n                        return true;\n                    }\n                }\n            }\n        return false;\n        },\n        validCSS: function(style) {\n            for (var i = 0; i < Strophe.XHTML.css.length; i++) {\n                if (style === Strophe.XHTML.css[i]) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    /** Constants: Connection Status Constants\n     *  Connection status constants for use by the connection handler\n     *  callback.\n     *\n     *  Status.ERROR - An error has occurred\n     *  Status.CONNECTING - The connection is currently being made\n     *  Status.CONNFAIL - The connection attempt failed\n     *  Status.AUTHENTICATING - The connection is authenticating\n     *  Status.AUTHFAIL - The authentication attempt failed\n     *  Status.CONNECTED - The connection has succeeded\n     *  Status.DISCONNECTED - The connection has been terminated\n     *  Status.DISCONNECTING - The connection is currently being terminated\n     *  Status.ATTACHED - The connection has been attached\n     *  Status.REDIRECT - The connection has been redirected\n     *  Status.CONNTIMEOUT - The connection has timed out\n     */\n    Status: {\n        ERROR: 0,\n        CONNECTING: 1,\n        CONNFAIL: 2,\n        AUTHENTICATING: 3,\n        AUTHFAIL: 4,\n        CONNECTED: 5,\n        DISCONNECTED: 6,\n        DISCONNECTING: 7,\n        ATTACHED: 8,\n        REDIRECT: 9,\n        CONNTIMEOUT: 10\n    },\n\n    /** Constants: Log Level Constants\n     *  Logging level indicators.\n     *\n     *  LogLevel.DEBUG - Debug output\n     *  LogLevel.INFO - Informational output\n     *  LogLevel.WARN - Warnings\n     *  LogLevel.ERROR - Errors\n     *  LogLevel.FATAL - Fatal errors\n     */\n    LogLevel: {\n        DEBUG: 0,\n        INFO: 1,\n        WARN: 2,\n        ERROR: 3,\n        FATAL: 4\n    },\n\n    /** PrivateConstants: DOM Element Type Constants\n     *  DOM element types.\n     *\n     *  ElementType.NORMAL - Normal element.\n     *  ElementType.TEXT - Text data element.\n     *  ElementType.FRAGMENT - XHTML fragment element.\n     */\n    ElementType: {\n        NORMAL: 1,\n        TEXT: 3,\n        CDATA: 4,\n        FRAGMENT: 11\n    },\n\n    /** PrivateConstants: Timeout Values\n     *  Timeout values for error states.  These values are in seconds.\n     *  These should not be changed unless you know exactly what you are\n     *  doing.\n     *\n     *  TIMEOUT - Timeout multiplier. A waiting request will be considered\n     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.\n     *      This defaults to 1.1, and with default wait, 66 seconds.\n     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where\n     *      Strophe can detect early failure, it will consider the request\n     *      failed if it doesn't return after\n     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.\n     *      This defaults to 0.1, and with default wait, 6 seconds.\n     */\n    TIMEOUT: 1.1,\n    SECONDARY_TIMEOUT: 0.1,\n\n    /** Function: addNamespace\n     *  This function is used to extend the current namespaces in\n     *  Strophe.NS.  It takes a key and a value with the key being the\n     *  name of the new namespace, with its actual value.\n     *  For example:\n     *  Strophe.addNamespace('PUBSUB', \"http://jabber.org/protocol/pubsub\");\n     *\n     *  Parameters:\n     *    (String) name - The name under which the namespace will be\n     *      referenced under Strophe.NS\n     *    (String) value - The actual namespace.\n     */\n    addNamespace: function (name, value) {\n        Strophe.NS[name] = value;\n    },\n\n    /** Function: forEachChild\n     *  Map a function over some or all child elements of a given element.\n     *\n     *  This is a small convenience function for mapping a function over\n     *  some or all of the children of an element.  If elemName is null, all\n     *  children will be passed to the function, otherwise only children\n     *  whose tag names match elemName will be passed.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The element to operate on.\n     *    (String) elemName - The child element tag name filter.\n     *    (Function) func - The function to apply to each child.  This\n     *      function should take a single argument, a DOM element.\n     */\n    forEachChild: function (elem, elemName, func) {\n        var i, childNode;\n        for (i = 0; i < elem.childNodes.length; i++) {\n            childNode = elem.childNodes[i];\n            if (childNode.nodeType === Strophe.ElementType.NORMAL &&\n                (!elemName || this.isTagEqual(childNode, elemName))) {\n                func(childNode);\n            }\n        }\n    },\n\n    /** Function: isTagEqual\n     *  Compare an element's tag name with a string.\n     *\n     *  This function is case sensitive.\n     *\n     *  Parameters:\n     *    (XMLElement) el - A DOM element.\n     *    (String) name - The element name.\n     *\n     *  Returns:\n     *    true if the element's tag name matches _el_, and false\n     *    otherwise.\n     */\n    isTagEqual: function (el, name) {\n        return el.tagName === name;\n    },\n\n    /** PrivateVariable: _xmlGenerator\n     *  _Private_ variable that caches a DOM document to\n     *  generate elements.\n     */\n    _xmlGenerator: null,\n\n    /** PrivateFunction: _makeGenerator\n     *  _Private_ function that creates a dummy XML DOM document to serve as\n     *  an element and text node generator.\n     */\n    _makeGenerator: function () {\n        var doc;\n        // IE9 does implement createDocument(); however, using it will cause the browser to leak memory on page unload.\n        // Here, we test for presence of createDocument() plus IE's proprietary documentMode attribute, which would be\n                // less than 10 in the case of IE9 and below.\n        if (document.implementation.createDocument === undefined ||\n                        document.implementation.createDocument && document.documentMode && document.documentMode < 10) {\n            doc = this._getIEXmlDom();\n            doc.appendChild(doc.createElement('strophe'));\n        } else {\n            doc = document.implementation\n                .createDocument('jabber:client', 'strophe', null);\n        }\n        return doc;\n    },\n\n    /** Function: xmlGenerator\n     *  Get the DOM document to generate elements.\n     *\n     *  Returns:\n     *    The currently used DOM document.\n     */\n    xmlGenerator: function () {\n        if (!Strophe._xmlGenerator) {\n            Strophe._xmlGenerator = Strophe._makeGenerator();\n        }\n        return Strophe._xmlGenerator;\n    },\n\n    /** PrivateFunction: _getIEXmlDom\n     *  Gets IE xml doc object\n     *\n     *  Returns:\n     *    A Microsoft XML DOM Object\n     *  See Also:\n     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx\n     */\n    _getIEXmlDom : function() {\n        var doc = null;\n        var docStrings = [\n            \"Msxml2.DOMDocument.6.0\",\n            \"Msxml2.DOMDocument.5.0\",\n            \"Msxml2.DOMDocument.4.0\",\n            \"MSXML2.DOMDocument.3.0\",\n            \"MSXML2.DOMDocument\",\n            \"MSXML.DOMDocument\",\n            \"Microsoft.XMLDOM\"\n        ];\n\n        for (var d = 0; d < docStrings.length; d++) {\n            if (doc === null) {\n                try {\n                    doc = new ActiveXObject(docStrings[d]);\n                } catch (e) {\n                    doc = null;\n                }\n            } else {\n                break;\n            }\n        }\n        return doc;\n    },\n\n    /** Function: xmlElement\n     *  Create an XML DOM element.\n     *\n     *  This function creates an XML DOM element correctly across all\n     *  implementations. Note that these are not HTML DOM elements, which\n     *  aren't appropriate for XMPP stanzas.\n     *\n     *  Parameters:\n     *    (String) name - The name for the element.\n     *    (Array|Object) attrs - An optional array or object containing\n     *      key/value pairs to use as element attributes. The object should\n     *      be in the format {'key': 'value'} or {key: 'value'}. The array\n     *      should have the format [['key1', 'value1'], ['key2', 'value2']].\n     *    (String) text - The text child data for the element.\n     *\n     *  Returns:\n     *    A new XML DOM element.\n     */\n    xmlElement: function (name) {\n        if (!name) { return null; }\n\n        var node = Strophe.xmlGenerator().createElement(name);\n        // FIXME: this should throw errors if args are the wrong type or\n        // there are more than two optional args\n        var a, i, k;\n        for (a = 1; a < arguments.length; a++) {\n            var arg = arguments[a];\n            if (!arg) { continue; }\n            if (typeof(arg) === \"string\" ||\n                typeof(arg) === \"number\") {\n                node.appendChild(Strophe.xmlTextNode(arg));\n            } else if (typeof(arg) === \"object\" &&\n                       typeof(arg.sort) === \"function\") {\n                for (i = 0; i < arg.length; i++) {\n                    var attr = arg[i];\n                    if (typeof(attr) === \"object\" &&\n                        typeof(attr.sort) === \"function\" &&\n                        attr[1] !== undefined &&\n                        attr[1] !== null) {\n                        node.setAttribute(attr[0], attr[1]);\n                    }\n                }\n            } else if (typeof(arg) === \"object\") {\n                for (k in arg) {\n                    if (arg.hasOwnProperty(k)) {\n                        if (arg[k] !== undefined &&\n                            arg[k] !== null) {\n                            node.setAttribute(k, arg[k]);\n                        }\n                    }\n                }\n            }\n        }\n\n        return node;\n    },\n\n    /*  Function: xmlescape\n     *  Excapes invalid xml characters.\n     *\n     *  Parameters:\n     *     (String) text - text to escape.\n     *\n     *  Returns:\n     *      Escaped text.\n     */\n    xmlescape: function(text) {\n        text = text.replace(/\\&/g, \"&amp;\");\n        text = text.replace(/</g,  \"&lt;\");\n        text = text.replace(/>/g,  \"&gt;\");\n        text = text.replace(/'/g,  \"&apos;\");\n        text = text.replace(/\"/g,  \"&quot;\");\n        return text;\n    },\n\n    /*  Function: xmlunescape\n    *  Unexcapes invalid xml characters.\n    *\n    *  Parameters:\n    *     (String) text - text to unescape.\n    *\n    *  Returns:\n    *      Unescaped text.\n    */\n    xmlunescape: function(text) {\n        text = text.replace(/\\&amp;/g, \"&\");\n        text = text.replace(/&lt;/g,  \"<\");\n        text = text.replace(/&gt;/g,  \">\");\n        text = text.replace(/&apos;/g,  \"'\");\n        text = text.replace(/&quot;/g,  \"\\\"\");\n        return text;\n    },\n\n    /** Function: xmlTextNode\n     *  Creates an XML DOM text node.\n     *\n     *  Provides a cross implementation version of document.createTextNode.\n     *\n     *  Parameters:\n     *    (String) text - The content of the text node.\n     *\n     *  Returns:\n     *    A new XML DOM text node.\n     */\n    xmlTextNode: function (text) {\n        return Strophe.xmlGenerator().createTextNode(text);\n    },\n\n    /** Function: xmlHtmlNode\n     *  Creates an XML DOM html node.\n     *\n     *  Parameters:\n     *    (String) html - The content of the html node.\n     *\n     *  Returns:\n     *    A new XML DOM text node.\n     */\n    xmlHtmlNode: function (html) {\n        var node;\n        //ensure text is escaped\n        if (DOMParser) {\n            var parser = new DOMParser();\n            node = parser.parseFromString(html, \"text/xml\");\n        } else {\n            node = new ActiveXObject(\"Microsoft.XMLDOM\");\n            node.async=\"false\";\n            node.loadXML(html);\n        }\n        return node;\n    },\n\n    /** Function: getText\n     *  Get the concatenation of all text children of an element.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A String with the concatenated text of all text element children.\n     */\n    getText: function (elem) {\n        if (!elem) { return null; }\n\n        var str = \"\";\n        if (elem.childNodes.length === 0 && elem.nodeType === Strophe.ElementType.TEXT) {\n            str += elem.nodeValue;\n        }\n\n        for (var i = 0; i < elem.childNodes.length; i++) {\n            if (elem.childNodes[i].nodeType === Strophe.ElementType.TEXT) {\n                str += elem.childNodes[i].nodeValue;\n            }\n        }\n\n        return Strophe.xmlescape(str);\n    },\n\n    /** Function: copyElement\n     *  Copy an XML DOM element.\n     *\n     *  This function copies a DOM element and all its descendants and returns\n     *  the new copy.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A new, copied DOM element tree.\n     */\n    copyElement: function (elem) {\n        var i, el;\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\n            el = Strophe.xmlElement(elem.tagName);\n\n            for (i = 0; i < elem.attributes.length; i++) {\n                el.setAttribute(elem.attributes[i].nodeName,\n                                elem.attributes[i].value);\n            }\n\n            for (i = 0; i < elem.childNodes.length; i++) {\n                el.appendChild(Strophe.copyElement(elem.childNodes[i]));\n            }\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);\n        }\n        return el;\n    },\n\n\n    /** Function: createHtml\n     *  Copy an HTML DOM element into an XML DOM.\n     *\n     *  This function copies a DOM element and all its descendants and returns\n     *  the new copy.\n     *\n     *  Parameters:\n     *    (HTMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    A new, copied DOM element tree.\n     */\n    createHtml: function (elem) {\n        var i, el, j, tag, attribute, value, css, cssAttrs, attr, cssName, cssValue;\n        if (elem.nodeType === Strophe.ElementType.NORMAL) {\n            tag = elem.nodeName.toLowerCase(); // XHTML tags must be lower case.\n            if(Strophe.XHTML.validTag(tag)) {\n                try {\n                    el = Strophe.xmlElement(tag);\n                    for(i = 0; i < Strophe.XHTML.attributes[tag].length; i++) {\n                        attribute = Strophe.XHTML.attributes[tag][i];\n                        value = elem.getAttribute(attribute);\n                        if(typeof value === 'undefined' || value === null || value === '' || value === false || value === 0) {\n                            continue;\n                        }\n                        if(attribute === 'style' && typeof value === 'object') {\n                            if(typeof value.cssText !== 'undefined') {\n                                value = value.cssText; // we're dealing with IE, need to get CSS out\n                            }\n                        }\n                        // filter out invalid css styles\n                        if(attribute === 'style') {\n                            css = [];\n                            cssAttrs = value.split(';');\n                            for(j = 0; j < cssAttrs.length; j++) {\n                                attr = cssAttrs[j].split(':');\n                                cssName = attr[0].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\").toLowerCase();\n                                if(Strophe.XHTML.validCSS(cssName)) {\n                                    cssValue = attr[1].replace(/^\\s*/, \"\").replace(/\\s*$/, \"\");\n                                    css.push(cssName + ': ' + cssValue);\n                                }\n                            }\n                            if(css.length > 0) {\n                                value = css.join('; ');\n                                el.setAttribute(attribute, value);\n                            }\n                        } else {\n                            el.setAttribute(attribute, value);\n                        }\n                    }\n\n                    for (i = 0; i < elem.childNodes.length; i++) {\n                        el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                    }\n                } catch(e) { // invalid elements\n                  el = Strophe.xmlTextNode('');\n                }\n            } else {\n                el = Strophe.xmlGenerator().createDocumentFragment();\n                for (i = 0; i < elem.childNodes.length; i++) {\n                    el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n                }\n            }\n        } else if (elem.nodeType === Strophe.ElementType.FRAGMENT) {\n            el = Strophe.xmlGenerator().createDocumentFragment();\n            for (i = 0; i < elem.childNodes.length; i++) {\n                el.appendChild(Strophe.createHtml(elem.childNodes[i]));\n            }\n        } else if (elem.nodeType === Strophe.ElementType.TEXT) {\n            el = Strophe.xmlTextNode(elem.nodeValue);\n        }\n        return el;\n    },\n\n    /** Function: escapeNode\n     *  Escape the node part (also called local part) of a JID.\n     *\n     *  Parameters:\n     *    (String) node - A node (or local part).\n     *\n     *  Returns:\n     *    An escaped node (or local part).\n     */\n    escapeNode: function (node) {\n        if (typeof node !== \"string\") { return node; }\n        return node.replace(/^\\s+|\\s+$/g, '')\n            .replace(/\\\\/g,  \"\\\\5c\")\n            .replace(/ /g,   \"\\\\20\")\n            .replace(/\\\"/g,  \"\\\\22\")\n            .replace(/\\&/g,  \"\\\\26\")\n            .replace(/\\'/g,  \"\\\\27\")\n            .replace(/\\//g,  \"\\\\2f\")\n            .replace(/:/g,   \"\\\\3a\")\n            .replace(/</g,   \"\\\\3c\")\n            .replace(/>/g,   \"\\\\3e\")\n            .replace(/@/g,   \"\\\\40\");\n    },\n\n    /** Function: unescapeNode\n     *  Unescape a node part (also called local part) of a JID.\n     *\n     *  Parameters:\n     *    (String) node - A node (or local part).\n     *\n     *  Returns:\n     *    An unescaped node (or local part).\n     */\n    unescapeNode: function (node) {\n        if (typeof node !== \"string\") { return node; }\n        return node.replace(/\\\\20/g, \" \")\n            .replace(/\\\\22/g, '\"')\n            .replace(/\\\\26/g, \"&\")\n            .replace(/\\\\27/g, \"'\")\n            .replace(/\\\\2f/g, \"/\")\n            .replace(/\\\\3a/g, \":\")\n            .replace(/\\\\3c/g, \"<\")\n            .replace(/\\\\3e/g, \">\")\n            .replace(/\\\\40/g, \"@\")\n            .replace(/\\\\5c/g, \"\\\\\");\n    },\n\n    /** Function: getNodeFromJid\n     *  Get the node portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the node.\n     */\n    getNodeFromJid: function (jid) {\n        if (jid.indexOf(\"@\") < 0) { return null; }\n        return jid.split(\"@\")[0];\n    },\n\n    /** Function: getDomainFromJid\n     *  Get the domain portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the domain.\n     */\n    getDomainFromJid: function (jid) {\n        var bare = Strophe.getBareJidFromJid(jid);\n        if (bare.indexOf(\"@\") < 0) {\n            return bare;\n        } else {\n            var parts = bare.split(\"@\");\n            parts.splice(0, 1);\n            return parts.join('@');\n        }\n    },\n\n    /** Function: getResourceFromJid\n     *  Get the resource portion of a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the resource.\n     */\n    getResourceFromJid: function (jid) {\n        var s = jid.split(\"/\");\n        if (s.length < 2) { return null; }\n        s.splice(0, 1);\n        return s.join('/');\n    },\n\n    /** Function: getBareJidFromJid\n     *  Get the bare JID from a JID String.\n     *\n     *  Parameters:\n     *    (String) jid - A JID.\n     *\n     *  Returns:\n     *    A String containing the bare JID.\n     */\n    getBareJidFromJid: function (jid) {\n        return jid ? jid.split(\"/\")[0] : null;\n    },\n\n    /** PrivateFunction: _handleError\n     *  _Private_ function that properly logs an error to the console\n     */\n    _handleError: function (e) {\n        if (typeof e.stack !== \"undefined\") {\n            Strophe.fatal(e.stack);\n        }\n        if (e.sourceURL) {\n            Strophe.fatal(\"error: \" + this.handler + \" \" + e.sourceURL + \":\" +\n                          e.line + \" - \" + e.name + \": \" + e.message);\n        } else if (e.fileName) {\n            Strophe.fatal(\"error: \" + this.handler + \" \" +\n                          e.fileName + \":\" + e.lineNumber + \" - \" +\n                          e.name + \": \" + e.message);\n        } else {\n            Strophe.fatal(\"error: \" + e.message);\n        }\n    },\n\n    /** Function: log\n     *  User overrideable logging function.\n     *\n     *  This function is called whenever the Strophe library calls any\n     *  of the logging functions.  The default implementation of this\n     *  function does nothing.  If client code wishes to handle the logging\n     *  messages, it should override this with\n     *  > Strophe.log = function (level, msg) {\n     *  >   (user code here)\n     *  > };\n     *\n     *  Please note that data sent and received over the wire is logged\n     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().\n     *\n     *  The different levels and their meanings are\n     *\n     *    DEBUG - Messages useful for debugging purposes.\n     *    INFO - Informational messages.  This is mostly information like\n     *      'disconnect was called' or 'SASL auth succeeded'.\n     *    WARN - Warnings about potential problems.  This is mostly used\n     *      to report transient connection errors like request timeouts.\n     *    ERROR - Some error occurred.\n     *    FATAL - A non-recoverable fatal error occurred.\n     *\n     *  Parameters:\n     *    (Integer) level - The log level of the log message.  This will\n     *      be one of the values in Strophe.LogLevel.\n     *    (String) msg - The log message.\n     */\n    /* jshint ignore:start */\n    log: function (level, msg) {\n        return;\n    },\n    /* jshint ignore:end */\n\n    /** Function: debug\n     *  Log a message at the Strophe.LogLevel.DEBUG level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    debug: function(msg) {\n        this.log(this.LogLevel.DEBUG, msg);\n    },\n\n    /** Function: info\n     *  Log a message at the Strophe.LogLevel.INFO level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    info: function (msg) {\n        this.log(this.LogLevel.INFO, msg);\n    },\n\n    /** Function: warn\n     *  Log a message at the Strophe.LogLevel.WARN level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    warn: function (msg) {\n        this.log(this.LogLevel.WARN, msg);\n    },\n\n    /** Function: error\n     *  Log a message at the Strophe.LogLevel.ERROR level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    error: function (msg) {\n        this.log(this.LogLevel.ERROR, msg);\n    },\n\n    /** Function: fatal\n     *  Log a message at the Strophe.LogLevel.FATAL level.\n     *\n     *  Parameters:\n     *    (String) msg - The log message.\n     */\n    fatal: function (msg) {\n        this.log(this.LogLevel.FATAL, msg);\n    },\n\n    /** Function: serialize\n     *  Render a DOM element and all descendants to a String.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    The serialized element tree as a String.\n     */\n    serialize: function (elem) {\n        var result;\n\n        if (!elem) { return null; }\n\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n\n        var nodeName = elem.nodeName;\n        var i, child;\n\n        if (elem.getAttribute(\"_realname\")) {\n            nodeName = elem.getAttribute(\"_realname\");\n        }\n\n        result = \"<\" + nodeName;\n        for (i = 0; i < elem.attributes.length; i++) {\n             if(elem.attributes[i].nodeName !== \"_realname\") {\n               result += \" \" + elem.attributes[i].nodeName +\n                   \"='\" + Strophe.xmlescape(elem.attributes[i].value) + \"'\";\n             }\n        }\n\n        if (elem.childNodes.length > 0) {\n            result += \">\";\n            for (i = 0; i < elem.childNodes.length; i++) {\n                child = elem.childNodes[i];\n                switch( child.nodeType ){\n                  case Strophe.ElementType.NORMAL:\n                    // normal element, so recurse\n                    result += Strophe.serialize(child);\n                    break;\n                  case Strophe.ElementType.TEXT:\n                    // text element to escape values\n                    result += Strophe.xmlescape(child.nodeValue);\n                    break;\n                  case Strophe.ElementType.CDATA:\n                    // cdata section so don't escape values\n                    result += \"<![CDATA[\"+child.nodeValue+\"]]>\";\n                }\n            }\n            result += \"</\" + nodeName + \">\";\n        } else {\n            result += \"/>\";\n        }\n\n        return result;\n    },\n\n    /** PrivateVariable: _requestId\n     *  _Private_ variable that keeps track of the request ids for\n     *  connections.\n     */\n    _requestId: 0,\n\n    /** PrivateVariable: Strophe.connectionPlugins\n     *  _Private_ variable Used to store plugin names that need\n     *  initialization on Strophe.Connection construction.\n     */\n    _connectionPlugins: {},\n\n    /** Function: addConnectionPlugin\n     *  Extends the Strophe.Connection object with the given plugin.\n     *\n     *  Parameters:\n     *    (String) name - The name of the extension.\n     *    (Object) ptype - The plugin's prototype.\n     */\n    addConnectionPlugin: function (name, ptype) {\n        Strophe._connectionPlugins[name] = ptype;\n    }\n};\n\n/** Class: Strophe.Builder\n *  XML DOM builder.\n *\n *  This object provides an interface similar to JQuery but for building\n *  DOM elements easily and rapidly.  All the functions except for toString()\n *  and tree() return the object, so calls can be chained.  Here's an\n *  example using the $iq() builder helper.\n *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})\n *  >     .c('query', {xmlns: 'strophe:example'})\n *  >     .c('example')\n *  >     .toString()\n *\n *  The above generates this XML fragment\n *  > <iq to='you' from='me' type='get' id='1'>\n *  >   <query xmlns='strophe:example'>\n *  >     <example/>\n *  >   </query>\n *  > </iq>\n *  The corresponding DOM manipulations to get a similar fragment would be\n *  a lot more tedious and probably involve several helper variables.\n *\n *  Since adding children makes new operations operate on the child, up()\n *  is provided to traverse up the tree.  To add two children, do\n *  > builder.c('child1', ...).up().c('child2', ...)\n *  The next operation on the Builder will be relative to the second child.\n */\n\n/** Constructor: Strophe.Builder\n *  Create a Strophe.Builder object.\n *\n *  The attributes should be passed in object notation.  For example\n *  > var b = new Builder('message', {to: 'you', from: 'me'});\n *  or\n *  > var b = new Builder('messsage', {'xml:lang': 'en'});\n *\n *  Parameters:\n *    (String) name - The name of the root element.\n *    (Object) attrs - The attributes for the root element in object notation.\n *\n *  Returns:\n *    A new Strophe.Builder.\n */\nStrophe.Builder = function (name, attrs) {\n    // Set correct namespace for jabber:client elements\n    if (name === \"presence\" || name === \"message\" || name === \"iq\") {\n        if (attrs && !attrs.xmlns) {\n            attrs.xmlns = Strophe.NS.CLIENT;\n        } else if (!attrs) {\n            attrs = {xmlns: Strophe.NS.CLIENT};\n        }\n    }\n\n    // Holds the tree being built.\n    this.nodeTree = Strophe.xmlElement(name, attrs);\n\n    // Points to the current operation node.\n    this.node = this.nodeTree;\n};\n\nStrophe.Builder.prototype = {\n    /** Function: tree\n     *  Return the DOM tree.\n     *\n     *  This function returns the current DOM tree as an element object.  This\n     *  is suitable for passing to functions like Strophe.Connection.send().\n     *\n     *  Returns:\n     *    The DOM tree as a element object.\n     */\n    tree: function () {\n        return this.nodeTree;\n    },\n\n    /** Function: toString\n     *  Serialize the DOM tree to a String.\n     *\n     *  This function returns a string serialization of the current DOM\n     *  tree.  It is often used internally to pass data to a\n     *  Strophe.Request object.\n     *\n     *  Returns:\n     *    The serialized DOM tree in a String.\n     */\n    toString: function () {\n        return Strophe.serialize(this.nodeTree);\n    },\n\n    /** Function: up\n     *  Make the current parent element the new current element.\n     *\n     *  This function is often used after c() to traverse back up the tree.\n     *  For example, to add two children to the same element\n     *  > builder.c('child1', {}).up().c('child2', {});\n     *\n     *  Returns:\n     *    The Stophe.Builder object.\n     */\n    up: function () {\n        this.node = this.node.parentNode;\n        return this;\n    },\n\n    /** Function: root\n     *  Make the root element the new current element.\n     *\n     *  When at a deeply nested element in the tree, this function can be used\n     *  to jump back to the root of the tree, instead of having to repeatedly\n     *  call up().\n     *\n     *  Returns:\n     *    The Stophe.Builder object.\n     */\n    root: function () {\n        this.node = this.nodeTree;\n        return this;\n    },\n\n    /** Function: attrs\n     *  Add or modify attributes of the current element.\n     *\n     *  The attributes should be passed in object notation.  This function\n     *  does not move the current element pointer.\n     *\n     *  Parameters:\n     *    (Object) moreattrs - The attributes to add/modify in object notation.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    attrs: function (moreattrs) {\n        for (var k in moreattrs) {\n            if (moreattrs.hasOwnProperty(k)) {\n                if (moreattrs[k] === undefined) {\n                    this.node.removeAttribute(k);\n                } else {\n                    this.node.setAttribute(k, moreattrs[k]);\n                }\n            }\n        }\n        return this;\n    },\n\n    /** Function: c\n     *  Add a child to the current element and make it the new current\n     *  element.\n     *\n     *  This function moves the current element pointer to the child,\n     *  unless text is provided.  If you need to add another child, it\n     *  is necessary to use up() to go back to the parent in the tree.\n     *\n     *  Parameters:\n     *    (String) name - The name of the child.\n     *    (Object) attrs - The attributes of the child in object notation.\n     *    (String) text - The text to add to the child.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    c: function (name, attrs, text) {\n        var child = Strophe.xmlElement(name, attrs, text);\n        this.node.appendChild(child);\n        if (typeof text !== \"string\" && typeof text !==\"number\") {\n            this.node = child;\n        }\n        return this;\n    },\n\n    /** Function: cnode\n     *  Add a child to the current element and make it the new current\n     *  element.\n     *\n     *  This function is the same as c() except that instead of using a\n     *  name and an attributes object to create the child it uses an\n     *  existing DOM element object.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - A DOM element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    cnode: function (elem) {\n        var impNode;\n        var xmlGen = Strophe.xmlGenerator();\n        try {\n            impNode = (xmlGen.importNode !== undefined);\n        } catch (e) {\n            impNode = false;\n        }\n        var newElem = impNode ?\n                      xmlGen.importNode(elem, true) :\n                      Strophe.copyElement(elem);\n        this.node.appendChild(newElem);\n        this.node = newElem;\n        return this;\n    },\n\n    /** Function: t\n     *  Add a child text element.\n     *\n     *  This *does not* make the child the new current element since there\n     *  are no children of text elements.\n     *\n     *  Parameters:\n     *    (String) text - The text data to append to the current element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    t: function (text) {\n        var child = Strophe.xmlTextNode(text);\n        this.node.appendChild(child);\n        return this;\n    },\n\n    /** Function: h\n     *  Replace current element contents with the HTML passed in.\n     *\n     *  This *does not* make the child the new current element\n     *\n     *  Parameters:\n     *    (String) html - The html to insert as contents of current element.\n     *\n     *  Returns:\n     *    The Strophe.Builder object.\n     */\n    h: function (html) {\n        var fragment = document.createElement('body');\n\n        // force the browser to try and fix any invalid HTML tags\n        fragment.innerHTML = html;\n\n        // copy cleaned html into an xml dom\n        var xhtml = Strophe.createHtml(fragment);\n\n        while(xhtml.childNodes.length > 0) {\n            this.node.appendChild(xhtml.childNodes[0]);\n        }\n        return this;\n    }\n};\n\n/** PrivateClass: Strophe.Handler\n *  _Private_ helper class for managing stanza handlers.\n *\n *  A Strophe.Handler encapsulates a user provided callback function to be\n *  executed when matching stanzas are received by the connection.\n *  Handlers can be either one-off or persistant depending on their\n *  return value. Returning true will cause a Handler to remain active, and\n *  returning false will remove the Handler.\n *\n *  Users will not use Strophe.Handler objects directly, but instead they\n *  will use Strophe.Connection.addHandler() and\n *  Strophe.Connection.deleteHandler().\n */\n\n/** PrivateConstructor: Strophe.Handler\n *  Create and initialize a new Strophe.Handler.\n *\n *  Parameters:\n *    (Function) handler - A function to be executed when the handler is run.\n *    (String) ns - The namespace to match.\n *    (String) name - The element name to match.\n *    (String) type - The element type to match.\n *    (String) id - The element id attribute to match.\n *    (String) from - The element from attribute to match.\n *    (Object) options - Handler options\n *\n *  Returns:\n *    A new Strophe.Handler object.\n */\nStrophe.Handler = function (handler, ns, name, type, id, from, options) {\n    this.handler = handler;\n    this.ns = ns;\n    this.name = name;\n    this.type = type;\n    this.id = id;\n    this.options = options || {'matchBareFromJid': false, 'ignoreNamespaceFragment': false};\n    // BBB: Maintain backward compatibility with old `matchBare` option\n    if (this.options.matchBare) {\n        Strophe.warn('The \"matchBare\" option is deprecated, use \"matchBareFromJid\" instead.');\n        this.options.matchBareFromJid = this.options.matchBare;\n        delete this.options.matchBare;\n    }\n\n    if (this.options.matchBareFromJid) {\n        this.from = from ? Strophe.getBareJidFromJid(from) : null;\n    } else {\n        this.from = from;\n    }\n    // whether the handler is a user handler or a system handler\n    this.user = true;\n};\n\nStrophe.Handler.prototype = {\n    /** PrivateFunction: getNamespace\n     *  Returns the XML namespace attribute on an element.\n     *  If `ignoreNamespaceFragment` was passed in for this handler, then the\n     *  URL fragment will be stripped.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element with the namespace.\n     *\n     *  Returns:\n     *    The namespace, with optionally the fragment stripped.\n     */\n    getNamespace: function (elem) {\n        var elNamespace = elem.getAttribute(\"xmlns\");\n        if (elNamespace && this.options.ignoreNamespaceFragment) {\n            elNamespace = elNamespace.split('#')[0];\n        }\n        return elNamespace;\n    },\n\n    /** PrivateFunction: namespaceMatch\n     *  Tests if a stanza matches the namespace set for this Strophe.Handler.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element to test.\n     *\n     *  Returns:\n     *    true if the stanza matches and false otherwise.\n     */\n    namespaceMatch: function (elem) {\n        var nsMatch = false;\n        if (!this.ns) {\n            return true;\n        } else {\n            var that = this;\n            Strophe.forEachChild(elem, null, function (elem) {\n                if (that.getNamespace(elem) === that.ns) {\n                    nsMatch = true;\n                }\n            });\n            nsMatch = nsMatch || this.getNamespace(elem) === this.ns;\n        }\n        return nsMatch;\n    },\n\n    /** PrivateFunction: isMatch\n     *  Tests if a stanza matches the Strophe.Handler.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML element to test.\n     *\n     *  Returns:\n     *    true if the stanza matches and false otherwise.\n     */\n    isMatch: function (elem) {\n        var from = elem.getAttribute('from');\n        if (this.options.matchBareFromJid) {\n            from = Strophe.getBareJidFromJid(from);\n        }\n        var elem_type = elem.getAttribute(\"type\");\n        if (this.namespaceMatch(elem) &&\n            (!this.name || Strophe.isTagEqual(elem, this.name)) &&\n            (!this.type || (Array.isArray(this.type) ? this.type.indexOf(elem_type) !== -1 : elem_type === this.type)) &&\n            (!this.id || elem.getAttribute(\"id\") === this.id) &&\n            (!this.from || from === this.from)) {\n                return true;\n        }\n        return false;\n    },\n\n    /** PrivateFunction: run\n     *  Run the callback on a matching stanza.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The DOM element that triggered the\n     *      Strophe.Handler.\n     *\n     *  Returns:\n     *    A boolean indicating if the handler should remain active.\n     */\n    run: function (elem) {\n        var result = null;\n        try {\n            result = this.handler(elem);\n        } catch (e) {\n            Strophe._handleError(e);\n            throw e;\n        }\n        return result;\n    },\n\n    /** PrivateFunction: toString\n     *  Get a String representation of the Strophe.Handler object.\n     *\n     *  Returns:\n     *    A String.\n     */\n    toString: function () {\n        return \"{Handler: \" + this.handler + \"(\" + this.name + \",\" +\n            this.id + \",\" + this.ns + \")}\";\n    }\n};\n\n/** PrivateClass: Strophe.TimedHandler\n *  _Private_ helper class for managing timed handlers.\n *\n *  A Strophe.TimedHandler encapsulates a user provided callback that\n *  should be called after a certain period of time or at regular\n *  intervals.  The return value of the callback determines whether the\n *  Strophe.TimedHandler will continue to fire.\n *\n *  Users will not use Strophe.TimedHandler objects directly, but instead\n *  they will use Strophe.Connection.addTimedHandler() and\n *  Strophe.Connection.deleteTimedHandler().\n */\n\n/** PrivateConstructor: Strophe.TimedHandler\n *  Create and initialize a new Strophe.TimedHandler object.\n *\n *  Parameters:\n *    (Integer) period - The number of milliseconds to wait before the\n *      handler is called.\n *    (Function) handler - The callback to run when the handler fires.  This\n *      function should take no arguments.\n *\n *  Returns:\n *    A new Strophe.TimedHandler object.\n */\nStrophe.TimedHandler = function (period, handler) {\n    this.period = period;\n    this.handler = handler;\n    this.lastCalled = new Date().getTime();\n    this.user = true;\n};\n\nStrophe.TimedHandler.prototype = {\n    /** PrivateFunction: run\n     *  Run the callback for the Strophe.TimedHandler.\n     *\n     *  Returns:\n     *    true if the Strophe.TimedHandler should be called again, and false\n     *      otherwise.\n     */\n    run: function () {\n        this.lastCalled = new Date().getTime();\n        return this.handler();\n    },\n\n    /** PrivateFunction: reset\n     *  Reset the last called time for the Strophe.TimedHandler.\n     */\n    reset: function () {\n        this.lastCalled = new Date().getTime();\n    },\n\n    /** PrivateFunction: toString\n     *  Get a string representation of the Strophe.TimedHandler object.\n     *\n     *  Returns:\n     *    The string representation.\n     */\n    toString: function () {\n        return \"{TimedHandler: \" + this.handler + \"(\" + this.period +\")}\";\n    }\n};\n\n/** Class: Strophe.Connection\n *  XMPP Connection manager.\n *\n *  This class is the main part of Strophe.  It manages a BOSH or websocket\n *  connection to an XMPP server and dispatches events to the user callbacks\n *  as data arrives. It supports SASL PLAIN, SASL DIGEST-MD5, SASL SCRAM-SHA1\n *  and legacy authentication.\n *\n *  After creating a Strophe.Connection object, the user will typically\n *  call connect() with a user supplied callback to handle connection level\n *  events like authentication failure, disconnection, or connection\n *  complete.\n *\n *  The user will also have several event handlers defined by using\n *  addHandler() and addTimedHandler().  These will allow the user code to\n *  respond to interesting stanzas or do something periodically with the\n *  connection. These handlers will be active once authentication is\n *  finished.\n *\n *  To send data to the connection, use send().\n */\n\n/** Constructor: Strophe.Connection\n *  Create and initialize a Strophe.Connection object.\n *\n *  The transport-protocol for this connection will be chosen automatically\n *  based on the given service parameter. URLs starting with \"ws://\" or\n *  \"wss://\" will use WebSockets, URLs starting with \"http://\", \"https://\"\n *  or without a protocol will use BOSH.\n *\n *  To make Strophe connect to the current host you can leave out the protocol\n *  and host part and just pass the path, e.g.\n *\n *  > var conn = new Strophe.Connection(\"/http-bind/\");\n *\n *  Options common to both Websocket and BOSH:\n *  ------------------------------------------\n *\n *  cookies:\n *\n *  The *cookies* option allows you to pass in cookies to be added to the\n *  document. These cookies will then be included in the BOSH XMLHttpRequest\n *  or in the websocket connection.\n *\n *  The passed in value must be a map of cookie names and string values.\n *\n *  > { \"myCookie\": {\n *  >     \"value\": \"1234\",\n *  >     \"domain\": \".example.org\",\n *  >     \"path\": \"/\",\n *  >     \"expires\": expirationDate\n *  >     }\n *  > }\n *\n *  Note that cookies can't be set in this way for other domains (i.e. cross-domain).\n *  Those cookies need to be set under those domains, for example they can be\n *  set server-side by making a XHR call to that domain to ask it to set any\n *  necessary cookies.\n *\n *  mechanisms:\n *\n *  The *mechanisms* option allows you to specify the SASL mechanisms that this\n *  instance of Strophe.Connection (and therefore your XMPP client) will\n *  support.\n *\n *  The value must be an array of objects with Strophe.SASLMechanism\n *  prototypes.\n *\n *  If nothing is specified, then the following mechanisms (and their\n *  priorities) are registered:\n *\n *      OAUTHBEARER - 60\n *      SCRAM-SHA1 - 50\n *      DIGEST-MD5 - 40\n *      PLAIN - 30\n *      ANONYMOUS - 20\n *      EXTERNAL - 10\n *\n *  WebSocket options:\n *  ------------------\n *\n *  If you want to connect to the current host with a WebSocket connection you\n *  can tell Strophe to use WebSockets through a \"protocol\" attribute in the\n *  optional options parameter. Valid values are \"ws\" for WebSocket and \"wss\"\n *  for Secure WebSocket.\n *  So to connect to \"wss://CURRENT_HOSTNAME/xmpp-websocket\" you would call\n *\n *  > var conn = new Strophe.Connection(\"/xmpp-websocket/\", {protocol: \"wss\"});\n *\n *  Note that relative URLs _NOT_ starting with a \"/\" will also include the path\n *  of the current site.\n *\n *  Also because downgrading security is not permitted by browsers, when using\n *  relative URLs both BOSH and WebSocket connections will use their secure\n *  variants if the current connection to the site is also secure (https).\n *\n *  BOSH options:\n *  -------------\n *\n *  By adding \"sync\" to the options, you can control if requests will\n *  be made synchronously or not. The default behaviour is asynchronous.\n *  If you want to make requests synchronous, make \"sync\" evaluate to true.\n *  > var conn = new Strophe.Connection(\"/http-bind/\", {sync: true});\n *\n *  You can also toggle this on an already established connection.\n *  > conn.options.sync = true;\n *\n *  The *customHeaders* option can be used to provide custom HTTP headers to be\n *  included in the XMLHttpRequests made.\n *\n *  The *keepalive* option can be used to instruct Strophe to maintain the\n *  current BOSH session across interruptions such as webpage reloads.\n *\n *  It will do this by caching the sessions tokens in sessionStorage, and when\n *  \"restore\" is called it will check whether there are cached tokens with\n *  which it can resume an existing session.\n *\n *  The *withCredentials* option should receive a Boolean value and is used to\n *  indicate wether cookies should be included in ajax requests (by default\n *  they're not).\n *  Set this value to true if you are connecting to a BOSH service\n *  and for some reason need to send cookies to it.\n *  In order for this to work cross-domain, the server must also enable\n *  credentials by setting the Access-Control-Allow-Credentials response header\n *  to \"true\". For most usecases however this setting should be false (which\n *  is the default).\n *  Additionally, when using Access-Control-Allow-Credentials, the\n *  Access-Control-Allow-Origin header can't be set to the wildcard \"*\", but\n *  instead must be restricted to actual domains.\n *\n *  The *contentType* option can be set to change the default Content-Type\n *  of \"text/xml; charset=utf-8\", which can be useful to reduce the amount of\n *  CORS preflight requests that are sent to the server.\n *\n *  Parameters:\n *    (String) service - The BOSH or WebSocket service URL.\n *    (Object) options - A hash of configuration options\n *\n *  Returns:\n *    A new Strophe.Connection object.\n */\nStrophe.Connection = function (service, options) {\n    // The service URL\n    this.service = service;\n    // Configuration options\n    this.options = options || {};\n    var proto = this.options.protocol || \"\";\n\n    // Select protocal based on service or options\n    if (service.indexOf(\"ws:\") === 0 || service.indexOf(\"wss:\") === 0 ||\n            proto.indexOf(\"ws\") === 0) {\n        this._proto = new Strophe.Websocket(this);\n    } else {\n        this._proto = new Strophe.Bosh(this);\n    }\n\n    /* The connected JID. */\n    this.jid = \"\";\n    /* the JIDs domain */\n    this.domain = null;\n    /* stream:features */\n    this.features = null;\n\n    // SASL\n    this._sasl_data = {};\n    this.do_session = false;\n    this.do_bind = false;\n\n    // handler lists\n    this.timedHandlers = [];\n    this.handlers = [];\n    this.removeTimeds = [];\n    this.removeHandlers = [];\n    this.addTimeds = [];\n    this.addHandlers = [];\n    this.protocolErrorHandlers = {\n        'HTTP': {},\n        'websocket': {}\n    };\n\n    this._idleTimeout = null;\n    this._disconnectTimeout = null;\n\n    this.authenticated = false;\n    this.connected = false;\n    this.disconnecting = false;\n    this.do_authentication = true;\n    this.paused = false;\n    this.restored = false;\n\n    this._data = [];\n    this._uniqueId = 0;\n\n    this._sasl_success_handler = null;\n    this._sasl_failure_handler = null;\n    this._sasl_challenge_handler = null;\n\n    // Max retries before disconnecting\n    this.maxRetries = 5;\n\n    // Call onIdle callback every 1/10th of a second\n    // XXX: setTimeout should be called only with function expressions (23974bc1)\n    this._idleTimeout = setTimeout(function() {\n        this._onIdle();\n    }.bind(this), 100);\n\n    utils.addCookies(this.options.cookies);\n    this.registerSASLMechanisms(this.options.mechanisms);\n\n    // initialize plugins\n    for (var k in Strophe._connectionPlugins) {\n        if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n            var ptype = Strophe._connectionPlugins[k];\n            // jslint complaints about the below line, but this is fine\n            var F = function () {}; // jshint ignore:line\n            F.prototype = ptype;\n            this[k] = new F();\n            this[k].init(this);\n        }\n    }\n};\n\nStrophe.Connection.prototype = {\n    /** Function: reset\n     *  Reset the connection.\n     *\n     *  This function should be called after a connection is disconnected\n     *  before that connection is reused.\n     */\n    reset: function () {\n        this._proto._reset();\n\n        // SASL\n        this.do_session = false;\n        this.do_bind = false;\n\n        // handler lists\n        this.timedHandlers = [];\n        this.handlers = [];\n        this.removeTimeds = [];\n        this.removeHandlers = [];\n        this.addTimeds = [];\n        this.addHandlers = [];\n\n        this.authenticated = false;\n        this.connected = false;\n        this.disconnecting = false;\n        this.restored = false;\n\n        this._data = [];\n        this._requests = [];\n        this._uniqueId = 0;\n    },\n\n    /** Function: pause\n     *  Pause the request manager.\n     *\n     *  This will prevent Strophe from sending any more requests to the\n     *  server.  This is very useful for temporarily pausing\n     *  BOSH-Connections while a lot of send() calls are happening quickly.\n     *  This causes Strophe to send the data in a single request, saving\n     *  many request trips.\n     */\n    pause: function () {\n        this.paused = true;\n    },\n\n    /** Function: resume\n     *  Resume the request manager.\n     *\n     *  This resumes after pause() has been called.\n     */\n    resume: function () {\n        this.paused = false;\n    },\n\n    /** Function: getUniqueId\n     *  Generate a unique ID for use in <iq/> elements.\n     *\n     *  All <iq/> stanzas are required to have unique id attributes.  This\n     *  function makes creating these easy.  Each connection instance has\n     *  a counter which starts from zero, and the value of this counter\n     *  plus a colon followed by the suffix becomes the unique id. If no\n     *  suffix is supplied, the counter is used as the unique id.\n     *\n     *  Suffixes are used to make debugging easier when reading the stream\n     *  data, and their use is recommended.  The counter resets to 0 for\n     *  every new connection for the same reason.  For connections to the\n     *  same server that authenticate the same way, all the ids should be\n     *  the same, which makes it easy to see changes.  This is useful for\n     *  automated testing as well.\n     *\n     *  Parameters:\n     *    (String) suffix - A optional suffix to append to the id.\n     *\n     *  Returns:\n     *    A unique string to be used for the id attribute.\n     */\n    getUniqueId: function(suffix) {\n        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random() * 16 | 0,\n                v = c === 'x' ? r : r & 0x3 | 0x8;\n            return v.toString(16);\n        });\n        if (typeof(suffix) === \"string\" || typeof(suffix) === \"number\") {\n            return uuid + \":\" + suffix;\n        } else {\n            return uuid + \"\";\n        }\n    },\n\n    /** Function: addProtocolErrorHandler\n     *  Register a handler function for when a protocol (websocker or HTTP)\n     *  error occurs.\n     *\n     *  NOTE: Currently only HTTP errors for BOSH requests are handled.\n     *  Patches that handle websocket errors would be very welcome.\n     *\n     *  Parameters:\n     *    (String) protocol - 'HTTP' or 'websocket'\n     *    (Integer) status_code - Error status code (e.g 500, 400 or 404)\n     *    (Function) callback - Function that will fire on Http error\n     *\n     *  Example:\n     *  function onError(err_code){\n     *    //do stuff\n     *  }\n     *\n     *  var conn = Strophe.connect('http://example.com/http-bind');\n     *  conn.addProtocolErrorHandler('HTTP', 500, onError);\n     *  // Triggers HTTP 500 error and onError handler will be called\n     *  conn.connect('user_jid@incorrect_jabber_host', 'secret', onConnect);\n     */\n    addProtocolErrorHandler: function(protocol, status_code, callback){\n        this.protocolErrorHandlers[protocol][status_code] = callback;\n    },\n\n\n    /** Function: connect\n     *  Starts the connection process.\n     *\n     *  As the connection process proceeds, the user supplied callback will\n     *  be triggered multiple times with status updates.  The callback\n     *  should take two arguments - the status code and the error condition.\n     *\n     *  The status code will be one of the values in the Strophe.Status\n     *  constants.  The error condition will be one of the conditions\n     *  defined in RFC 3920 or the condition 'strophe-parsererror'.\n     *\n     *  The Parameters _wait_, _hold_ and _route_ are optional and only relevant\n     *  for BOSH connections. Please see XEP 124 for a more detailed explanation\n     *  of the optional parameters.\n     *\n     *  Parameters:\n     *    (String) jid - The user's JID.  This may be a bare JID,\n     *      or a full JID.  If a node is not supplied, SASL OAUTHBEARER or\n     *      SASL ANONYMOUS authentication will be attempted (OAUTHBEARER will\n     *      process the provided password value as an access token).\n     *    (String) pass - The user's password.\n     *    (Function) callback - The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (String) route - The optional route value.\n     *    (String) authcid - The optional alternative authentication identity\n     *      (username) if intending to impersonate another user.\n     *      When using the SASL-EXTERNAL authentication mechanism, for example\n     *      with client certificates, then the authcid value is used to\n     *      determine whether an authorization JID (authzid) should be sent to\n     *      the server. The authzid should not be sent to the server if the\n     *      authzid and authcid are the same. So to prevent it from being sent\n     *      (for example when the JID is already contained in the client\n     *      certificate), set authcid to that same JID. See XEP-178 for more\n     *      details.\n     */\n    connect: function (jid, pass, callback, wait, hold, route, authcid) {\n        this.jid = jid;\n        /** Variable: authzid\n         *  Authorization identity.\n         */\n        this.authzid = Strophe.getBareJidFromJid(this.jid);\n\n        /** Variable: authcid\n         *  Authentication identity (User name).\n         */\n        this.authcid = authcid || Strophe.getNodeFromJid(this.jid);\n\n        /** Variable: pass\n         *  Authentication identity (User password).\n         */\n        this.pass = pass;\n\n        /** Variable: servtype\n         *  Digest MD5 compatibility.\n         */\n        this.servtype = \"xmpp\";\n\n        this.connect_callback = callback;\n        this.disconnecting = false;\n        this.connected = false;\n        this.authenticated = false;\n        this.restored = false;\n\n        // parse jid for domain\n        this.domain = Strophe.getDomainFromJid(this.jid);\n\n        this._changeConnectStatus(Strophe.Status.CONNECTING, null);\n\n        this._proto._connect(wait, hold, route);\n    },\n\n    /** Function: attach\n     *  Attach to an already created and authenticated BOSH session.\n     *\n     *  This function is provided to allow Strophe to attach to BOSH\n     *  sessions which have been created externally, perhaps by a Web\n     *  application.  This is often used to support auto-login type features\n     *  without putting user credentials into the page.\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *    (String) sid - The SID of the BOSH session.\n     *    (String) rid - The current RID of the BOSH session.  This RID\n     *      will be used by the next request.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    attach: function (jid, sid, rid, callback, wait, hold, wind) {\n        if (this._proto instanceof Strophe.Bosh) {\n            this._proto._attach(jid, sid, rid, callback, wait, hold, wind);\n        } else {\n            throw {\n                name: 'StropheSessionError',\n                message: 'The \"attach\" method can only be used with a BOSH connection.'\n            };\n        }\n    },\n\n    /** Function: restore\n     *  Attempt to restore a cached BOSH session.\n     *\n     *  This function is only useful in conjunction with providing the\n     *  \"keepalive\":true option when instantiating a new Strophe.Connection.\n     *\n     *  When \"keepalive\" is set to true, Strophe will cache the BOSH tokens\n     *  RID (Request ID) and SID (Session ID) and then when this function is\n     *  called, it will attempt to restore the session from those cached\n     *  tokens.\n     *\n     *  This function must therefore be called instead of connect or attach.\n     *\n     *  For an example on how to use it, please see examples/restore.js\n     *\n     *  Parameters:\n     *    (String) jid - The user's JID.  This may be a bare JID or a full JID.\n     *    (Function) callback - The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    restore: function (jid, callback, wait, hold, wind) {\n        if (this._sessionCachingSupported()) {\n            this._proto._restore(jid, callback, wait, hold, wind);\n        } else {\n            throw {\n                name: 'StropheSessionError',\n                message: 'The \"restore\" method can only be used with a BOSH connection.'\n            };\n        }\n    },\n\n    /** PrivateFunction: _sessionCachingSupported\n     * Checks whether sessionStorage and JSON are supported and whether we're\n     * using BOSH.\n     */\n    _sessionCachingSupported: function () {\n        if (this._proto instanceof Strophe.Bosh) {\n            if (!JSON) { return false; }\n            try {\n                sessionStorage.setItem('_strophe_', '_strophe_');\n                sessionStorage.removeItem('_strophe_');\n            } catch (e) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    },\n\n    /** Function: xmlInput\n     *  User overrideable function that receives XML data coming into the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.xmlInput = function (elem) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XML data received by the connection.\n     */\n    /* jshint unused:false */\n    xmlInput: function (elem) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: xmlOutput\n     *  User overrideable function that receives XML data sent to the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.xmlOutput = function (elem) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Due to limitations of current Browsers' XML-Parsers the opening and closing\n     *  <stream> tag for WebSocket-Connoctions will be passed as selfclosing here.\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag. See\n     *  <Strophe.Bosh.strip> if you want to strip this tag.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The XMLdata sent by the connection.\n     */\n    /* jshint unused:false */\n    xmlOutput: function (elem) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: rawInput\n     *  User overrideable function that receives raw data coming into the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.rawInput = function (data) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (String) data - The data received by the connection.\n     */\n    /* jshint unused:false */\n    rawInput: function (data) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: rawOutput\n     *  User overrideable function that receives raw data sent to the\n     *  connection.\n     *\n     *  The default function does nothing.  User code can override this with\n     *  > Strophe.Connection.rawOutput = function (data) {\n     *  >   (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (String) data - The data sent by the connection.\n     */\n    /* jshint unused:false */\n    rawOutput: function (data) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: nextValidRid\n     *  User overrideable function that receives the new valid rid.\n     *\n     *  The default function does nothing. User code can override this with\n     *  > Strophe.Connection.nextValidRid = function (rid) {\n     *  >    (user code)\n     *  > };\n     *\n     *  Parameters:\n     *    (Number) rid - The next valid rid\n     */\n    /* jshint unused:false */\n    nextValidRid: function (rid) {\n        return;\n    },\n    /* jshint unused:true */\n\n    /** Function: send\n     *  Send a stanza.\n     *\n     *  This function is called to push data onto the send queue to\n     *  go out over the wire.  Whenever a request is sent to the BOSH\n     *  server, all pending data is sent and the queue is flushed.\n     *\n     *  Parameters:\n     *    (XMLElement |\n     *     [XMLElement] |\n     *     Strophe.Builder) elem - The stanza to send.\n     */\n    send: function (elem) {\n        if (elem === null) { return ; }\n        if (typeof(elem.sort) === \"function\") {\n            for (var i = 0; i < elem.length; i++) {\n                this._queueData(elem[i]);\n            }\n        } else if (typeof(elem.tree) === \"function\") {\n            this._queueData(elem.tree());\n        } else {\n            this._queueData(elem);\n        }\n\n        this._proto._send();\n    },\n\n    /** Function: flush\n     *  Immediately send any pending outgoing data.\n     *\n     *  Normally send() queues outgoing data until the next idle period\n     *  (100ms), which optimizes network use in the common cases when\n     *  several send()s are called in succession. flush() can be used to\n     *  immediately send all pending data.\n     */\n    flush: function () {\n        // cancel the pending idle period and run the idle function\n        // immediately\n        clearTimeout(this._idleTimeout);\n        this._onIdle();\n    },\n\n    /** Function: sendPresence\n     *  Helper function to send presence stanzas. The main benefit is for\n     *  sending presence stanzas for which you expect a responding presence\n     *  stanza with the same id (for example when leaving a chat room).\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza to send.\n     *    (Function) callback - The callback function for a successful request.\n     *    (Function) errback - The callback function for a failed or timed\n     *      out request.  On timeout, the stanza will be null.\n     *    (Integer) timeout - The time specified in milliseconds for a\n     *      timeout to occur.\n     *\n     *  Returns:\n     *    The id used to send the presence.\n     */\n    sendPresence: function(elem, callback, errback, timeout) {\n        var timeoutHandler = null;\n        var that = this;\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        var id = elem.getAttribute('id');\n        if (!id) { // inject id if not found\n            id = this.getUniqueId(\"sendPresence\");\n            elem.setAttribute(\"id\", id);\n        }\n\n        if (typeof callback === \"function\" || typeof errback === \"function\") {\n            var handler = this.addHandler(function (stanza) {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                    that.deleteTimedHandler(timeoutHandler);\n                }\n                var type = stanza.getAttribute('type');\n                if (type === 'error') {\n                    if (errback) {\n                        errback(stanza);\n                    }\n                } else if (callback) {\n                    callback(stanza);\n                }\n            }, null, 'presence', null, id);\n\n            // if timeout specified, set up a timeout handler.\n            if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, function () {\n                    // get rid of normal handler\n                    that.deleteHandler(handler);\n                    // call errback on timeout with null stanza\n                    if (errback) {\n                        errback(null);\n                    }\n                    return false;\n                });\n            }\n        }\n        this.send(elem);\n        return id;\n    },\n\n    /** Function: sendIQ\n     *  Helper function to send IQ stanzas.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza to send.\n     *    (Function) callback - The callback function for a successful request.\n     *    (Function) errback - The callback function for a failed or timed\n     *      out request.  On timeout, the stanza will be null.\n     *    (Integer) timeout - The time specified in milliseconds for a\n     *      timeout to occur.\n     *\n     *  Returns:\n     *    The id used to send the IQ.\n    */\n    sendIQ: function(elem, callback, errback, timeout) {\n        var timeoutHandler = null;\n        var that = this;\n        if (typeof(elem.tree) === \"function\") {\n            elem = elem.tree();\n        }\n        var id = elem.getAttribute('id');\n        if (!id) { // inject id if not found\n            id = this.getUniqueId(\"sendIQ\");\n            elem.setAttribute(\"id\", id);\n        }\n\n        if (typeof callback === \"function\" || typeof errback === \"function\") {\n            var handler = this.addHandler(function (stanza) {\n                // remove timeout handler if there is one\n                if (timeoutHandler) {\n                    that.deleteTimedHandler(timeoutHandler);\n                }\n                var iqtype = stanza.getAttribute('type');\n                if (iqtype === 'result') {\n                    if (callback) {\n                        callback(stanza);\n                    }\n                } else if (iqtype === 'error') {\n                    if (errback) {\n                        errback(stanza);\n                    }\n                } else {\n                    throw {\n                        name: \"StropheError\",\n                        message: \"Got bad IQ type of \" + iqtype\n                    };\n                }\n            }, null, 'iq', ['error', 'result'], id);\n\n            // if timeout specified, set up a timeout handler.\n            if (timeout) {\n                timeoutHandler = this.addTimedHandler(timeout, function () {\n                    // get rid of normal handler\n                    that.deleteHandler(handler);\n                    // call errback on timeout with null stanza\n                    if (errback) {\n                        errback(null);\n                    }\n                    return false;\n                });\n            }\n        }\n        this.send(elem);\n        return id;\n    },\n\n    /** PrivateFunction: _queueData\n     *  Queue outgoing data for later sending.  Also ensures that the data\n     *  is a DOMElement.\n     */\n    _queueData: function (element) {\n        if (element === null ||\n            !element.tagName ||\n            !element.childNodes) {\n            throw {\n                name: \"StropheError\",\n                message: \"Cannot queue non-DOMElement.\"\n            };\n        }\n        this._data.push(element);\n    },\n\n    /** PrivateFunction: _sendRestart\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        this._data.push(\"restart\");\n        this._proto._sendRestart();\n        // XXX: setTimeout should be called only with function expressions (23974bc1)\n        this._idleTimeout = setTimeout(function() {\n            this._onIdle();\n        }.bind(this), 100);\n    },\n\n    /** Function: addTimedHandler\n     *  Add a timed handler to the connection.\n     *\n     *  This function adds a timed handler.  The provided handler will\n     *  be called every period milliseconds until it returns false,\n     *  the connection is terminated, or the handler is removed.  Handlers\n     *  that wish to continue being invoked should return true.\n     *\n     *  Because of method binding it is necessary to save the result of\n     *  this function if you wish to remove a handler with\n     *  deleteTimedHandler().\n     *\n     *  Note that user handlers are not active until authentication is\n     *  successful.\n     *\n     *  Parameters:\n     *    (Integer) period - The period of the handler.\n     *    (Function) handler - The callback function.\n     *\n     *  Returns:\n     *    A reference to the handler that can be used to remove it.\n     */\n    addTimedHandler: function (period, handler) {\n        var thand = new Strophe.TimedHandler(period, handler);\n        this.addTimeds.push(thand);\n        return thand;\n    },\n\n    /** Function: deleteTimedHandler\n     *  Delete a timed handler for a connection.\n     *\n     *  This function removes a timed handler from the connection.  The\n     *  handRef parameter is *not* the function passed to addTimedHandler(),\n     *  but is the reference returned from addTimedHandler().\n     *\n     *  Parameters:\n     *    (Strophe.TimedHandler) handRef - The handler reference.\n     */\n    deleteTimedHandler: function (handRef) {\n        // this must be done in the Idle loop so that we don't change\n        // the handlers during iteration\n        this.removeTimeds.push(handRef);\n    },\n\n    /** Function: addHandler\n     *  Add a stanza handler for the connection.\n     *\n     *  This function adds a stanza handler to the connection.  The\n     *  handler callback will be called for any stanza that matches\n     *  the parameters.  Note that if multiple parameters are supplied,\n     *  they must all match for the handler to be invoked.\n     *\n     *  The handler will receive the stanza that triggered it as its argument.\n     *  *The handler should return true if it is to be invoked again;\n     *  returning false will remove the handler after it returns.*\n     *\n     *  As a convenience, the ns parameters applies to the top level element\n     *  and also any of its immediate children.  This is primarily to make\n     *  matching /iq/query elements easy.\n     *\n     *  Options\n     *  ~~~~~~~\n     *  With the options argument, you can specify boolean flags that affect how\n     *  matches are being done.\n     *\n     *  Currently two flags exist:\n     *\n     *  - matchBareFromJid:\n     *      When set to true, the from parameter and the\n     *      from attribute on the stanza will be matched as bare JIDs instead\n     *      of full JIDs. To use this, pass {matchBareFromJid: true} as the\n     *      value of options. The default value for matchBareFromJid is false.\n     *\n     *  - ignoreNamespaceFragment:\n     *      When set to true, a fragment specified on the stanza's namespace\n     *      URL will be ignored when it's matched with the one configured for\n     *      the handler.\n     *\n     *      This means that if you register like this:\n     *      >   connection.addHandler(\n     *      >       handler,\n     *      >       'http://jabber.org/protocol/muc',\n     *      >       null, null, null, null,\n     *      >       {'ignoreNamespaceFragment': true}\n     *      >   );\n     *\n     *      Then a stanza with XML namespace of\n     *      'http://jabber.org/protocol/muc#user' will also be matched. If\n     *      'ignoreNamespaceFragment' is false, then only stanzas with\n     *      'http://jabber.org/protocol/muc' will be matched.\n     *\n     *  Deleting the handler\n     *  ~~~~~~~~~~~~~~~~~~~~\n     *  The return value should be saved if you wish to remove the handler\n     *  with deleteHandler().\n     *\n     *  Parameters:\n     *    (Function) handler - The user callback.\n     *    (String) ns - The namespace to match.\n     *    (String) name - The stanza name to match.\n     *    (String|Array) type - The stanza type (or types if an array) to match.\n     *    (String) id - The stanza id attribute to match.\n     *    (String) from - The stanza from attribute to match.\n     *    (String) options - The handler options\n     *\n     *  Returns:\n     *    A reference to the handler that can be used to remove it.\n     */\n    addHandler: function (handler, ns, name, type, id, from, options) {\n        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);\n        this.addHandlers.push(hand);\n        return hand;\n    },\n\n    /** Function: deleteHandler\n     *  Delete a stanza handler for a connection.\n     *\n     *  This function removes a stanza handler from the connection.  The\n     *  handRef parameter is *not* the function passed to addHandler(),\n     *  but is the reference returned from addHandler().\n     *\n     *  Parameters:\n     *    (Strophe.Handler) handRef - The handler reference.\n     */\n    deleteHandler: function (handRef) {\n        // this must be done in the Idle loop so that we don't change\n        // the handlers during iteration\n        this.removeHandlers.push(handRef);\n        // If a handler is being deleted while it is being added,\n        // prevent it from getting added\n        var i = this.addHandlers.indexOf(handRef);\n        if (i >= 0) {\n            this.addHandlers.splice(i, 1);\n        }\n    },\n\n    /** Function: registerSASLMechanisms\n     *\n     * Register the SASL mechanisms which will be supported by this instance of\n     * Strophe.Connection (i.e. which this XMPP client will support).\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of objects with Strophe.SASLMechanism prototypes\n     *\n     */\n    registerSASLMechanisms: function (mechanisms) {\n        this.mechanisms = {};\n        mechanisms = mechanisms || [\n            Strophe.SASLAnonymous,\n            Strophe.SASLExternal,\n            Strophe.SASLMD5,\n            Strophe.SASLOAuthBearer,\n            Strophe.SASLPlain,\n            Strophe.SASLSHA1\n        ];\n        mechanisms.forEach(this.registerSASLMechanism.bind(this));\n    },\n\n    /** Function: registerSASLMechanism\n     *\n     * Register a single SASL mechanism, to be supported by this client.\n     *\n     *  Parameters:\n     *    (Object) mechanism - Object with a Strophe.SASLMechanism prototype\n     *\n     */\n    registerSASLMechanism: function (mechanism) {\n        this.mechanisms[mechanism.prototype.name] = mechanism;\n    },\n\n    /** Function: disconnect\n     *  Start the graceful disconnection process.\n     *\n     *  This function starts the disconnection process.  This process starts\n     *  by sending unavailable presence and sending BOSH body of type\n     *  terminate.  A timeout handler makes sure that disconnection happens\n     *  even if the BOSH server does not respond.\n     *  If the Connection object isn't connected, at least tries to abort all pending requests\n     *  so the connection object won't generate successful requests (which were already opened).\n     *\n     *  The user supplied connection callback will be notified of the\n     *  progress as this process happens.\n     *\n     *  Parameters:\n     *    (String) reason - The reason the disconnect is occuring.\n     */\n    disconnect: function (reason) {\n        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);\n\n        Strophe.info(\"Disconnect was called because: \" + reason);\n        if (this.connected) {\n            var pres = false;\n            this.disconnecting = true;\n            if (this.authenticated) {\n                pres = $pres({\n                    xmlns: Strophe.NS.CLIENT,\n                    type: 'unavailable'\n                });\n            }\n            // setup timeout handler\n            this._disconnectTimeout = this._addSysTimedHandler(\n                3000, this._onDisconnectTimeout.bind(this));\n            this._proto._disconnect(pres);\n        } else {\n            Strophe.info(\"Disconnect was called before Strophe connected to the server\");\n            this._proto._abortAllRequests();\n            this._doDisconnect();\n        }\n    },\n\n    /** PrivateFunction: _changeConnectStatus\n     *  _Private_ helper function that makes sure plugins and the user's\n     *  callback are notified of connection status changes.\n     *\n     *  Parameters:\n     *    (Integer) status - the new connection status, one of the values\n     *      in Strophe.Status\n     *    (String) condition - the error condition or null\n     */\n    _changeConnectStatus: function (status, condition) {\n        // notify all plugins listening for status changes\n        for (var k in Strophe._connectionPlugins) {\n            if (Strophe._connectionPlugins.hasOwnProperty(k)) {\n                var plugin = this[k];\n                if (plugin.statusChanged) {\n                    try {\n                        plugin.statusChanged(status, condition);\n                    } catch (err) {\n                        Strophe.error(\"\" + k + \" plugin caused an exception \" +\n                                      \"changing status: \" + err);\n                    }\n                }\n            }\n        }\n\n        // notify the user's callback\n        if (this.connect_callback) {\n            try {\n                this.connect_callback(status, condition);\n            } catch (e) {\n                Strophe._handleError(e);\n                Strophe.error(\n                    \"User connection callback caused an \"+\"exception: \"+e);\n            }\n        }\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  This is the last piece of the disconnection logic.  This resets the\n     *  connection and alerts the user's connection callback.\n     */\n    _doDisconnect: function (condition) {\n        if (typeof this._idleTimeout === \"number\") {\n            clearTimeout(this._idleTimeout);\n        }\n\n        // Cancel Disconnect Timeout\n        if (this._disconnectTimeout !== null) {\n            this.deleteTimedHandler(this._disconnectTimeout);\n            this._disconnectTimeout = null;\n        }\n\n        Strophe.info(\"_doDisconnect was called\");\n        this._proto._doDisconnect();\n\n        this.authenticated = false;\n        this.disconnecting = false;\n        this.restored = false;\n\n        // delete handlers\n        this.handlers = [];\n        this.timedHandlers = [];\n        this.removeTimeds = [];\n        this.removeHandlers = [];\n        this.addTimeds = [];\n        this.addHandlers = [];\n\n        // tell the parent we disconnected\n        this._changeConnectStatus(Strophe.Status.DISCONNECTED, condition);\n        this.connected = false;\n    },\n\n    /** PrivateFunction: _dataRecv\n     *  _Private_ handler to processes incoming data from the the connection.\n     *\n     *  Except for _connect_cb handling the initial connection request,\n     *  this function handles the incoming data for all requests.  This\n     *  function also fires stanza handlers that match each incoming\n     *  stanza.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request that has data ready.\n     *    (string) req - The stanza a raw string (optiona).\n     */\n    _dataRecv: function (req, raw) {\n        Strophe.info(\"_dataRecv called\");\n        var elem = this._proto._reqToData(req);\n        if (elem === null) { return; }\n\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n            if (elem.nodeName === this._proto.strip && elem.childNodes.length) {\n                this.xmlInput(elem.childNodes[0]);\n            } else {\n                this.xmlInput(elem);\n            }\n        }\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n            if (raw) {\n                this.rawInput(raw);\n            } else {\n                this.rawInput(Strophe.serialize(elem));\n            }\n        }\n\n        // remove handlers scheduled for deletion\n        var i, hand;\n        while (this.removeHandlers.length > 0) {\n            hand = this.removeHandlers.pop();\n            i = this.handlers.indexOf(hand);\n            if (i >= 0) {\n                this.handlers.splice(i, 1);\n            }\n        }\n\n        // add handlers scheduled for addition\n        while (this.addHandlers.length > 0) {\n            this.handlers.push(this.addHandlers.pop());\n        }\n\n        // handle graceful disconnect\n        if (this.disconnecting && this._proto._emptyQueue()) {\n            this._doDisconnect();\n            return;\n        }\n\n        var type = elem.getAttribute(\"type\");\n        var cond, conflict;\n        if (type !== null && type === \"terminate\") {\n            // Don't process stanzas that come in after disconnect\n            if (this.disconnecting) {\n                return;\n            }\n\n            // an error occurred\n            cond = elem.getAttribute(\"condition\");\n            conflict = elem.getElementsByTagName(\"conflict\");\n            if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                    cond = \"conflict\";\n                }\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n            } else {\n                this._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n            }\n            this._doDisconnect(cond);\n            return;\n        }\n\n        // send each incoming stanza through the handler chain\n        var that = this;\n        Strophe.forEachChild(elem, null, function (child) {\n            var i, newList;\n            // process handlers\n            newList = that.handlers;\n            that.handlers = [];\n            for (i = 0; i < newList.length; i++) {\n                var hand = newList[i];\n                // encapsulate 'handler.run' not to lose the whole handler list if\n                // one of the handlers throws an exception\n                try {\n                    if (hand.isMatch(child) &&\n                        (that.authenticated || !hand.user)) {\n                        if (hand.run(child)) {\n                            that.handlers.push(hand);\n                        }\n                    } else {\n                        that.handlers.push(hand);\n                    }\n                } catch(e) {\n                    // if the handler throws an exception, we consider it as false\n                    Strophe.warn('Removing Strophe handlers due to uncaught exception: '+e.message);\n                }\n            }\n        });\n    },\n\n\n    /** Attribute: mechanisms\n     *  SASL Mechanisms available for Connection.\n     */\n    mechanisms: {},\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ handler for initial connection request.\n     *\n     *  This handler is used to process the initial connection request\n     *  response from the BOSH server. It is used to set up authentication\n     *  handlers and start the authentication process.\n     *\n     *  SASL authentication will be attempted if available, otherwise\n     *  the code will fall back to legacy authentication.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The current request.\n     *    (Function) _callback - low level (xmpp) connect callback function.\n     *      Useful for plugins with their own xmpp connect callback (when their)\n     *      want to do something special).\n     */\n    _connect_cb: function (req, _callback, raw) {\n        Strophe.info(\"_connect_cb was called\");\n        this.connected = true;\n\n        var bodyWrap;\n        try {\n            bodyWrap = this._proto._reqToData(req);\n        } catch (e) {\n            if (e !== \"badformat\") { throw e; }\n            this._changeConnectStatus(Strophe.Status.CONNFAIL, 'bad-format');\n            this._doDisconnect('bad-format');\n        }\n        if (!bodyWrap) { return; }\n\n        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {\n            if (bodyWrap.nodeName === this._proto.strip && bodyWrap.childNodes.length) {\n                this.xmlInput(bodyWrap.childNodes[0]);\n            } else {\n                this.xmlInput(bodyWrap);\n            }\n        }\n        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {\n            if (raw) {\n                this.rawInput(raw);\n            } else {\n                this.rawInput(Strophe.serialize(bodyWrap));\n            }\n        }\n\n        var conncheck = this._proto._connect_cb(bodyWrap);\n        if (conncheck === Strophe.Status.CONNFAIL) {\n            return;\n        }\n\n        // Check for the stream:features tag\n        var hasFeatures;\n        if (bodyWrap.getElementsByTagNameNS) {\n            hasFeatures = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"features\").length > 0;\n        } else {\n            hasFeatures = bodyWrap.getElementsByTagName(\"stream:features\").length > 0 ||\n                            bodyWrap.getElementsByTagName(\"features\").length > 0;\n        }\n        if (!hasFeatures) {\n            this._proto._no_auth_received(_callback);\n            return;\n        }\n\n        var matched = [], i, mech;\n        var mechanisms = bodyWrap.getElementsByTagName(\"mechanism\");\n        if (mechanisms.length > 0) {\n            for (i = 0; i < mechanisms.length; i++) {\n                mech = Strophe.getText(mechanisms[i]);\n                if (this.mechanisms[mech]) matched.push(this.mechanisms[mech]);\n            }\n        }\n        if (matched.length === 0) {\n            if (bodyWrap.getElementsByTagName(\"auth\").length === 0) {\n                // There are no matching SASL mechanisms and also no legacy\n                // auth available.\n                this._proto._no_auth_received(_callback);\n                return;\n            }\n        }\n        if (this.do_authentication !== false) {\n            this.authenticate(matched);\n        }\n    },\n\n    /** Function: sortMechanismsByPriority\n     *\n     *  Sorts an array of objects with prototype SASLMechanism according to\n     *  their priorities.\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of SASL mechanisms.\n     *\n     */\n    sortMechanismsByPriority: function (mechanisms) {\n        // Sorting mechanisms according to priority.\n        var i, j, higher, swap;\n        for (i = 0; i < mechanisms.length - 1; ++i) {\n            higher = i;\n            for (j = i + 1; j < mechanisms.length; ++j) {\n                if (mechanisms[j].prototype.priority > mechanisms[higher].prototype.priority) {\n                    higher = j;\n                }\n            }\n            if (higher !== i) {\n                swap = mechanisms[i];\n                mechanisms[i] = mechanisms[higher];\n                mechanisms[higher] = swap;\n            }\n        }\n        return mechanisms;\n    },\n\n    /** PrivateFunction: _attemptSASLAuth\n     *\n     *  Iterate through an array of SASL mechanisms and attempt authentication\n     *  with the highest priority (enabled) mechanism.\n     *\n     *  Parameters:\n     *    (Array) mechanisms - Array of SASL mechanisms.\n     *\n     *  Returns:\n     *    (Boolean) mechanism_found - true or false, depending on whether a\n     *          valid SASL mechanism was found with which authentication could be\n     *          started.\n     */\n    _attemptSASLAuth: function (mechanisms) {\n        mechanisms = this.sortMechanismsByPriority(mechanisms || []);\n        var i = 0, mechanism_found = false;\n        for (i = 0; i < mechanisms.length; ++i) {\n            if (!mechanisms[i].prototype.test(this)) {\n                continue;\n            }\n            this._sasl_success_handler = this._addSysHandler(\n                this._sasl_success_cb.bind(this), null,\n                \"success\", null, null);\n            this._sasl_failure_handler = this._addSysHandler(\n                this._sasl_failure_cb.bind(this), null,\n                \"failure\", null, null);\n            this._sasl_challenge_handler = this._addSysHandler(\n                this._sasl_challenge_cb.bind(this), null,\n                \"challenge\", null, null);\n\n            this._sasl_mechanism = new mechanisms[i]();\n            this._sasl_mechanism.onStart(this);\n\n            var request_auth_exchange = $build(\"auth\", {\n                xmlns: Strophe.NS.SASL,\n                mechanism: this._sasl_mechanism.name\n            });\n            if (this._sasl_mechanism.isClientFirst) {\n                var response = this._sasl_mechanism.onChallenge(this, null);\n                request_auth_exchange.t(btoa(response));\n            }\n            this.send(request_auth_exchange.tree());\n            mechanism_found = true;\n            break;\n        }\n        return mechanism_found;\n    },\n\n    /** PrivateFunction: _attemptLegacyAuth\n     *\n     *  Attempt legacy (i.e. non-SASL) authentication.\n     *\n     */\n    _attemptLegacyAuth: function () {\n        if (Strophe.getNodeFromJid(this.jid) === null) {\n            // we don't have a node, which is required for non-anonymous\n            // client connections\n            this._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                'x-strophe-bad-non-anon-jid'\n            );\n            this.disconnect('x-strophe-bad-non-anon-jid');\n        } else {\n            // Fall back to legacy authentication\n            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);\n            this._addSysHandler(\n                this._auth1_cb.bind(this),\n                null, null, null, \"_auth_1\"\n            );\n            this.send($iq({\n                    'type': \"get\",\n                    'to': this.domain,\n                    'id': \"_auth_1\"\n                }).c(\"query\", {xmlns: Strophe.NS.AUTH})\n                .c(\"username\", {}).t(Strophe.getNodeFromJid(this.jid))\n                .tree());\n        }\n    },\n\n    /** Function: authenticate\n     * Set up authentication\n     *\n     *  Continues the initial connection request by setting up authentication\n     *  handlers and starting the authentication process.\n     *\n     *  SASL authentication will be attempted if available, otherwise\n     *  the code will fall back to legacy authentication.\n     *\n     *  Parameters:\n     *    (Array) matched - Array of SASL mechanisms supported.\n     *\n     */\n    authenticate: function (matched) {\n        if (!this._attemptSASLAuth(matched)) {\n            this._attemptLegacyAuth();\n        }\n    },\n\n    /** PrivateFunction: _sasl_challenge_cb\n     *  _Private_ handler for the SASL challenge\n     *\n     */\n    _sasl_challenge_cb: function(elem) {\n      var challenge = atob(Strophe.getText(elem));\n      var response = this._sasl_mechanism.onChallenge(this, challenge);\n      var stanza = $build('response', {\n          'xmlns': Strophe.NS.SASL\n      });\n      if (response !== \"\") {\n        stanza.t(btoa(response));\n      }\n      this.send(stanza.tree());\n      return true;\n    },\n\n    /** PrivateFunction: _auth1_cb\n     *  _Private_ handler for legacy authentication.\n     *\n     *  This handler is called in response to the initial <iq type='get'/>\n     *  for legacy authentication.  It builds an authentication <iq/> and\n     *  sends it, creating a handler (calling back to _auth2_cb()) to\n     *  handle the result\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza that triggered the callback.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    /* jshint unused:false */\n    _auth1_cb: function (elem) {\n        // build plaintext auth iq\n        var iq = $iq({type: \"set\", id: \"_auth_2\"})\n            .c('query', {xmlns: Strophe.NS.AUTH})\n            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))\n            .up()\n            .c('password').t(this.pass);\n\n        if (!Strophe.getResourceFromJid(this.jid)) {\n            // since the user has not supplied a resource, we pick\n            // a default one here.  unlike other auth methods, the server\n            // cannot do this for us.\n            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';\n        }\n        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));\n\n        this._addSysHandler(this._auth2_cb.bind(this), null,\n                            null, null, \"_auth_2\");\n        this.send(iq.tree());\n        return false;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: _sasl_success_cb\n     *  _Private_ handler for succesful SASL authentication.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_success_cb: function (elem) {\n        if (this._sasl_data[\"server-signature\"]) {\n            var serverSignature;\n            var success = atob(Strophe.getText(elem));\n            var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n            var matches = success.match(attribMatch);\n            if (matches[1] === \"v\") {\n                serverSignature = matches[2];\n            }\n\n            if (serverSignature !== this._sasl_data[\"server-signature\"]) {\n              // remove old handlers\n              this.deleteHandler(this._sasl_failure_handler);\n              this._sasl_failure_handler = null;\n              if (this._sasl_challenge_handler) {\n                this.deleteHandler(this._sasl_challenge_handler);\n                this._sasl_challenge_handler = null;\n              }\n\n              this._sasl_data = {};\n              return this._sasl_failure_cb(null);\n            }\n        }\n        Strophe.info(\"SASL authentication succeeded.\");\n\n        if (this._sasl_mechanism) {\n          this._sasl_mechanism.onSuccess();\n        }\n\n        // remove old handlers\n        this.deleteHandler(this._sasl_failure_handler);\n        this._sasl_failure_handler = null;\n        if (this._sasl_challenge_handler) {\n            this.deleteHandler(this._sasl_challenge_handler);\n            this._sasl_challenge_handler = null;\n        }\n\n        var streamfeature_handlers = [];\n        var wrapper = function(handlers, elem) {\n            while (handlers.length) {\n                this.deleteHandler(handlers.pop());\n            }\n            this._sasl_auth1_cb.bind(this)(elem);\n            return false;\n        };\n        streamfeature_handlers.push(this._addSysHandler(function(elem) {\n            wrapper.bind(this)(streamfeature_handlers, elem);\n        }.bind(this), null, \"stream:features\", null, null));\n        streamfeature_handlers.push(this._addSysHandler(function(elem) {\n            wrapper.bind(this)(streamfeature_handlers, elem);\n        }.bind(this), Strophe.NS.STREAM, \"features\", null, null));\n\n        // we must send an xmpp:restart now\n        this._sendRestart();\n\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_auth1_cb\n     *  _Private_ handler to start stream binding.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_auth1_cb: function (elem) {\n        // save stream:features for future usage\n        this.features = elem;\n        var i, child;\n        for (i = 0; i < elem.childNodes.length; i++) {\n            child = elem.childNodes[i];\n            if (child.nodeName === 'bind') {\n                this.do_bind = true;\n            }\n\n            if (child.nodeName === 'session') {\n                this.do_session = true;\n            }\n        }\n\n        if (!this.do_bind) {\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n            return false;\n        } else {\n            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,\n                                null, \"_bind_auth_2\");\n\n            var resource = Strophe.getResourceFromJid(this.jid);\n            if (resource) {\n                this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                          .c('bind', {xmlns: Strophe.NS.BIND})\n                          .c('resource', {}).t(resource).tree());\n            } else {\n                this.send($iq({type: \"set\", id: \"_bind_auth_2\"})\n                          .c('bind', {xmlns: Strophe.NS.BIND})\n                          .tree());\n            }\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_bind_cb\n     *  _Private_ handler for binding result and session start.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_bind_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"error\") {\n            Strophe.info(\"SASL binding failed.\");\n            var conflict = elem.getElementsByTagName(\"conflict\"), condition;\n            if (conflict.length > 0) {\n                condition = 'conflict';\n            }\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, condition);\n            return false;\n        }\n\n        // TODO - need to grab errors\n        var bind = elem.getElementsByTagName(\"bind\");\n        var jidNode;\n        if (bind.length > 0) {\n            // Grab jid\n            jidNode = bind[0].getElementsByTagName(\"jid\");\n            if (jidNode.length > 0) {\n                this.jid = Strophe.getText(jidNode[0]);\n\n                if (this.do_session) {\n                    this._addSysHandler(this._sasl_session_cb.bind(this),\n                                        null, null, null, \"_session_auth_2\");\n\n                    this.send($iq({type: \"set\", id: \"_session_auth_2\"})\n                                  .c('session', {xmlns: Strophe.NS.SESSION})\n                                  .tree());\n                } else {\n                    this.authenticated = true;\n                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n                }\n            }\n        } else {\n            Strophe.info(\"SASL binding failed.\");\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n            return false;\n        }\n    },\n\n    /** PrivateFunction: _sasl_session_cb\n     *  _Private_ handler to finish successful SASL connection.\n     *\n     *  This sets Connection.authenticated to true on success, which\n     *  starts the processing of user handlers.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _sasl_session_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"result\") {\n            this.authenticated = true;\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n        } else if (elem.getAttribute(\"type\") === \"error\") {\n            Strophe.info(\"Session creation failed.\");\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n            return false;\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _sasl_failure_cb\n     *  _Private_ handler for SASL authentication failure.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The matching stanza.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    /* jshint unused:false */\n    _sasl_failure_cb: function (elem) {\n        // delete unneeded handlers\n        if (this._sasl_success_handler) {\n            this.deleteHandler(this._sasl_success_handler);\n            this._sasl_success_handler = null;\n        }\n        if (this._sasl_challenge_handler) {\n            this.deleteHandler(this._sasl_challenge_handler);\n            this._sasl_challenge_handler = null;\n        }\n\n        if(this._sasl_mechanism)\n          this._sasl_mechanism.onFailure();\n        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n        return false;\n    },\n    /* jshint unused:true */\n\n    /** PrivateFunction: _auth2_cb\n     *  _Private_ handler to finish legacy authentication.\n     *\n     *  This handler is called when the result from the jabber:iq:auth\n     *  <iq/> stanza is returned.\n     *\n     *  Parameters:\n     *    (XMLElement) elem - The stanza that triggered the callback.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _auth2_cb: function (elem) {\n        if (elem.getAttribute(\"type\") === \"result\") {\n            this.authenticated = true;\n            this._changeConnectStatus(Strophe.Status.CONNECTED, null);\n        } else if (elem.getAttribute(\"type\") === \"error\") {\n            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);\n            this.disconnect('authentication failed');\n        }\n        return false;\n    },\n\n    /** PrivateFunction: _addSysTimedHandler\n     *  _Private_ function to add a system level timed handler.\n     *\n     *  This function is used to add a Strophe.TimedHandler for the\n     *  library code.  System timed handlers are allowed to run before\n     *  authentication is complete.\n     *\n     *  Parameters:\n     *    (Integer) period - The period of the handler.\n     *    (Function) handler - The callback function.\n     */\n    _addSysTimedHandler: function (period, handler) {\n        var thand = new Strophe.TimedHandler(period, handler);\n        thand.user = false;\n        this.addTimeds.push(thand);\n        return thand;\n    },\n\n    /** PrivateFunction: _addSysHandler\n     *  _Private_ function to add a system level stanza handler.\n     *\n     *  This function is used to add a Strophe.Handler for the\n     *  library code.  System stanza handlers are allowed to run before\n     *  authentication is complete.\n     *\n     *  Parameters:\n     *    (Function) handler - The callback function.\n     *    (String) ns - The namespace to match.\n     *    (String) name - The stanza name to match.\n     *    (String) type - The stanza type attribute to match.\n     *    (String) id - The stanza id attribute to match.\n     */\n    _addSysHandler: function (handler, ns, name, type, id) {\n        var hand = new Strophe.Handler(handler, ns, name, type, id);\n        hand.user = false;\n        this.addHandlers.push(hand);\n        return hand;\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  If the graceful disconnect process does not complete within the\n     *  time allotted, this handler finishes the disconnect anyway.\n     *\n     *  Returns:\n     *    false to remove the handler.\n     */\n    _onDisconnectTimeout: function () {\n        Strophe.info(\"_onDisconnectTimeout was called\");\n        this._changeConnectStatus(Strophe.Status.CONNTIMEOUT, null);\n        this._proto._onDisconnectTimeout();\n        // actually disconnect\n        this._doDisconnect();\n        return false;\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ handler to process events during idle cycle.\n     *\n     *  This handler is called every 100ms to fire timed handlers that\n     *  are ready and keep poll requests going.\n     */\n    _onIdle: function () {\n        var i, thand, since, newList;\n\n        // add timed handlers scheduled for addition\n        // NOTE: we add before remove in the case a timed handler is\n        // added and then deleted before the next _onIdle() call.\n        while (this.addTimeds.length > 0) {\n            this.timedHandlers.push(this.addTimeds.pop());\n        }\n\n        // remove timed handlers that have been scheduled for deletion\n        while (this.removeTimeds.length > 0) {\n            thand = this.removeTimeds.pop();\n            i = this.timedHandlers.indexOf(thand);\n            if (i >= 0) {\n                this.timedHandlers.splice(i, 1);\n            }\n        }\n\n        // call ready timed handlers\n        var now = new Date().getTime();\n        newList = [];\n        for (i = 0; i < this.timedHandlers.length; i++) {\n            thand = this.timedHandlers[i];\n            if (this.authenticated || !thand.user) {\n                since = thand.lastCalled + thand.period;\n                if (since - now <= 0) {\n                    if (thand.run()) {\n                        newList.push(thand);\n                    }\n                } else {\n                    newList.push(thand);\n                }\n            }\n        }\n        this.timedHandlers = newList;\n\n        clearTimeout(this._idleTimeout);\n\n        this._proto._onIdle();\n\n        // reactivate the timer only if connected\n        if (this.connected) {\n            // XXX: setTimeout should be called only with function expressions (23974bc1)\n            this._idleTimeout = setTimeout(function() {\n                this._onIdle();\n            }.bind(this), 100);\n        }\n    }\n};\n\n/** Class: Strophe.SASLMechanism\n *\n *  encapsulates SASL authentication mechanisms.\n *\n *  User code may override the priority for each mechanism or disable it completely.\n *  See <priority> for information about changing priority and <test> for informatian on\n *  how to disable a mechanism.\n *\n *  By default, all mechanisms are enabled and the priorities are\n *\n *      OAUTHBEARER - 60\n *      SCRAM-SHA1 - 50\n *      DIGEST-MD5 - 40\n *      PLAIN - 30\n *      ANONYMOUS - 20\n *      EXTERNAL - 10\n *\n *  See: Strophe.Connection.addSupportedSASLMechanisms\n */\n\n/**\n * PrivateConstructor: Strophe.SASLMechanism\n * SASL auth mechanism abstraction.\n *\n *  Parameters:\n *    (String) name - SASL Mechanism name.\n *    (Boolean) isClientFirst - If client should send response first without challenge.\n *    (Number) priority - Priority.\n *\n *  Returns:\n *    A new Strophe.SASLMechanism object.\n */\nStrophe.SASLMechanism = function(name, isClientFirst, priority) {\n  /** PrivateVariable: name\n   *  Mechanism name.\n   */\n  this.name = name;\n  /** PrivateVariable: isClientFirst\n   *  If client sends response without initial server challenge.\n   */\n  this.isClientFirst = isClientFirst;\n  /** Variable: priority\n   *  Determines which <SASLMechanism> is chosen for authentication (Higher is better).\n   *  Users may override this to prioritize mechanisms differently.\n   *\n   *  In the default configuration the priorities are\n   *\n   *  SCRAM-SHA1 - 40\n   *  DIGEST-MD5 - 30\n   *  Plain - 20\n   *\n   *  Example: (This will cause Strophe to choose the mechanism that the server sent first)\n   *\n   *  > Strophe.SASLMD5.priority = Strophe.SASLSHA1.priority;\n   *\n   *  See <SASL mechanisms> for a list of available mechanisms.\n   *\n   */\n  this.priority = priority;\n};\n\nStrophe.SASLMechanism.prototype = {\n  /**\n   *  Function: test\n   *  Checks if mechanism able to run.\n   *  To disable a mechanism, make this return false;\n   *\n   *  To disable plain authentication run\n   *  > Strophe.SASLPlain.test = function() {\n   *  >   return false;\n   *  > }\n   *\n   *  See <SASL mechanisms> for a list of available mechanisms.\n   *\n   *  Parameters:\n   *    (Strophe.Connection) connection - Target Connection.\n   *\n   *  Returns:\n   *    (Boolean) If mechanism was able to run.\n   */\n  /* jshint unused:false */\n  test: function(connection) {\n    return true;\n  },\n  /* jshint unused:true */\n\n  /** PrivateFunction: onStart\n   *  Called before starting mechanism on some connection.\n   *\n   *  Parameters:\n   *    (Strophe.Connection) connection - Target Connection.\n   */\n  onStart: function(connection) {\n    this._connection = connection;\n  },\n\n  /** PrivateFunction: onChallenge\n   *  Called by protocol implementation on incoming challenge. If client is\n   *  first (isClientFirst === true) challenge will be null on the first call.\n   *\n   *  Parameters:\n   *    (Strophe.Connection) connection - Target Connection.\n   *    (String) challenge - current challenge to handle.\n   *\n   *  Returns:\n   *    (String) Mechanism response.\n   */\n  /* jshint unused:false */\n  onChallenge: function(connection, challenge) {\n    throw new Error(\"You should implement challenge handling!\");\n  },\n  /* jshint unused:true */\n\n  /** PrivateFunction: onFailure\n   *  Protocol informs mechanism implementation about SASL failure.\n   */\n  onFailure: function() {\n    this._connection = null;\n  },\n\n  /** PrivateFunction: onSuccess\n   *  Protocol informs mechanism implementation about SASL success.\n   */\n  onSuccess: function() {\n    this._connection = null;\n  }\n};\n\n  /** Constants: SASL mechanisms\n   *  Available authentication mechanisms\n   *\n   *  Strophe.SASLAnonymous - SASL ANONYMOUS authentication.\n   *  Strophe.SASLPlain - SASL PLAIN authentication.\n   *  Strophe.SASLMD5 - SASL DIGEST-MD5 authentication\n   *  Strophe.SASLSHA1 - SASL SCRAM-SHA1 authentication\n   *  Strophe.SASLOAuthBearer - SASL OAuth Bearer authentication\n   *  Strophe.SASLExternal - SASL EXTERNAL authentication\n   */\n\n// Building SASL callbacks\n\n/** PrivateConstructor: SASLAnonymous\n *  SASL ANONYMOUS authentication.\n */\nStrophe.SASLAnonymous = function() {};\nStrophe.SASLAnonymous.prototype = new Strophe.SASLMechanism(\"ANONYMOUS\", false, 20);\n\nStrophe.SASLAnonymous.prototype.test = function(connection) {\n    return connection.authcid === null;\n};\n\n\n/** PrivateConstructor: SASLPlain\n *  SASL PLAIN authentication.\n */\nStrophe.SASLPlain = function() {};\nStrophe.SASLPlain.prototype = new Strophe.SASLMechanism(\"PLAIN\", true, 30);\n\nStrophe.SASLPlain.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\nStrophe.SASLPlain.prototype.onChallenge = function(connection) {\n    var auth_str = connection.authzid;\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.authcid;\n    auth_str = auth_str + \"\\u0000\";\n    auth_str = auth_str + connection.pass;\n    return utils.utf16to8(auth_str);\n};\n\n\n/** PrivateConstructor: SASLSHA1\n *  SASL SCRAM SHA 1 authentication.\n */\nStrophe.SASLSHA1 = function() {};\nStrophe.SASLSHA1.prototype = new Strophe.SASLMechanism(\"SCRAM-SHA-1\", true, 50);\n\nStrophe.SASLSHA1.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\nStrophe.SASLSHA1.prototype.onChallenge = function(connection, challenge, test_cnonce) {\n  var cnonce = test_cnonce || MD5.hexdigest(Math.random() * 1234567890);\n  var auth_str = \"n=\" + utils.utf16to8(connection.authcid);\n  auth_str += \",r=\";\n  auth_str += cnonce;\n  connection._sasl_data.cnonce = cnonce;\n  connection._sasl_data[\"client-first-message-bare\"] = auth_str;\n\n  auth_str = \"n,,\" + auth_str;\n\n  this.onChallenge = function (connection, challenge) {\n    var nonce, salt, iter, Hi, U, U_old, i, k, pass;\n    var clientKey, serverKey, clientSignature;\n    var responseText = \"c=biws,\";\n    var authMessage = connection._sasl_data[\"client-first-message-bare\"] + \",\" +\n      challenge + \",\";\n    var cnonce = connection._sasl_data.cnonce;\n    var attribMatch = /([a-z]+)=([^,]+)(,|$)/;\n\n    while (challenge.match(attribMatch)) {\n      var matches = challenge.match(attribMatch);\n      challenge = challenge.replace(matches[0], \"\");\n      switch (matches[1]) {\n      case \"r\":\n        nonce = matches[2];\n        break;\n      case \"s\":\n        salt = matches[2];\n        break;\n      case \"i\":\n        iter = matches[2];\n        break;\n      }\n    }\n\n    if (nonce.substr(0, cnonce.length) !== cnonce) {\n      connection._sasl_data = {};\n      return connection._sasl_failure_cb();\n    }\n\n    responseText += \"r=\" + nonce;\n    authMessage += responseText;\n\n    salt = atob(salt);\n    salt += \"\\x00\\x00\\x00\\x01\";\n\n    pass = utils.utf16to8(connection.pass);\n    Hi = U_old = SHA1.core_hmac_sha1(pass, salt);\n    for (i = 1; i < iter; i++) {\n      U = SHA1.core_hmac_sha1(pass, SHA1.binb2str(U_old));\n      for (k = 0; k < 5; k++) {\n        Hi[k] ^= U[k];\n      }\n      U_old = U;\n    }\n    Hi = SHA1.binb2str(Hi);\n\n    clientKey = SHA1.core_hmac_sha1(Hi, \"Client Key\");\n    serverKey = SHA1.str_hmac_sha1(Hi, \"Server Key\");\n    clientSignature = SHA1.core_hmac_sha1(SHA1.str_sha1(SHA1.binb2str(clientKey)), authMessage);\n    connection._sasl_data[\"server-signature\"] = SHA1.b64_hmac_sha1(serverKey, authMessage);\n\n    for (k = 0; k < 5; k++) {\n      clientKey[k] ^= clientSignature[k];\n    }\n\n    responseText += \",p=\" + btoa(SHA1.binb2str(clientKey));\n    return responseText;\n  }.bind(this);\n\n  return auth_str;\n};\n\n\n/** PrivateConstructor: SASLMD5\n *  SASL DIGEST MD5 authentication.\n */\nStrophe.SASLMD5 = function() {};\nStrophe.SASLMD5.prototype = new Strophe.SASLMechanism(\"DIGEST-MD5\", false, 40);\n\nStrophe.SASLMD5.prototype.test = function(connection) {\n    return connection.authcid !== null;\n};\n\n/** PrivateFunction: _quote\n *  _Private_ utility function to backslash escape and quote strings.\n *\n *  Parameters:\n *    (String) str - The string to be quoted.\n *\n *  Returns:\n *    quoted string\n */\nStrophe.SASLMD5.prototype._quote = function (str) {\n    return '\"' + str.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"') + '\"';\n    //\" end string workaround for emacs\n};\n\nStrophe.SASLMD5.prototype.onChallenge = function(connection, challenge, test_cnonce) {\n  var attribMatch = /([a-z]+)=(\"[^\"]+\"|[^,\"]+)(?:,|$)/;\n  var cnonce = test_cnonce || MD5.hexdigest(\"\" + (Math.random() * 1234567890));\n  var realm = \"\";\n  var host = null;\n  var nonce = \"\";\n  var qop = \"\";\n  var matches;\n\n  while (challenge.match(attribMatch)) {\n    matches = challenge.match(attribMatch);\n    challenge = challenge.replace(matches[0], \"\");\n    matches[2] = matches[2].replace(/^\"(.+)\"$/, \"$1\");\n    switch (matches[1]) {\n    case \"realm\":\n      realm = matches[2];\n      break;\n    case \"nonce\":\n      nonce = matches[2];\n      break;\n    case \"qop\":\n      qop = matches[2];\n      break;\n    case \"host\":\n      host = matches[2];\n      break;\n    }\n  }\n\n  var digest_uri = connection.servtype + \"/\" + connection.domain;\n  if (host !== null) {\n    digest_uri = digest_uri + \"/\" + host;\n  }\n\n  var cred = utils.utf16to8(connection.authcid + \":\" + realm + \":\" + this._connection.pass);\n  var A1 = MD5.hash(cred) + \":\" + nonce + \":\" + cnonce;\n  var A2 = 'AUTHENTICATE:' + digest_uri;\n\n  var responseText = \"\";\n  responseText += 'charset=utf-8,';\n  responseText += 'username=' + this._quote(utils.utf16to8(connection.authcid)) + ',';\n  responseText += 'realm=' + this._quote(realm) + ',';\n  responseText += 'nonce=' + this._quote(nonce) + ',';\n  responseText += 'nc=00000001,';\n  responseText += 'cnonce=' + this._quote(cnonce) + ',';\n  responseText += 'digest-uri=' + this._quote(digest_uri) + ',';\n  responseText += 'response=' + MD5.hexdigest(MD5.hexdigest(A1) + \":\" +\n                                              nonce + \":00000001:\" +\n                                              cnonce + \":auth:\" +\n                                              MD5.hexdigest(A2)) + \",\";\n  responseText += 'qop=auth';\n\n  this.onChallenge = function () {\n      return \"\";\n  };\n  return responseText;\n};\n\n\n/** PrivateConstructor: SASLOAuthBearer\n *  SASL OAuth Bearer authentication.\n */\nStrophe.SASLOAuthBearer = function() {};\nStrophe.SASLOAuthBearer.prototype = new Strophe.SASLMechanism(\"OAUTHBEARER\", true, 60);\n\nStrophe.SASLOAuthBearer.prototype.test = function(connection) {\n    return connection.pass !== null;\n};\n\nStrophe.SASLOAuthBearer.prototype.onChallenge = function(connection) {\n    var auth_str = 'n,';\n    if (connection.authcid !== null) {\n      auth_str = auth_str + 'a=' + connection.authzid;\n    }\n    auth_str = auth_str + ',';\n    auth_str = auth_str + \"\\u0001\";\n    auth_str = auth_str + 'auth=Bearer ';\n    auth_str = auth_str + connection.pass;\n    auth_str = auth_str + \"\\u0001\";\n    auth_str = auth_str + \"\\u0001\";\n\n    return utils.utf16to8(auth_str);\n};\n\n\n/** PrivateConstructor: SASLExternal\n *  SASL EXTERNAL authentication.\n *\n *  The EXTERNAL mechanism allows a client to request the server to use\n *  credentials established by means external to the mechanism to\n *  authenticate the client. The external means may be, for instance,\n *  TLS services.\n */\nStrophe.SASLExternal = function() {};\nStrophe.SASLExternal.prototype = new Strophe.SASLMechanism(\"EXTERNAL\", true, 10);\n\nStrophe.SASLExternal.prototype.onChallenge = function(connection) {\n    /** According to XEP-178, an authzid SHOULD NOT be presented when the\n     * authcid contained or implied in the client certificate is the JID (i.e.\n     * authzid) with which the user wants to log in as.\n     *\n     * To NOT send the authzid, the user should therefore set the authcid equal\n     * to the JID when instantiating a new Strophe.Connection object.\n     */\n    return connection.authcid === connection.authzid ? '' : connection.authzid;\n};\n\nreturn {\n    'Strophe':         Strophe,\n    '$build':          $build,\n    '$iq':             $iq,\n    '$msg':            $msg,\n    '$pres':           $pres,\n    'SHA1':            SHA1,\n    'MD5':             MD5,\n    'b64_hmac_sha1':   SHA1.b64_hmac_sha1,\n    'b64_sha1':        SHA1.b64_sha1,\n    'str_hmac_sha1':   SHA1.str_hmac_sha1,\n    'str_sha1':        SHA1.str_sha1\n};\n}));\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/* global define, window, setTimeout, clearTimeout, XMLHttpRequest, ActiveXObject, Strophe, $build */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-bosh',['strophe-core'], function (core) {\n            return factory(\n                core.Strophe,\n                core.$build\n            );\n        });\n    } else {\n        // Browser globals\n        return factory(Strophe, $build);\n    }\n}(this, function (Strophe, $build) {\n\n/** PrivateClass: Strophe.Request\n *  _Private_ helper class that provides a cross implementation abstraction\n *  for a BOSH related XMLHttpRequest.\n *\n *  The Strophe.Request class is used internally to encapsulate BOSH request\n *  information.  It is not meant to be used from user's code.\n */\n\n/** PrivateConstructor: Strophe.Request\n *  Create and initialize a new Strophe.Request object.\n *\n *  Parameters:\n *    (XMLElement) elem - The XML data to be sent in the request.\n *    (Function) func - The function that will be called when the\n *      XMLHttpRequest readyState changes.\n *    (Integer) rid - The BOSH rid attribute associated with this request.\n *    (Integer) sends - The number of times this same request has been sent.\n */\nStrophe.Request = function (elem, func, rid, sends) {\n    this.id = ++Strophe._requestId;\n    this.xmlData = elem;\n    this.data = Strophe.serialize(elem);\n    // save original function in case we need to make a new request\n    // from this one.\n    this.origFunc = func;\n    this.func = func;\n    this.rid = rid;\n    this.date = NaN;\n    this.sends = sends || 0;\n    this.abort = false;\n    this.dead = null;\n\n    this.age = function () {\n        if (!this.date) { return 0; }\n        var now = new Date();\n        return (now - this.date) / 1000;\n    };\n    this.timeDead = function () {\n        if (!this.dead) { return 0; }\n        var now = new Date();\n        return (now - this.dead) / 1000;\n    };\n    this.xhr = this._newXHR();\n};\n\nStrophe.Request.prototype = {\n    /** PrivateFunction: getResponse\n     *  Get a response from the underlying XMLHttpRequest.\n     *\n     *  This function attempts to get a response from the request and checks\n     *  for errors.\n     *\n     *  Throws:\n     *    \"parsererror\" - A parser error occured.\n     *    \"badformat\" - The entity has sent XML that cannot be processed.\n     *\n     *  Returns:\n     *    The DOM element tree of the response.\n     */\n    getResponse: function () {\n        var node = null;\n        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {\n            node = this.xhr.responseXML.documentElement;\n            if (node.tagName === \"parsererror\") {\n                Strophe.error(\"invalid response received\");\n                Strophe.error(\"responseText: \" + this.xhr.responseText);\n                Strophe.error(\"responseXML: \" +\n                              Strophe.serialize(this.xhr.responseXML));\n                throw \"parsererror\";\n            }\n        } else if (this.xhr.responseText) {\n            Strophe.error(\"invalid response received\");\n            Strophe.error(\"responseText: \" + this.xhr.responseText);\n            throw \"badformat\";\n        }\n\n        return node;\n    },\n\n    /** PrivateFunction: _newXHR\n     *  _Private_ helper function to create XMLHttpRequests.\n     *\n     *  This function creates XMLHttpRequests across all implementations.\n     *\n     *  Returns:\n     *    A new XMLHttpRequest.\n     */\n    _newXHR: function () {\n        var xhr = null;\n        if (window.XMLHttpRequest) {\n            xhr = new XMLHttpRequest();\n            if (xhr.overrideMimeType) {\n                xhr.overrideMimeType(\"text/xml; charset=utf-8\");\n            }\n        } else if (window.ActiveXObject) {\n            xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n        // use Function.bind() to prepend ourselves as an argument\n        xhr.onreadystatechange = this.func.bind(null, this);\n        return xhr;\n    }\n};\n\n/** Class: Strophe.Bosh\n *  _Private_ helper class that handles BOSH Connections\n *\n *  The Strophe.Bosh class is used internally by Strophe.Connection\n *  to encapsulate BOSH sessions. It is not meant to be used from user's code.\n */\n\n/** File: bosh.js\n *  A JavaScript library to enable BOSH in Strophejs.\n *\n *  this library uses Bidirectional-streams Over Synchronous HTTP (BOSH)\n *  to emulate a persistent, stateful, two-way connection to an XMPP server.\n *  More information on BOSH can be found in XEP 124.\n */\n\n/** PrivateConstructor: Strophe.Bosh\n *  Create and initialize a Strophe.Bosh object.\n *\n *  Parameters:\n *    (Strophe.Connection) connection - The Strophe.Connection that will use BOSH.\n *\n *  Returns:\n *    A new Strophe.Bosh object.\n */\nStrophe.Bosh = function(connection) {\n    this._conn = connection;\n    /* request id for body tags */\n    this.rid = Math.floor(Math.random() * 4294967295);\n    /* The current session ID. */\n    this.sid = null;\n\n    // default BOSH values\n    this.hold = 1;\n    this.wait = 60;\n    this.window = 5;\n    this.errors = 0;\n    this.inactivity = null;\n\n    this._requests = [];\n};\n\nStrophe.Bosh.prototype = {\n    /** Variable: strip\n     *\n     *  BOSH-Connections will have all stanzas wrapped in a <body> tag when\n     *  passed to <Strophe.Connection.xmlInput> or <Strophe.Connection.xmlOutput>.\n     *  To strip this tag, User code can set <Strophe.Bosh.strip> to \"body\":\n     *\n     *  > Strophe.Bosh.prototype.strip = \"body\";\n     *\n     *  This will enable stripping of the body tag in both\n     *  <Strophe.Connection.xmlInput> and <Strophe.Connection.xmlOutput>.\n     */\n    strip: null,\n\n    /** PrivateFunction: _buildBody\n     *  _Private_ helper function to generate the <body/> wrapper for BOSH.\n     *\n     *  Returns:\n     *    A Strophe.Builder with a <body/> element.\n     */\n    _buildBody: function () {\n        var bodyWrap = $build('body', {\n            rid: this.rid++,\n            xmlns: Strophe.NS.HTTPBIND\n        });\n        if (this.sid !== null) {\n            bodyWrap.attrs({sid: this.sid});\n        }\n        if (this._conn.options.keepalive && this._conn._sessionCachingSupported()) {\n            this._cacheSession();\n        }\n        return bodyWrap;\n    },\n\n    /** PrivateFunction: _reset\n     *  Reset the connection.\n     *\n     *  This function is called by the reset function of the Strophe Connection\n     */\n    _reset: function () {\n        this.rid = Math.floor(Math.random() * 4294967295);\n        this.sid = null;\n        this.errors = 0;\n        if (this._conn._sessionCachingSupported()) {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n\n        this._conn.nextValidRid(this.rid);\n    },\n\n    /** PrivateFunction: _connect\n     *  _Private_ function that initializes the BOSH connection.\n     *\n     *  Creates and sends the Request that initializes the BOSH connection.\n     */\n    _connect: function (wait, hold, route) {\n        this.wait = wait || this.wait;\n        this.hold = hold || this.hold;\n        this.errors = 0;\n\n        // build the body tag\n        var body = this._buildBody().attrs({\n            to: this._conn.domain,\n            \"xml:lang\": \"en\",\n            wait: this.wait,\n            hold: this.hold,\n            content: \"text/xml; charset=utf-8\",\n            ver: \"1.6\",\n            \"xmpp:version\": \"1.0\",\n            \"xmlns:xmpp\": Strophe.NS.BOSH\n        });\n\n        if(route){\n            body.attrs({\n                route: route\n            });\n        }\n\n        var _connect_cb = this._conn._connect_cb;\n\n        this._requests.push(\n            new Strophe.Request(body.tree(),\n                                this._onRequestStateChange.bind(\n                                    this, _connect_cb.bind(this._conn)),\n                                body.tree().getAttribute(\"rid\")));\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _attach\n     *  Attach to an already created and authenticated BOSH session.\n     *\n     *  This function is provided to allow Strophe to attach to BOSH\n     *  sessions which have been created externally, perhaps by a Web\n     *  application.  This is often used to support auto-login type features\n     *  without putting user credentials into the page.\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *    (String) sid - The SID of the BOSH session.\n     *    (String) rid - The current RID of the BOSH session.  This RID\n     *      will be used by the next request.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    _attach: function (jid, sid, rid, callback, wait, hold, wind) {\n        this._conn.jid = jid;\n        this.sid = sid;\n        this.rid = rid;\n\n        this._conn.connect_callback = callback;\n\n        this._conn.domain = Strophe.getDomainFromJid(this._conn.jid);\n\n        this._conn.authenticated = true;\n        this._conn.connected = true;\n\n        this.wait = wait || this.wait;\n        this.hold = hold || this.hold;\n        this.window = wind || this.window;\n\n        this._conn._changeConnectStatus(Strophe.Status.ATTACHED, null);\n    },\n\n    /** PrivateFunction: _restore\n     *  Attempt to restore a cached BOSH session\n     *\n     *  Parameters:\n     *    (String) jid - The full JID that is bound by the session.\n     *      This parameter is optional but recommended, specifically in cases\n     *      where prebinded BOSH sessions are used where it's important to know\n     *      that the right session is being restored.\n     *    (Function) callback The connect callback function.\n     *    (Integer) wait - The optional HTTPBIND wait value.  This is the\n     *      time the server will wait before returning an empty result for\n     *      a request.  The default setting of 60 seconds is recommended.\n     *      Other settings will require tweaks to the Strophe.TIMEOUT value.\n     *    (Integer) hold - The optional HTTPBIND hold value.  This is the\n     *      number of connections the server will hold at one time.  This\n     *      should almost always be set to 1 (the default).\n     *    (Integer) wind - The optional HTTBIND window value.  This is the\n     *      allowed range of request ids that are valid.  The default is 5.\n     */\n    _restore: function (jid, callback, wait, hold, wind) {\n        var session = JSON.parse(window.sessionStorage.getItem('strophe-bosh-session'));\n        if (typeof session !== \"undefined\" &&\n                   session !== null &&\n                   session.rid &&\n                   session.sid &&\n                   session.jid &&\n                   (    typeof jid === \"undefined\" ||\n                        jid === null ||\n                        Strophe.getBareJidFromJid(session.jid) === Strophe.getBareJidFromJid(jid) ||\n                        // If authcid is null, then it's an anonymous login, so\n                        // we compare only the domains:\n                        ((Strophe.getNodeFromJid(jid) === null) && (Strophe.getDomainFromJid(session.jid) === jid))\n                    )\n        ) {\n            this._conn.restored = true;\n            this._attach(session.jid, session.sid, session.rid, callback, wait, hold, wind);\n        } else {\n            throw { name: \"StropheSessionError\", message: \"_restore: no restoreable session.\" };\n        }\n    },\n\n    /** PrivateFunction: _cacheSession\n     *  _Private_ handler for the beforeunload event.\n     *\n     *  This handler is used to process the Bosh-part of the initial request.\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _cacheSession: function () {\n        if (this._conn.authenticated) {\n            if (this._conn.jid && this.rid && this.sid) {\n                window.sessionStorage.setItem('strophe-bosh-session', JSON.stringify({\n                    'jid': this._conn.jid,\n                    'rid': this.rid,\n                    'sid': this.sid\n                }));\n            }\n        } else {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n    },\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ handler for initial connection request.\n     *\n     *  This handler is used to process the Bosh-part of the initial request.\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _connect_cb: function (bodyWrap) {\n        var typ = bodyWrap.getAttribute(\"type\");\n        var cond, conflict;\n        if (typ !== null && typ === \"terminate\") {\n            // an error occurred\n            cond = bodyWrap.getAttribute(\"condition\");\n            Strophe.error(\"BOSH-Connection failed: \" + cond);\n            conflict = bodyWrap.getElementsByTagName(\"conflict\");\n            if (cond !== null) {\n                if (cond === \"remote-stream-error\" && conflict.length > 0) {\n                    cond = \"conflict\";\n                }\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, cond);\n            } else {\n                this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"unknown\");\n            }\n            this._conn._doDisconnect(cond);\n            return Strophe.Status.CONNFAIL;\n        }\n\n        // check to make sure we don't overwrite these if _connect_cb is\n        // called multiple times in the case of missing stream:features\n        if (!this.sid) {\n            this.sid = bodyWrap.getAttribute(\"sid\");\n        }\n        var wind = bodyWrap.getAttribute('requests');\n        if (wind) { this.window = parseInt(wind, 10); }\n        var hold = bodyWrap.getAttribute('hold');\n        if (hold) { this.hold = parseInt(hold, 10); }\n        var wait = bodyWrap.getAttribute('wait');\n        if (wait) { this.wait = parseInt(wait, 10); }\n        var inactivity = bodyWrap.getAttribute('inactivity');\n        if (inactivity) { this.inactivity = parseInt(inactivity, 10); }\n    },\n\n    /** PrivateFunction: _disconnect\n     *  _Private_ part of Connection.disconnect for Bosh\n     *\n     *  Parameters:\n     *    (Request) pres - This stanza will be sent before disconnecting.\n     */\n    _disconnect: function (pres) {\n        this._sendTerminate(pres);\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  Resets the SID and RID.\n     */\n    _doDisconnect: function () {\n        this.sid = null;\n        this.rid = Math.floor(Math.random() * 4294967295);\n        if (this._conn._sessionCachingSupported()) {\n            window.sessionStorage.removeItem('strophe-bosh-session');\n        }\n\n        this._conn.nextValidRid(this.rid);\n    },\n\n    /** PrivateFunction: _emptyQueue\n     * _Private_ function to check if the Request queue is empty.\n     *\n     *  Returns:\n     *    True, if there are no Requests queued, False otherwise.\n     */\n    _emptyQueue: function () {\n        return this._requests.length === 0;\n    },\n\n    /** PrivateFunction: _callProtocolErrorHandlers\n     *  _Private_ function to call error handlers registered for HTTP errors.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request that is changing readyState.\n     */\n    _callProtocolErrorHandlers: function (req) {\n        var reqStatus = this._getRequestStatus(req),\n            err_callback;\n        err_callback = this._conn.protocolErrorHandlers.HTTP[reqStatus];\n        if (err_callback) {\n            err_callback.call(this, reqStatus);\n        }\n    },\n\n    /** PrivateFunction: _hitError\n     *  _Private_ function to handle the error count.\n     *\n     *  Requests are resent automatically until their error count reaches\n     *  5.  Each time an error is encountered, this function is called to\n     *  increment the count and disconnect if the count is too high.\n     *\n     *  Parameters:\n     *    (Integer) reqStatus - The request status.\n     */\n    _hitError: function (reqStatus) {\n        this.errors++;\n        Strophe.warn(\"request errored, status: \" + reqStatus +\n                     \", number of errors: \" + this.errors);\n        if (this.errors > 4) {\n            this._conn._onDisconnectTimeout();\n        }\n    },\n\n    /** PrivateFunction: _no_auth_received\n     *\n     * Called on stream start/restart when no stream:features\n     * has been received and sends a blank poll request.\n     */\n    _no_auth_received: function (_callback) {\n        if (_callback) {\n            _callback = _callback.bind(this._conn);\n        } else {\n            _callback = this._conn._connect_cb.bind(this._conn);\n        }\n        var body = this._buildBody();\n        this._requests.push(\n                new Strophe.Request(body.tree(),\n                    this._onRequestStateChange.bind(\n                        this, _callback.bind(this._conn)),\n                    body.tree().getAttribute(\"rid\")));\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  Cancels all remaining Requests and clears the queue.\n     */\n    _onDisconnectTimeout: function () {\n        this._abortAllRequests();\n    },\n\n    /** PrivateFunction: _abortAllRequests\n     *  _Private_ helper function that makes sure all pending requests are aborted.\n     */\n    _abortAllRequests: function _abortAllRequests() {\n        var req;\n        while (this._requests.length > 0) {\n            req = this._requests.pop();\n            req.abort = true;\n            req.xhr.abort();\n            // jslint complains, but this is fine. setting to empty func\n            // is necessary for IE6\n            req.xhr.onreadystatechange = function () {}; // jshint ignore:line\n        }\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ handler called by Strophe.Connection._onIdle\n     *\n     *  Sends all queued Requests or polls with empty Request if there are none.\n     */\n    _onIdle: function () {\n        var data = this._conn._data;\n        // if no requests are in progress, poll\n        if (this._conn.authenticated && this._requests.length === 0 &&\n            data.length === 0 && !this._conn.disconnecting) {\n            Strophe.info(\"no requests during idle cycle, sending \" +\n                         \"blank request\");\n            data.push(null);\n        }\n\n        if (this._conn.paused) {\n            return;\n        }\n\n        if (this._requests.length < 2 && data.length > 0) {\n            var body = this._buildBody();\n            for (var i = 0; i < data.length; i++) {\n                if (data[i] !== null) {\n                    if (data[i] === \"restart\") {\n                        body.attrs({\n                            to: this._conn.domain,\n                            \"xml:lang\": \"en\",\n                            \"xmpp:restart\": \"true\",\n                            \"xmlns:xmpp\": Strophe.NS.BOSH\n                        });\n                    } else {\n                        body.cnode(data[i]).up();\n                    }\n                }\n            }\n            delete this._conn._data;\n            this._conn._data = [];\n            this._requests.push(\n                new Strophe.Request(body.tree(),\n                                    this._onRequestStateChange.bind(\n                                        this, this._conn._dataRecv.bind(this._conn)),\n                                    body.tree().getAttribute(\"rid\")));\n            this._throttledRequestHandler();\n        }\n\n        if (this._requests.length > 0) {\n            var time_elapsed = this._requests[0].age();\n            if (this._requests[0].dead !== null) {\n                if (this._requests[0].timeDead() >\n                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {\n                    this._throttledRequestHandler();\n                }\n            }\n\n            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {\n                Strophe.warn(\"Request \" +\n                             this._requests[0].id +\n                             \" timed out, over \" + Math.floor(Strophe.TIMEOUT * this.wait) +\n                             \" seconds since last activity\");\n                this._throttledRequestHandler();\n            }\n        }\n    },\n\n    /** PrivateFunction: _getRequestStatus\n     *\n     *  Returns the HTTP status code from a Strophe.Request\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The Strophe.Request instance.\n     *    (Integer) def - The default value that should be returned if no\n     *          status value was found.\n     */\n    _getRequestStatus: function (req, def) {\n        var reqStatus;\n        if (req.xhr.readyState === 4) {\n            try {\n                reqStatus = req.xhr.status;\n            } catch (e) {\n                // ignore errors from undefined status attribute. Works\n                // around a browser bug\n                Strophe.error(\n                    \"Caught an error while retrieving a request's status, \" +\n                    \"reqStatus: \" + reqStatus);\n            }\n        }\n        if (typeof(reqStatus) === \"undefined\") {\n            reqStatus = typeof def === 'number' ? def : 0;\n        }\n        return reqStatus;\n    },\n\n    /** PrivateFunction: _onRequestStateChange\n     *  _Private_ handler for Strophe.Request state changes.\n     *\n     *  This function is called when the XMLHttpRequest readyState changes.\n     *  It contains a lot of error handling logic for the many ways that\n     *  requests can fail, and calls the request callback when requests\n     *  succeed.\n     *\n     *  Parameters:\n     *    (Function) func - The handler for the request.\n     *    (Strophe.Request) req - The request that is changing readyState.\n     */\n    _onRequestStateChange: function (func, req) {\n        Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\n                      \" state changed to \"+req.xhr.readyState);\n        if (req.abort) {\n            req.abort = false;\n            return;\n        }\n        if (req.xhr.readyState !== 4) {\n            // The request is not yet complete\n            return;\n        }\n        var reqStatus = this._getRequestStatus(req);\n        if (this.disconnecting && reqStatus >= 400) {\n            this._hitError(reqStatus);\n            this._callProtocolErrorHandlers(req);\n            return;\n        }\n\n        var valid_request = reqStatus > 0 && reqStatus < 500;\n        var too_many_retries = req.sends > this._conn.maxRetries;\n        if (valid_request || too_many_retries) {\n            // remove from internal queue\n            this._removeRequest(req);\n            Strophe.debug(\"request id \"+req.id+\" should now be removed\");\n        }\n\n        if (reqStatus === 200) {\n            // request succeeded\n            var reqIs0 = (this._requests[0] === req);\n            var reqIs1 = (this._requests[1] === req);\n            // if request 1 finished, or request 0 finished and request\n            // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to\n            // restart the other - both will be in the first spot, as the\n            // completed request has been removed from the queue already\n            if (reqIs1 ||\n                (reqIs0 && this._requests.length > 0 &&\n                    this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {\n                this._restartRequest(0);\n            }\n            this._conn.nextValidRid(Number(req.rid) + 1);\n            Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\" got 200\");\n            func(req); // call handler\n            this.errors = 0;\n        } else if (reqStatus === 0 ||\n                   (reqStatus >= 400 && reqStatus < 600) ||\n                   reqStatus >= 12000) {\n            // request failed\n            Strophe.error(\"request id \"+req.id+\".\"+req.sends+\" error \"+reqStatus+\" happened\");\n            this._hitError(reqStatus);\n            this._callProtocolErrorHandlers(req);\n            if (reqStatus >= 400 && reqStatus < 500) {\n                this._conn._changeConnectStatus(Strophe.Status.DISCONNECTING, null);\n                this._conn._doDisconnect();\n            }\n        } else {\n            Strophe.error(\"request id \"+req.id+\".\"+req.sends+\" error \"+reqStatus+\" happened\");\n        }\n\n        if (!valid_request && !too_many_retries) {\n            this._throttledRequestHandler();\n        } else if (too_many_retries && !this._conn.connected) {\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, \"giving-up\");\n        }\n    },\n\n    /** PrivateFunction: _processRequest\n     *  _Private_ function to process a request in the queue.\n     *\n     *  This function takes requests off the queue and sends them and\n     *  restarts dead requests.\n     *\n     *  Parameters:\n     *    (Integer) i - The index of the request in the queue.\n     */\n    _processRequest: function (i) {\n        var self = this;\n        var req = this._requests[i];\n        var reqStatus = this._getRequestStatus(req, -1);\n\n        // make sure we limit the number of retries\n        if (req.sends > this._conn.maxRetries) {\n            this._conn._onDisconnectTimeout();\n            return;\n        }\n\n        var time_elapsed = req.age();\n        var primaryTimeout = (!isNaN(time_elapsed) &&\n                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));\n        var secondaryTimeout = (req.dead !== null &&\n                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));\n        var requestCompletedWithServerError = (req.xhr.readyState === 4 &&\n                                               (reqStatus < 1 || reqStatus >= 500));\n        if (primaryTimeout || secondaryTimeout ||\n            requestCompletedWithServerError) {\n            if (secondaryTimeout) {\n                Strophe.error(\"Request \" + this._requests[i].id +\n                              \" timed out (secondary), restarting\");\n            }\n            req.abort = true;\n            req.xhr.abort();\n            // setting to null fails on IE6, so set to empty function\n            req.xhr.onreadystatechange = function () {};\n            this._requests[i] = new Strophe.Request(req.xmlData,\n                                                    req.origFunc,\n                                                    req.rid,\n                                                    req.sends);\n            req = this._requests[i];\n        }\n\n        if (req.xhr.readyState === 0) {\n            Strophe.debug(\"request id \"+req.id+\".\"+req.sends+\" posting\");\n\n            try {\n                var contentType = this._conn.options.contentType || \"text/xml; charset=utf-8\";\n                req.xhr.open(\"POST\", this._conn.service, this._conn.options.sync ? false : true);\n                if (typeof req.xhr.setRequestHeader !== 'undefined') {\n                    // IE9 doesn't have setRequestHeader\n                    req.xhr.setRequestHeader(\"Content-Type\", contentType);\n                }\n                if (this._conn.options.withCredentials) {\n                    req.xhr.withCredentials = true;\n                }\n            } catch (e2) {\n                Strophe.error(\"XHR open failed: \" + e2.toString());\n                if (!this._conn.connected) {\n                    this._conn._changeConnectStatus(\n                            Strophe.Status.CONNFAIL, \"bad-service\");\n                }\n                this._conn.disconnect();\n                return;\n            }\n\n            // Fires the XHR request -- may be invoked immediately\n            // or on a gradually expanding retry window for reconnects\n            var sendFunc = function () {\n                req.date = new Date();\n                if (self._conn.options.customHeaders){\n                    var headers = self._conn.options.customHeaders;\n                    for (var header in headers) {\n                        if (headers.hasOwnProperty(header)) {\n                            req.xhr.setRequestHeader(header, headers[header]);\n                        }\n                    }\n                }\n                req.xhr.send(req.data);\n            };\n\n            // Implement progressive backoff for reconnects --\n            // First retry (send === 1) should also be instantaneous\n            if (req.sends > 1) {\n                // Using a cube of the retry number creates a nicely\n                // expanding retry window\n                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),\n                                       Math.pow(req.sends, 3)) * 1000;\n                setTimeout(function() {\n                    // XXX: setTimeout should be called only with function expressions (23974bc1)\n                    sendFunc();\n                }, backoff);\n            } else {\n                sendFunc();\n            }\n\n            req.sends++;\n\n            if (this._conn.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {\n                if (req.xmlData.nodeName === this.strip && req.xmlData.childNodes.length) {\n                    this._conn.xmlOutput(req.xmlData.childNodes[0]);\n                } else {\n                    this._conn.xmlOutput(req.xmlData);\n                }\n            }\n            if (this._conn.rawOutput !== Strophe.Connection.prototype.rawOutput) {\n                this._conn.rawOutput(req.data);\n            }\n        } else {\n            Strophe.debug(\"_processRequest: \" +\n                          (i === 0 ? \"first\" : \"second\") +\n                          \" request has readyState of \" +\n                          req.xhr.readyState);\n        }\n    },\n\n    /** PrivateFunction: _removeRequest\n     *  _Private_ function to remove a request from the queue.\n     *\n     *  Parameters:\n     *    (Strophe.Request) req - The request to remove.\n     */\n    _removeRequest: function (req) {\n        Strophe.debug(\"removing request\");\n        var i;\n        for (i = this._requests.length - 1; i >= 0; i--) {\n            if (req === this._requests[i]) {\n                this._requests.splice(i, 1);\n            }\n        }\n        // IE6 fails on setting to null, so set to empty function\n        req.xhr.onreadystatechange = function () {};\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _restartRequest\n     *  _Private_ function to restart a request that is presumed dead.\n     *\n     *  Parameters:\n     *    (Integer) i - The index of the request in the queue.\n     */\n    _restartRequest: function (i) {\n        var req = this._requests[i];\n        if (req.dead === null) {\n            req.dead = new Date();\n        }\n\n        this._processRequest(i);\n    },\n\n    /** PrivateFunction: _reqToData\n     * _Private_ function to get a stanza out of a request.\n     *\n     * Tries to extract a stanza out of a Request Object.\n     * When this fails the current connection will be disconnected.\n     *\n     *  Parameters:\n     *    (Object) req - The Request.\n     *\n     *  Returns:\n     *    The stanza that was passed.\n     */\n    _reqToData: function (req) {\n        try {\n            return req.getResponse();\n        } catch (e) {\n            if (e !== \"parsererror\") { throw e; }\n            this._conn.disconnect(\"strophe-parsererror\");\n        }\n    },\n\n    /** PrivateFunction: _sendTerminate\n     *  _Private_ function to send initial disconnect sequence.\n     *\n     *  This is the first step in a graceful disconnect.  It sends\n     *  the BOSH server a terminate body and includes an unavailable\n     *  presence if authentication has completed.\n     */\n    _sendTerminate: function (pres) {\n        Strophe.info(\"_sendTerminate was called\");\n        var body = this._buildBody().attrs({type: \"terminate\"});\n        if (pres) {\n            body.cnode(pres.tree());\n        }\n        var req = new Strophe.Request(\n            body.tree(),\n            this._onRequestStateChange.bind(\n            this, this._conn._dataRecv.bind(this._conn)),\n            body.tree().getAttribute(\"rid\")\n        );\n        this._requests.push(req);\n        this._throttledRequestHandler();\n    },\n\n    /** PrivateFunction: _send\n     *  _Private_ part of the Connection.send function for BOSH\n     *\n     * Just triggers the RequestHandler to send the messages that are in the queue\n     */\n    _send: function () {\n        clearTimeout(this._conn._idleTimeout);\n        this._throttledRequestHandler();\n\n        // XXX: setTimeout should be called only with function expressions (23974bc1)\n        this._conn._idleTimeout = setTimeout(function() {\n            this._onIdle();\n        }.bind(this._conn), 100);\n    },\n\n    /** PrivateFunction: _sendRestart\n     *\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        this._throttledRequestHandler();\n        clearTimeout(this._conn._idleTimeout);\n    },\n\n    /** PrivateFunction: _throttledRequestHandler\n     *  _Private_ function to throttle requests to the connection window.\n     *\n     *  This function makes sure we don't send requests so fast that the\n     *  request ids overflow the connection window in the case that one\n     *  request died.\n     */\n    _throttledRequestHandler: function () {\n        if (!this._requests) {\n            Strophe.debug(\"_throttledRequestHandler called with \" +\n                          \"undefined requests\");\n        } else {\n            Strophe.debug(\"_throttledRequestHandler called with \" +\n                          this._requests.length + \" requests\");\n        }\n\n        if (!this._requests || this._requests.length === 0) {\n            return;\n        }\n\n        if (this._requests.length > 0) {\n            this._processRequest(0);\n        }\n\n        if (this._requests.length > 1 &&\n            Math.abs(this._requests[0].rid -\n                     this._requests[1].rid) < this.window) {\n            this._processRequest(1);\n        }\n    }\n};\nreturn Strophe;\n}));\n\n/*\n    This program is distributed under the terms of the MIT license.\n    Please see the LICENSE file for details.\n\n    Copyright 2006-2008, OGG, LLC\n*/\n\n/* jshint undef: true, unused: true:, noarg: true, latedef: true */\n/* global define, window, clearTimeout, WebSocket, DOMParser, Strophe, $build */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('strophe-websocket',['strophe-core'], function (core) {\n            return factory(\n                core.Strophe,\n                core.$build\n            );\n        });\n    } else {\n        // Browser globals\n        return factory(Strophe, $build);\n    }\n}(this, function (Strophe, $build) {\n\n/** Class: Strophe.WebSocket\n *  _Private_ helper class that handles WebSocket Connections\n *\n *  The Strophe.WebSocket class is used internally by Strophe.Connection\n *  to encapsulate WebSocket sessions. It is not meant to be used from user's code.\n */\n\n/** File: websocket.js\n *  A JavaScript library to enable XMPP over Websocket in Strophejs.\n *\n *  This file implements XMPP over WebSockets for Strophejs.\n *  If a Connection is established with a Websocket url (ws://...)\n *  Strophe will use WebSockets.\n *  For more information on XMPP-over-WebSocket see RFC 7395:\n *  http://tools.ietf.org/html/rfc7395\n *\n *  WebSocket support implemented by Andreas Guth (andreas.guth@rwth-aachen.de)\n */\n\n/** PrivateConstructor: Strophe.Websocket\n *  Create and initialize a Strophe.WebSocket object.\n *  Currently only sets the connection Object.\n *\n *  Parameters:\n *    (Strophe.Connection) connection - The Strophe.Connection that will use WebSockets.\n *\n *  Returns:\n *    A new Strophe.WebSocket object.\n */\nStrophe.Websocket = function(connection) {\n    this._conn = connection;\n    this.strip = \"wrapper\";\n\n    var service = connection.service;\n    if (service.indexOf(\"ws:\") !== 0 && service.indexOf(\"wss:\") !== 0) {\n        // If the service is not an absolute URL, assume it is a path and put the absolute\n        // URL together from options, current URL and the path.\n        var new_service = \"\";\n\n        if (connection.options.protocol === \"ws\" && window.location.protocol !== \"https:\") {\n            new_service += \"ws\";\n        } else {\n            new_service += \"wss\";\n        }\n\n        new_service += \"://\" + window.location.host;\n\n        if (service.indexOf(\"/\") !== 0) {\n            new_service += window.location.pathname + service;\n        } else {\n            new_service += service;\n        }\n\n        connection.service = new_service;\n    }\n};\n\nStrophe.Websocket.prototype = {\n    /** PrivateFunction: _buildStream\n     *  _Private_ helper function to generate the <stream> start tag for WebSockets\n     *\n     *  Returns:\n     *    A Strophe.Builder with a <stream> element.\n     */\n    _buildStream: function () {\n        return $build(\"open\", {\n            \"xmlns\": Strophe.NS.FRAMING,\n            \"to\": this._conn.domain,\n            \"version\": '1.0'\n        });\n    },\n\n    /** PrivateFunction: _check_streamerror\n     * _Private_ checks a message for stream:error\n     *\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     *    connectstatus - The ConnectStatus that will be set on error.\n     *  Returns:\n     *     true if there was a streamerror, false otherwise.\n     */\n    _check_streamerror: function (bodyWrap, connectstatus) {\n        var errors;\n        if (bodyWrap.getElementsByTagNameNS) {\n            errors = bodyWrap.getElementsByTagNameNS(Strophe.NS.STREAM, \"error\");\n        } else {\n            errors = bodyWrap.getElementsByTagName(\"stream:error\");\n        }\n        if (errors.length === 0) {\n            return false;\n        }\n        var error = errors[0];\n\n        var condition = \"\";\n        var text = \"\";\n\n        var ns = \"urn:ietf:params:xml:ns:xmpp-streams\";\n        for (var i = 0; i < error.childNodes.length; i++) {\n            var e = error.childNodes[i];\n            if (e.getAttribute(\"xmlns\") !== ns) {\n                break;\n            } if (e.nodeName === \"text\") {\n                text = e.textContent;\n            } else {\n                condition = e.nodeName;\n            }\n        }\n\n        var errorString = \"WebSocket stream error: \";\n\n        if (condition) {\n            errorString += condition;\n        } else {\n            errorString += \"unknown\";\n        }\n\n        if (text) {\n            errorString += \" - \" + text;\n        }\n\n        Strophe.error(errorString);\n\n        // close the connection on stream_error\n        this._conn._changeConnectStatus(connectstatus, condition);\n        this._conn._doDisconnect();\n        return true;\n    },\n\n    /** PrivateFunction: _reset\n     *  Reset the connection.\n     *\n     *  This function is called by the reset function of the Strophe Connection.\n     *  Is not needed by WebSockets.\n     */\n    _reset: function () {\n        return;\n    },\n\n    /** PrivateFunction: _connect\n     *  _Private_ function called by Strophe.Connection.connect\n     *\n     *  Creates a WebSocket for a connection and assigns Callbacks to it.\n     *  Does nothing if there already is a WebSocket.\n     */\n    _connect: function () {\n        // Ensure that there is no open WebSocket from a previous Connection.\n        this._closeSocket();\n\n        // Create the new WobSocket\n        this.socket = new WebSocket(this._conn.service, \"xmpp\");\n        this.socket.onopen = this._onOpen.bind(this);\n        this.socket.onerror = this._onError.bind(this);\n        this.socket.onclose = this._onClose.bind(this);\n        this.socket.onmessage = this._connect_cb_wrapper.bind(this);\n    },\n\n    /** PrivateFunction: _connect_cb\n     *  _Private_ function called by Strophe.Connection._connect_cb\n     *\n     * checks for stream:error\n     *\n     *  Parameters:\n     *    (Strophe.Request) bodyWrap - The received stanza.\n     */\n    _connect_cb: function(bodyWrap) {\n        var error = this._check_streamerror(bodyWrap, Strophe.Status.CONNFAIL);\n        if (error) {\n            return Strophe.Status.CONNFAIL;\n        }\n    },\n\n    /** PrivateFunction: _handleStreamStart\n     * _Private_ function that checks the opening <open /> tag for errors.\n     *\n     * Disconnects if there is an error and returns false, true otherwise.\n     *\n     *  Parameters:\n     *    (Node) message - Stanza containing the <open /> tag.\n     */\n    _handleStreamStart: function(message) {\n        var error = false;\n\n        // Check for errors in the <open /> tag\n        var ns = message.getAttribute(\"xmlns\");\n        if (typeof ns !== \"string\") {\n            error = \"Missing xmlns in <open />\";\n        } else if (ns !== Strophe.NS.FRAMING) {\n            error = \"Wrong xmlns in <open />: \" + ns;\n        }\n\n        var ver = message.getAttribute(\"version\");\n        if (typeof ver !== \"string\") {\n            error = \"Missing version in <open />\";\n        } else if (ver !== \"1.0\") {\n            error = \"Wrong version in <open />: \" + ver;\n        }\n\n        if (error) {\n            this._conn._changeConnectStatus(Strophe.Status.CONNFAIL, error);\n            this._conn._doDisconnect();\n            return false;\n        }\n\n        return true;\n    },\n\n    /** PrivateFunction: _connect_cb_wrapper\n     * _Private_ function that handles the first connection messages.\n     *\n     * On receiving an opening stream tag this callback replaces itself with the real\n     * message handler. On receiving a stream error the connection is terminated.\n     */\n    _connect_cb_wrapper: function(message) {\n        if (message.data.indexOf(\"<open \") === 0 || message.data.indexOf(\"<?xml\") === 0) {\n            // Strip the XML Declaration, if there is one\n            var data = message.data.replace(/^(<\\?.*?\\?>\\s*)*/, \"\");\n            if (data === '') return;\n\n            var streamStart = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n            this._conn.xmlInput(streamStart);\n            this._conn.rawInput(message.data);\n\n            //_handleStreamSteart will check for XML errors and disconnect on error\n            if (this._handleStreamStart(streamStart)) {\n                //_connect_cb will check for stream:error and disconnect on error\n                this._connect_cb(streamStart);\n            }\n        } else if (message.data.indexOf(\"<close \") === 0) { // <close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing />\n            this._conn.rawInput(message.data);\n            this._conn.xmlInput(message);\n            var see_uri = message.getAttribute(\"see-other-uri\");\n            if (see_uri) {\n                this._conn._changeConnectStatus(\n                    Strophe.Status.REDIRECT,\n                    \"Received see-other-uri, resetting connection\"\n                );\n                this._conn.reset();\n                this._conn.service = see_uri;\n                this._connect();\n            } else {\n                this._conn._changeConnectStatus(\n                    Strophe.Status.CONNFAIL,\n                    \"Received closing stream\"\n                );\n                this._conn._doDisconnect();\n            }\n        } else {\n            var string = this._streamWrap(message.data);\n            var elem = new DOMParser().parseFromString(string, \"text/xml\").documentElement;\n            this.socket.onmessage = this._onMessage.bind(this);\n            this._conn._connect_cb(elem, null, message.data);\n        }\n    },\n\n    /** PrivateFunction: _disconnect\n     *  _Private_ function called by Strophe.Connection.disconnect\n     *\n     *  Disconnects and sends a last stanza if one is given\n     *\n     *  Parameters:\n     *    (Request) pres - This stanza will be sent before disconnecting.\n     */\n    _disconnect: function (pres) {\n        if (this.socket && this.socket.readyState !== WebSocket.CLOSED) {\n            if (pres) {\n                this._conn.send(pres);\n            }\n            var close = $build(\"close\", { \"xmlns\": Strophe.NS.FRAMING });\n            this._conn.xmlOutput(close);\n            var closeString = Strophe.serialize(close);\n            this._conn.rawOutput(closeString);\n            try {\n                this.socket.send(closeString);\n            } catch (e) {\n                Strophe.info(\"Couldn't send <close /> tag.\");\n            }\n        }\n        this._conn._doDisconnect();\n    },\n\n    /** PrivateFunction: _doDisconnect\n     *  _Private_ function to disconnect.\n     *\n     *  Just closes the Socket for WebSockets\n     */\n    _doDisconnect: function () {\n        Strophe.info(\"WebSockets _doDisconnect was called\");\n        this._closeSocket();\n    },\n\n    /** PrivateFunction _streamWrap\n     *  _Private_ helper function to wrap a stanza in a <stream> tag.\n     *  This is used so Strophe can process stanzas from WebSockets like BOSH\n     */\n    _streamWrap: function (stanza) {\n        return \"<wrapper>\" + stanza + '</wrapper>';\n    },\n\n\n    /** PrivateFunction: _closeSocket\n     *  _Private_ function to close the WebSocket.\n     *\n     *  Closes the socket if it is still open and deletes it\n     */\n    _closeSocket: function () {\n        if (this.socket) { try {\n            this.socket.close();\n        } catch (e) {} }\n        this.socket = null;\n    },\n\n    /** PrivateFunction: _emptyQueue\n     * _Private_ function to check if the message queue is empty.\n     *\n     *  Returns:\n     *    True, because WebSocket messages are send immediately after queueing.\n     */\n    _emptyQueue: function () {\n        return true;\n    },\n\n    /** PrivateFunction: _onClose\n     * _Private_ function to handle websockets closing.\n     *\n     * Nothing to do here for WebSockets\n     */\n    _onClose: function(e) {\n        if(this._conn.connected && !this._conn.disconnecting) {\n            Strophe.error(\"Websocket closed unexpectedly\");\n            this._conn._doDisconnect();\n        } else if (e && e.code === 1006 && !this._conn.connected && this.socket) {\n            // in case the onError callback was not called (Safari 10 does not\n            // call onerror when the initial connection fails) we need to\n            // dispatch a CONNFAIL status update to be consistent with the\n            // behavior on other browsers.\n            Strophe.error(\"Websocket closed unexcectedly\");\n            this._conn._changeConnectStatus(\n                Strophe.Status.CONNFAIL,\n                \"The WebSocket connection could not be established or was disconnected.\"\n            );\n            this._conn._doDisconnect();\n        } else {\n            Strophe.info(\"Websocket closed\");\n        }\n    },\n\n    /** PrivateFunction: _no_auth_received\n     *\n     * Called on stream start/restart when no stream:features\n     * has been received.\n     */\n    _no_auth_received: function (_callback) {\n        Strophe.error(\"Server did not send any auth methods\");\n        this._conn._changeConnectStatus(\n            Strophe.Status.CONNFAIL,\n            \"Server did not send any auth methods\"\n        );\n        if (_callback) {\n            _callback = _callback.bind(this._conn);\n            _callback();\n        }\n        this._conn._doDisconnect();\n    },\n\n    /** PrivateFunction: _onDisconnectTimeout\n     *  _Private_ timeout handler for handling non-graceful disconnection.\n     *\n     *  This does nothing for WebSockets\n     */\n    _onDisconnectTimeout: function () {},\n\n    /** PrivateFunction: _abortAllRequests\n     *  _Private_ helper function that makes sure all pending requests are aborted.\n     */\n    _abortAllRequests: function () {},\n\n    /** PrivateFunction: _onError\n     * _Private_ function to handle websockets errors.\n     *\n     * Parameters:\n     * (Object) error - The websocket error.\n     */\n    _onError: function(error) {\n        Strophe.error(\"Websocket error \" + error);\n        this._conn._changeConnectStatus(\n            Strophe.Status.CONNFAIL,\n            \"The WebSocket connection could not be established or was disconnected.\"\n        );\n        this._disconnect();\n    },\n\n    /** PrivateFunction: _onIdle\n     *  _Private_ function called by Strophe.Connection._onIdle\n     *\n     *  sends all queued stanzas\n     */\n    _onIdle: function () {\n        var data = this._conn._data;\n        if (data.length > 0 && !this._conn.paused) {\n            for (var i = 0; i < data.length; i++) {\n                if (data[i] !== null) {\n                    var stanza, rawStanza;\n                    if (data[i] === \"restart\") {\n                        stanza = this._buildStream().tree();\n                    } else {\n                        stanza = data[i];\n                    }\n                    rawStanza = Strophe.serialize(stanza);\n                    this._conn.xmlOutput(stanza);\n                    this._conn.rawOutput(rawStanza);\n                    this.socket.send(rawStanza);\n                }\n            }\n            this._conn._data = [];\n        }\n    },\n\n    /** PrivateFunction: _onMessage\n     * _Private_ function to handle websockets messages.\n     *\n     * This function parses each of the messages as if they are full documents.\n     * [TODO : We may actually want to use a SAX Push parser].\n     *\n     * Since all XMPP traffic starts with\n     *  <stream:stream version='1.0'\n     *                 xml:lang='en'\n     *                 xmlns='jabber:client'\n     *                 xmlns:stream='http://etherx.jabber.org/streams'\n     *                 id='3697395463'\n     *                 from='SERVER'>\n     *\n     * The first stanza will always fail to be parsed.\n     *\n     * Additionally, the seconds stanza will always be <stream:features> with\n     * the stream NS defined in the previous stanza, so we need to 'force'\n     * the inclusion of the NS in this stanza.\n     *\n     * Parameters:\n     * (string) message - The websocket message.\n     */\n    _onMessage: function(message) {\n        var elem, data;\n        // check for closing stream\n        var close = '<close xmlns=\"urn:ietf:params:xml:ns:xmpp-framing\" />';\n        if (message.data === close) {\n            this._conn.rawInput(close);\n            this._conn.xmlInput(message);\n            if (!this._conn.disconnecting) {\n                this._conn._doDisconnect();\n            }\n            return;\n        } else if (message.data.search(\"<open \") === 0) {\n            // This handles stream restarts\n            elem = new DOMParser().parseFromString(message.data, \"text/xml\").documentElement;\n            if (!this._handleStreamStart(elem)) {\n                return;\n            }\n        } else {\n            data = this._streamWrap(message.data);\n            elem = new DOMParser().parseFromString(data, \"text/xml\").documentElement;\n        }\n\n        if (this._check_streamerror(elem, Strophe.Status.ERROR)) {\n            return;\n        }\n\n        //handle unavailable presence stanza before disconnecting\n        if (this._conn.disconnecting &&\n                elem.firstChild.nodeName === \"presence\" &&\n                elem.firstChild.getAttribute(\"type\") === \"unavailable\") {\n            this._conn.xmlInput(elem);\n            this._conn.rawInput(Strophe.serialize(elem));\n            // if we are already disconnecting we will ignore the unavailable stanza and\n            // wait for the </stream:stream> tag before we close the connection\n            return;\n        }\n        this._conn._dataRecv(elem, message.data);\n    },\n\n    /** PrivateFunction: _onOpen\n     * _Private_ function to handle websockets connection setup.\n     *\n     * The opening stream tag is sent here.\n     */\n    _onOpen: function() {\n        Strophe.info(\"Websocket open\");\n        var start = this._buildStream();\n        this._conn.xmlOutput(start.tree());\n\n        var startString = Strophe.serialize(start);\n        this._conn.rawOutput(startString);\n        this.socket.send(startString);\n    },\n\n    /** PrivateFunction: _reqToData\n     * _Private_ function to get a stanza out of a request.\n     *\n     * WebSockets don't use requests, so the passed argument is just returned.\n     *\n     *  Parameters:\n     *    (Object) stanza - The stanza.\n     *\n     *  Returns:\n     *    The stanza that was passed.\n     */\n    _reqToData: function (stanza) {\n        return stanza;\n    },\n\n    /** PrivateFunction: _send\n     *  _Private_ part of the Connection.send function for WebSocket\n     *\n     * Just flushes the messages that are in the queue\n     */\n    _send: function () {\n        this._conn.flush();\n    },\n\n    /** PrivateFunction: _sendRestart\n     *\n     *  Send an xmpp:restart stanza.\n     */\n    _sendRestart: function () {\n        clearTimeout(this._conn._idleTimeout);\n        this._conn._onIdle.bind(this._conn)();\n    }\n};\nreturn Strophe;\n}));\n\n(function(root){\n    if(typeof define === 'function' && define.amd){\n        define('strophe',[\n            \"strophe-core\",\n            \"strophe-bosh\",\n            \"strophe-websocket\"\n        ], function (wrapper) {\n            return wrapper;\n        });\n    }\n})(this);\n\n\nrequire([\"strophe-polyfill\"]);\n/* jshint ignore:start */\n    //The modules for your project will be inlined above\n    //this snippet. Ask almond to synchronously require the\n    //module value for 'main' here and return it as the\n    //value to use for the public API for the built file.\n    return require('strophe');\n}));\n/* jshint ignore:end */\n\n\n\n// WEBPACK FOOTER //\n// ./sdk/dist/strophe-1.2.14.js"],"sourceRoot":""}