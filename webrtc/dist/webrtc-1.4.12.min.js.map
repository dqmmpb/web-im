{"version":3,"sources":["webpack:///webrtc/dist/webrtc-1.4.12.min.js","webpack:///webpack/bootstrap c9402f91bc3dfc2c1147?e414**","webpack:///./webrtc/src/entry.js","webpack:///(webpack)/buildin/module.js","webpack:///./webrtc/src/components/utils.js","webpack:///./webrtc/src/components/call.js","webpack:///./webrtc/src/components/iq.js","webpack:///./webrtc/src/components/api.js","webpack:///./webrtc/src/components/webrtc.js","webpack:///./webrtc/src/components/p2p.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","247","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","obj","constructor","prototype","Util","Call","window","WebIM","WebRTC","apply","undefined","test","navigator","userAgent","supportPRAnswer","split","248","webpackPolyfill","deprecate","paths","children","249","CHARS","Math","uuid","len","radix","i","chars","length","random","r","join","uuidFast","Array","rnd","uuidCompact","replace","v","toString","Logger","callLog","level","args","_args","push","self","log","this","LogLevel","TRACE","DEBUG","INFO","WARN","ERROR","FATAL","LogLevelName","arguments","config","isDebug","console","trace","debug","info","warn","error","fatal","logger","parseJSON","jsonString","JSON","parse","class2type","stringifyJSON","jsonObj","stringify","hasOwn","hasOwnProperty","fnToString","ObjectFunctionString","Object","isPlainObject","proto","Ctor","getPrototypeOf","isArray","isEmptyObject","name","type","extend","options","src","copy","copyIsArray","clone","target","deep","isFunction","hasLocalStorage","key","localStorage","getItem","toggleClass","node","className","hasClass","removeClass","addClass","setCookie","value","hour","exp","Date","setTime","getTime","document","cookie","escape","toGMTString","getCookie","arr","match","RegExp","unescape","parseURL","reg","location","search","substr","250","RTCIQHandler","API","CommonPattern","RouteTo","Api","_logger","_Call","api","caller","connection","pattern","listener","onAcceptCall","from","onRinging","onTermCall","onIceConnectionStateChange","iceState","mediaStreamConstaints","audio","video","init","imConnection","rtcHandler","onInitC","_onInitC","makeVideoCall","callee","accessSid","makeVoiceCall","acceptCall","accept","endCall","termCall","jid","rt","rtKey","sid","success","result","fail","onError","reqP2P","rtcOptions","online","message","_onGotServerP2PConfig","initC","rtkey","tsxId","fromSid","_rtcCfg","rtcCfg","_WebRTCCfg","sessId","rtcId","switchPattern","streamType","_p2pConfig","_rtcCfg2","rtcCfg2","_rtKey","_rtkey","_rtFlag","_rtflag","rtFlag","rtflag","admtok","tkt","_sessId","_rtcId","webRtc","onGotLocalStream","onGotRemoteStream","onOtherUserOpenVoice","onOtherUserOpenVideo","initConfigs","251","_util","CONFERENCE_XMLNS","_RtcHandler","_apiCallbacks","_connectedSid","_conn","registerConfrIQHandler","handleConferenceIQ","msginfo","handleRtcMessage","stack","addHandler","getAttribute","lastIndexOf","substring","getElementsByTagName","innerHTML","fromSessionId","_fromSessionID","contentTags","contentString","content","op","singalStreamType","ctx","indexOf","to","data","reason","sendRtcMessage","reasonObj","sdp","toLowerCase","cands","sdpMLineIndex","mlineindex","sdpMid","mid","callback","err","onRecvRtcMessage","rtcJSON","convertRtcOptions","_sdp","toUpperCase","_cands","RTCIceCandidate","_cand","candidate","_webrtc","getUniqueId","domain","iq","$iq","context","xmlns","t","up","tree","completeFn","errFn","ele","stropheConn","sendIQ","252","_RouteTo","extendCfg","sub","_clazz","events","1","2","3","100","101","102","103","104","105","106","107","300","301","302","303","304","204","400","401","onServerError","register","event","bind","func","onFunc","shortUserName","appKey","peer","newCfr","reqTkt","password","enter","WebRTCId","reqMembers","nonce","digest","ping","streamControl","controlType","pubS","subS","tcklC","ansC","enableVoice","enableVideo","acptC","ans","getMems","subC","usubC","termC","exit","delCfr","_onRecvRtcMessage","onFunction","253","_WebrtcStatistics","bytesPrev","timestampPrev","sentBytesPrev","sentTimestampPrev","printStats","rtcPeerConnection","getStats","results","parseRecvStatistics","stopIntervalPrintStats","_printIntervalId","clearInterval","intervalPrintStats","seconds","_intervalPrintStats","setInterval","callbackSent","bitrate","remoteWidth","remoteHeight","activeCandidatePair","remoteCandidate","keys","forEach","report","now","timestamp","mediaType","floor","bitrateMean","bytesReceived","bytes","selected","googActiveConnection","bytesSent","googFrameHeightSent","br","googFrameWidthSent","remoteCandidateId","ipAddress","portNumber","WebrtcStatisticsHelper","cfg","webrtcStatisticsHelper","_SDPSection","headerSection","audioSection","videoSection","_parseHeaderSection","index","slice","_parseAudioSection","endIndex","_parseVideoSection","spiltSection","removeSSRC","section","_arr","removeField_msid","updateHeaderMsidSemantic","wms","line","updateAudioSSRCSection","ssrc","cname","msid","label","ssrcSection","updateVideoSSRCSection","getUpdatedSDP","parseMsidSemantic","header","regexp","_parseLine","msidSemantic","WMS","lines","parseSSRC","updateSSRCSection","e","str","exec","SDPSection","_WebRTC","localStream","offerOptions","offerToReceiveAudio","offerToReceiveVideo","createMedia","constaints","onGotStream","gotStream","stream","videoTracks","getVideoTracks","audioTracks","getAudioTracks","mediaDevices","getUserMedia","then","onCreateMedia","catch","setLocalVideoSrcObject","createRtcPeerConnection","iceServerConfig","iceServers","rtcpMuxPolicy","bundlePolicy","relayOnly","iceTransportPolicy","startTime","performance","RTCPeerConnection","onicecandidate","onIceCandidate","onicestatechange","onIceStateChange","oniceconnectionstatechange","iceConnectionState","onaddstream","_onGotRemoteStream","_uploadLocalStream","addStream","createOffer","onCreateOfferSuccess","onCreateOfferError","desc","offerDescription","setLocalDescription","onSetLocalSessionDescriptionSuccess","onSetSessionDescriptionError","onCreateSessionDescriptionError","createPRAnswer","onCreatePRAnswerSuccess","onCreatePRAnswerError","createAnswer","prAnswerDescription","onSetLocalSuccess","sdpSection","onCreateAnswerSuccess","onCreateAnswerError","ms","audioSSRC","videoSSRC","answerDescription","close","getTracks","track","stop","addIceCandidate","onAddIceCandidateSuccess","onAddIceCandidateError","setRemoteDescription","RTCSessionDescription","onSetRemoteSuccess","enabled","254","P2PRouteTo","_pingIntervalId","isCaller","accepted","setLocalSDP","setRemoteSDP","hangup","onPing","_onPing","onTcklC","_onTcklC","onAcptC","_onAcptC","onAnsC","_onAnsC","onTermC","_onTermC","onEvJoin","_onEvJoin","onStreamControl","_onStreamControl","_onIceCandidate","_onIceStateChange","_ping","createLocalMedia","webrtc","offer","_onGotWebRtcOffer","_handRecvCandsOrSend","__onVoiceOrVideo","opened","_tsxId","_fromSid","prAnswer","_onGotWebRtcPRAnswer","setTimeout","createAndSendAnswer","answer","_recvCands","sendIceCandidate","sendReason"],"mappings":"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","file":"./webrtc/dist/webrtc-1.4.12.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(247);\n\n\n/***/ }),\n\n/***/ 247:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar Util = __webpack_require__(249);\n\tvar Call = __webpack_require__(250);\n\t\n\twindow.WebIM = typeof WebIM !== 'undefined' ? WebIM : {};\n\tWebIM.WebRTC = WebIM.WebRTC || {};\n\tWebIM.WebRTC.Call = Call;\n\tWebIM.WebRTC.Util = Util;\n\t\n\tif (( false ? 'undefined' : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n\t    module.exports = WebIM.WebRTC;\n\t} else if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t        return WebIM.WebRTC;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t\n\t/**\n\t * 判断是否支持pranswer\n\t */\n\tif (/Chrome/.test(navigator.userAgent)) {\n\t    WebIM.WebRTC.supportPRAnswer = navigator.userAgent.split(\"Chrome/\")[1].split(\".\")[0] >= 50 ? true : false;\n\t}\n\t\n\t//WebIM.WebRTC.supportPRAnswer = false;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(248)(module)))\n\n/***/ }),\n\n/***/ 248:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ }),\n\n/***/ 249:\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/*\n\t * ! Math.uuid.js (v1.4) http://www.broofa.com mailto:robert@broofa.com\n\t * \n\t * Copyright (c) 2010 Robert Kieffer Dual licensed under the MIT and GPL\n\t * licenses.\n\t */\n\t\n\t/*\n\t * Generate a random uuid.\n\t * \n\t * USAGE: Math.uuid(length, radix) length - the desired number of characters\n\t * radix - the number of allowable values for each character.\n\t * \n\t * EXAMPLES: // No arguments - returns RFC4122, version 4 ID >>> Math.uuid()\n\t * \"92329D39-6F5C-4520-ABFC-AAB64544E172\" // One argument - returns ID of the\n\t * specified length >>> Math.uuid(15) // 15 character ID (default base=62)\n\t * \"VcydxgltxrVZSTV\" // Two arguments - returns ID of the specified length, and\n\t * radix. (Radix must be <= 62) >>> Math.uuid(8, 2) // 8 character ID (base=2)\n\t * \"01001010\" >>> Math.uuid(8, 10) // 8 character ID (base=10) \"47473046\" >>>\n\t * Math.uuid(8, 16) // 8 character ID (base=16) \"098F4D35\"\n\t */\n\t(function () {\n\t    // Private array of chars to use\n\t    var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\t\n\t    Math.uuid = function (len, radix) {\n\t        var chars = CHARS,\n\t            uuid = [],\n\t            i;\n\t        radix = radix || chars.length;\n\t\n\t        if (len) {\n\t            // Compact form\n\t            for (i = 0; i < len; i++) {\n\t                uuid[i] = chars[0 | Math.random() * radix];\n\t            }\n\t        } else {\n\t            // rfc4122, version 4 form\n\t            var r;\n\t\n\t            // rfc4122 requires these characters\n\t            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\t            uuid[14] = '4';\n\t\n\t            // Fill in random data. At i==19 set the high bits of clock sequence\n\t            // as\n\t            // per rfc4122, sec. 4.1.5\n\t            for (i = 0; i < 36; i++) {\n\t                if (!uuid[i]) {\n\t                    r = 0 | Math.random() * 16;\n\t                    uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\n\t                }\n\t            }\n\t        }\n\t\n\t        return uuid.join('');\n\t    };\n\t\n\t    // A more performant, but slightly bulkier, RFC4122v4 solution. We boost\n\t    // performance\n\t    // by minimizing calls to random()\n\t    Math.uuidFast = function () {\n\t        var chars = CHARS,\n\t            uuid = new Array(36),\n\t            rnd = 0,\n\t            r;\n\t        for (var i = 0; i < 36; i++) {\n\t            if (i == 8 || i == 13 || i == 18 || i == 23) {\n\t                uuid[i] = '-';\n\t            } else if (i == 14) {\n\t                uuid[i] = '4';\n\t            } else {\n\t                if (rnd <= 0x02) rnd = 0x2000000 + Math.random() * 0x1000000 | 0;\n\t                r = rnd & 0xf;\n\t                rnd = rnd >> 4;\n\t                uuid[i] = chars[i == 19 ? r & 0x3 | 0x8 : r];\n\t            }\n\t        }\n\t        return uuid.join('');\n\t    };\n\t\n\t    // A more compact, but less performant, RFC4122v4 solution:\n\t    Math.uuidCompact = function () {\n\t        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t            var r = Math.random() * 16 | 0,\n\t                v = c == 'x' ? r : r & 0x3 | 0x8;\n\t            return v.toString(16);\n\t        });\n\t    };\n\t})();\n\t\n\t/**\n\t * Util\n\t *\n\t * @constructor\n\t */\n\tfunction Util() {}\n\t\n\t/**\n\t * Function Logger\n\t *\n\t * @constructor\n\t */\n\tvar Logger = function Logger() {\n\t    var self = this;\n\t\n\t    var LogLevel = {\n\t        TRACE: 0,\n\t        DEBUG: 1,\n\t        INFO: 2,\n\t        WARN: 3,\n\t        ERROR: 4,\n\t        FATAL: 5\n\t    };\n\t\n\t    var LogLevelName = ['TRACE', 'DEBUG', 'INFO', 'WARN', 'ERROR', 'FATAL'];\n\t\n\t    this.log = function () {\n\t        var level = arguments[0];\n\t\n\t        level = arguments[0] = '[' + LogLevelName[level] + '] ';\n\t\n\t        var text = arguments[1];\n\t\n\t        if (WebIM && WebIM.config && WebIM.config.isDebug) {\n\t            console.log.apply(console, arguments);\n\t        }\n\t    };\n\t\n\t    function callLog(level, args) {\n\t        var _args = [];\n\t\n\t        _args.push(level);\n\t\n\t        for (var i in args) {\n\t            _args.push(args[i]);\n\t        }\n\t\n\t        self.log.apply(self, _args);\n\t    };\n\t\n\t    this.trace = function () {\n\t        this.log && callLog(LogLevel.TRACE, arguments);\n\t    };\n\t\n\t    this.debug = function () {\n\t        this.log && callLog(LogLevel.DEBUG, arguments);\n\t    };\n\t\n\t    this.info = function () {\n\t        this.log && callLog(LogLevel.INFO, arguments);\n\t    };\n\t\n\t    this.warn = function () {\n\t        this.log && callLog(LogLevel.WARN, arguments);\n\t    };\n\t\n\t    this.error = function () {\n\t        this.log && callLog(LogLevel.ERROR, arguments);\n\t    };\n\t\n\t    this.fatal = function () {\n\t        this.log && callLog(LogLevel.FATAL, arguments);\n\t    };\n\t};\n\t\n\tUtil.prototype.logger = new Logger();\n\t\n\t/**\n\t * parse json\n\t *\n\t * @param jsonString\n\t */\n\tUtil.prototype.parseJSON = function (jsonString) {\n\t    return JSON.parse(jsonString);\n\t};\n\t\n\t/**\n\t * json to string\n\t *\n\t * @type {Util.stringifyJSON}\n\t */\n\tvar stringifyJSON = Util.prototype.stringifyJSON = function (jsonObj) {\n\t    return JSON.stringify(jsonObj);\n\t};\n\t\n\tvar class2type = {};\n\t\n\tvar toString = class2type.toString;\n\t\n\tvar hasOwn = class2type.hasOwnProperty;\n\t\n\tvar fnToString = hasOwn.toString;\n\t\n\tvar ObjectFunctionString = fnToString.call(Object);\n\t\n\t/**\n\t * check object type\n\t *\n\t * @type {Util.isPlainObject}\n\t */\n\tvar isPlainObject = Util.prototype.isPlainObject = function (obj) {\n\t    var proto, Ctor;\n\t\n\t    // Detect obvious negatives\n\t    // Use toString instead of jQuery.type to catch host objects\n\t    if (!obj || toString.call(obj) !== \"[object Object]\") {\n\t        return false;\n\t    }\n\t\n\t    proto = Object.getPrototypeOf(obj);\n\t\n\t    // Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t    if (!proto) {\n\t        return true;\n\t    }\n\t\n\t    // Objects with prototype are plain iff they were constructed by a\n\t    // global Object function\n\t    Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n\t    return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n\t};\n\t\n\tUtil.prototype.isArray = Array.isArray;\n\t\n\t/**\n\t * check empty object\n\t *\n\t * @param obj\n\t * @returns {boolean}\n\t */\n\tUtil.prototype.isEmptyObject = function (obj) {\n\t    var name;\n\t    for (name in obj) {\n\t        return false;\n\t    }\n\t    return true;\n\t};\n\t\n\tUtil.prototype.type = function (obj) {\n\t    if (obj == null) {\n\t        return obj + \"\";\n\t    }\n\t    return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n\t};\n\t\n\t/**\n\t * Function extend\n\t *\n\t * @returns {*|{}}\n\t */\n\tUtil.prototype.extend = function () {\n\t    var self = this;\n\t    var options,\n\t        name,\n\t        src,\n\t        copy,\n\t        copyIsArray,\n\t        clone,\n\t        target = arguments[0] || {},\n\t        i = 1,\n\t        length = arguments.length,\n\t        deep = false;\n\t\n\t    // Handle a deep copy situation\n\t    if (typeof target === \"boolean\") {\n\t        deep = target;\n\t\n\t        // Skip the boolean and the target\n\t        target = arguments[i] || {};\n\t        i++;\n\t    }\n\t\n\t    // Handle case when target is a string or something (possible in deep\n\t    // copy)\n\t    if ((typeof target === 'undefined' ? 'undefined' : _typeof(target)) !== \"object\" && !self.isFunction(target)) {\n\t        target = {};\n\t    }\n\t\n\t    // Extend self itself if only one argument is passed\n\t    if (i === length) {\n\t        target = this;\n\t        i--;\n\t    }\n\t\n\t    for (; i < length; i++) {\n\t\n\t        // Only deal with non-null/undefined values\n\t        if ((options = arguments[i]) != null) {\n\t\n\t            // Extend the base object\n\t            for (name in options) {\n\t                src = target[name];\n\t                copy = options[name];\n\t\n\t                // Prevent never-ending loop\n\t                if (target === copy) {\n\t                    continue;\n\t                }\n\t\n\t                // Recurse if we're merging plain objects or arrays\n\t                if (deep && copy && (self.isPlainObject(copy) || (copyIsArray = self.isArray(copy)))) {\n\t\n\t                    if (copyIsArray) {\n\t                        copyIsArray = false;\n\t                        clone = src && self.isArray(src) ? src : [];\n\t                    } else {\n\t                        clone = src && self.isPlainObject(src) ? src : {};\n\t                    }\n\t\n\t                    // Never move original objects, clone them\n\t                    target[name] = self.extend(deep, clone, copy);\n\t\n\t                    // Don't bring in undefined values\n\t                } else if (copy !== undefined) {\n\t                    target[name] = copy;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // Return the modified object\n\t    return target;\n\t};\n\t\n\t/**\n\t * get local cache\n\t *\n\t * @memberOf tool\n\t * @name hasLocalData\n\t * @param key{string}\n\t *            localStorage的key值\n\t * @return boolean\n\t */\n\tUtil.prototype.hasLocalStorage = function (key) {\n\t    // null -> localStorage.removeItem时\n\t    // '{}' -> collection.models.destroy时\n\t    if (localStorage.getItem(key) == null || localStorage.getItem(key) == '{}') {\n\t        return false;\n\t    }\n\t    return true;\n\t};\n\t\n\tUtil.prototype.toggleClass = function (node, className) {\n\t    if (node.hasClass(className)) {\n\t        node.removeClass(className);\n\t        return;\n\t    }\n\t    node.addClass(className);\n\t};\n\t\n\t/**\n\t * set cookie\n\t *\n\t * @param name{String}\n\t *\n\t * @param value{String}\n\t *\n\t * @param hour{Number}\n\t *\n\t * @return void\n\t */\n\tUtil.prototype.setCookie = function (name, value, hour) {\n\t    var exp = new Date();\n\t    exp.setTime(exp.getTime() + hour * 60 * 60 * 1000);\n\t    document.cookie = name + \"=\" + escape(value) + \";expires=\" + exp.toGMTString();\n\t};\n\t\n\t/**\n\t * read cookie\n\t *\n\t * @param name(String)\n\t *            cookie key\n\t * @return cookie value\n\t * @memberOf Tool\n\t */\n\tUtil.prototype.getCookie = function (name) {\n\t    var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\"));\n\t    if (arr != null) {\n\t        return unescape(arr[2]);\n\t    }\n\t    return null;\n\t};\n\t\n\t/**\n\t * query parameter from url\n\t *\n\t * @name parseURL\n\t * @memberof C.Tools\n\t * @param {string}\n\t *\n\t * @return {string}\n\t * @type function\n\t * @public\n\t */\n\tUtil.prototype.parseURL = function (name) {\n\t    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");\n\t    var r = window.location.search.substr(1).match(reg);\n\t    if (r != null) {\n\t        return unescape(r[2]);\n\t    }\n\t    return null;\n\t};\n\t\n\tmodule.exports = new Util();\n\n/***/ }),\n\n/***/ 250:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Util = __webpack_require__(249);\n\tvar RTCIQHandler = __webpack_require__(251);\n\tvar API = __webpack_require__(252);\n\tvar WebRTC = __webpack_require__(253);\n\tvar CommonPattern = __webpack_require__(254);\n\t\n\tvar RouteTo = API.RouteTo;\n\tvar Api = API.Api;\n\tvar _logger = Util.logger;\n\t\n\tvar _Call = {\n\t    api: null,\n\t    caller: '',\n\t    connection: null,\n\t\n\t    pattern: null,\n\t\n\t    listener: {\n\t        onAcceptCall: function onAcceptCall(from, options) {},\n\t\n\t        onRinging: function onRinging(caller) {},\n\t\n\t        onTermCall: function onTermCall() {},\n\t\n\t        onIceConnectionStateChange: function onIceConnectionStateChange(iceState) {}\n\t    },\n\t\n\t    mediaStreamConstaints: {\n\t        audio: true,\n\t        video: true\n\t    },\n\t\n\t    init: function init() {\n\t        var self = this;\n\t\n\t        if (typeof self.connection === \"undefined\") {\n\t            throw \"Caller need a instance of Easemob.im.Connection\";\n\t        }\n\t\n\t        self.api = self.api || new Api({\n\t            imConnection: self.connection,\n\t\n\t            rtcHandler: new RTCIQHandler({\n\t                imConnection: self.connection\n\t            })\n\t        });\n\t\n\t        self.api.onInitC = function () {\n\t            self._onInitC.apply(self, arguments);\n\t        }, self.api.onIceConnectionStateChange = function () {\n\t            self.listener.onIceConnectionStateChange.apply(self, arguments);\n\t        };\n\t    },\n\t\n\t    makeVideoCall: function makeVideoCall(callee, accessSid) {\n\t        var self = this;\n\t\n\t        var mediaStreamConstaints = {};\n\t        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);\n\t        self.mediaStreamConstaints.video = true;\n\t\n\t        this.call(callee, mediaStreamConstaints, accessSid);\n\t    },\n\t\n\t    makeVoiceCall: function makeVoiceCall(callee, accessSid) {\n\t        console.log('ScareCrow');\n\t        var self = this;\n\t\n\t        var mediaStreamConstaints = {};\n\t        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);\n\t        self.mediaStreamConstaints.video = false;\n\t\n\t        self.call(callee, mediaStreamConstaints, accessSid);\n\t    },\n\t\n\t    acceptCall: function acceptCall() {\n\t        var self = this;\n\t        self.pattern.accept();\n\t    },\n\t\n\t    endCall: function endCall(callee) {\n\t        var self = this;\n\t        self.caller = '';\n\t        self.pattern.termCall();\n\t    },\n\t\n\t    call: function call(callee, mediaStreamConstaints, accessSid) {\n\t        var self = this;\n\t        this.callee = this.api.jid(callee);\n\t\n\t        var rt = new RouteTo({\n\t            rtKey: \"\",\n\t            sid: accessSid,\n\t\n\t            success: function success(result) {\n\t                _logger.debug(\"iq to server success\", result);\n\t            },\n\t            fail: function fail(error) {\n\t                _logger.debug(\"iq to server error\", error);\n\t                self.onError(error);\n\t            }\n\t        });\n\t\n\t        this.api.reqP2P(rt, mediaStreamConstaints.video ? 1 : 0, mediaStreamConstaints.audio ? 1 : 0, this.api.jid(callee), function (from, rtcOptions) {\n\t            if (rtcOptions.online == \"0\") {\n\t                self.listener.onError({ message: \"callee is not online!\" });\n\t                return;\n\t            }\n\t            self._onGotServerP2PConfig(from, rtcOptions);\n\t            self.pattern.initC(self.mediaStreamConstaints, accessSid);\n\t        });\n\t    },\n\t\n\t    _onInitC: function _onInitC(from, options, rtkey, tsxId, fromSid) {\n\t        var self = this;\n\t\n\t        self.callee = from;\n\t        self._rtcCfg = options.rtcCfg;\n\t        self._WebRTCCfg = options.WebRTC;\n\t\n\t        self.sessId = options.sessId;\n\t        self.rtcId = options.rtcId;\n\t\n\t        self.switchPattern(options.streamType == \"VIDEO\" ? \"VIDEO\" : \"VOICE\");\n\t        self.pattern._onInitC(from, options, rtkey, tsxId, fromSid);\n\t    },\n\t\n\t    _onGotServerP2PConfig: function _onGotServerP2PConfig(from, rtcOptions) {\n\t        var self = this;\n\t\n\t        if (rtcOptions.result == 0) {\n\t            self._p2pConfig = rtcOptions;\n\t            self._rtcCfg = rtcOptions.rtcCfg;\n\t            self._rtcCfg2 = rtcOptions.rtcCfg2;\n\t\n\t            self.sessId = rtcOptions.sessId;\n\t            self.rtcId = \"Channel_webIM\";\n\t\n\t            self._rtKey = self._rtkey = rtcOptions.rtKey || rtcOptions.rtkey;\n\t            self._rtFlag = self._rtflag = rtcOptions.rtFlag || rtcOptions.rtflag;\n\t\n\t            self._WebRTCCfg = rtcOptions.WebRTC;\n\t            self.admtok = rtcOptions.admtok;\n\t            self.tkt = rtcOptions.tkt;\n\t\n\t            self.switchPattern(self.mediaStreamConstaints.audio && self.mediaStreamConstaints.video ? \"VIDEO\" : \"VOICE\");\n\t        } else {\n\t            //\n\t        }\n\t    },\n\t\n\t    switchPattern: function switchPattern(streamType) {\n\t        var self = this;\n\t\n\t        !self._WebRTCCfg && (self.pattern = new CommonPattern({\n\t            callee: self.callee,\n\t\n\t            _p2pConfig: self._p2pConfig,\n\t            _rtcCfg: self._rtcCfg,\n\t            _rtcCfg2: self._rtcCfg2,\n\t\n\t            _rtKey: self._rtKey || self._rtkey,\n\t            _rtFlag: self._rtFlag || self._rtflag,\n\t\n\t            _sessId: self.sessId,\n\t            _rtcId: self.rtcId,\n\t\n\t            webRtc: new WebRTC({\n\t                streamType: streamType,\n\t                onGotLocalStream: self.listener.onGotLocalStream,\n\t                onGotRemoteStream: self.listener.onGotRemoteStream,\n\t                onError: self.listener.onError\n\t            }),\n\t\n\t            api: self.api,\n\t\n\t            onAcceptCall: self.listener && self.listener.onAcceptCall || function () {},\n\t            onRinging: self.listener && self.listener.onRinging || function () {},\n\t            onTermCall: self.listener && self.listener.onTermCall || function () {},\n\t            onOtherUserOpenVoice: self.listener && self.listener.onOtherUserOpenVoice || function () {},\n\t            onOtherUserOpenVideo: self.listener && self.listener.onOtherUserOpenVideo || function () {}\n\t        }));\n\t    }\n\t};\n\t\n\tmodule.exports = function (initConfigs) {\n\t    Util.extend(true, this, _Call, initConfigs || {});\n\t\n\t    this.init();\n\t};\n\n/***/ }),\n\n/***/ 251:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * IQ Message，IM -> CMServer --> IM\n\t */\n\t\n\tvar _util = __webpack_require__(249);\n\tvar _logger = _util.logger;\n\tvar API = __webpack_require__(252);\n\tvar RouteTo = API.RouteTo;\n\t\n\tvar CONFERENCE_XMLNS = \"urn:xmpp:media-conference\";\n\t\n\tvar _RtcHandler = {\n\t    _apiCallbacks: {},\n\t\n\t    imConnection: null,\n\t\n\t    _connectedSid: '',\n\t\n\t    init: function init() {\n\t        var self = this;\n\t\n\t        var _conn = self.imConnection;\n\t\n\t        _conn.registerConfrIQHandler = function () {\n\t            var handleConferenceIQ = function handleConferenceIQ(msginfo) {\n\t                try {\n\t                    self.handleRtcMessage(msginfo);\n\t                } catch (error) {\n\t                    _logger.error(error.stack || error);\n\t                    throw error;\n\t                }\n\t\n\t                return true;\n\t            };\n\t\n\t            _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', \"set\");\n\t            _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', \"get\");\n\t\n\t            _logger.warn(\"Conference iq handler. registered.\");\n\t        };\n\t    },\n\t\n\t    handleRtcMessage: function handleRtcMessage(msginfo) {\n\t        var self = this;\n\t\n\t        var id = msginfo.getAttribute('id');\n\t        var from = msginfo.getAttribute('from') || '';\n\t\n\t        // remove resource\n\t        from.lastIndexOf(\"/\") >= 0 && (from = from.substring(0, from.lastIndexOf(\"/\")));\n\t\n\t        var rtkey = msginfo.getElementsByTagName('rtkey')[0].innerHTML;\n\t\n\t        var fromSessionId = msginfo.getElementsByTagName('sid')[0].innerHTML;\n\t\n\t        (self._fromSessionID || (self._fromSessionID = {}))[from] = fromSessionId;\n\t\n\t        var contentTags = msginfo.getElementsByTagName('content');\n\t\n\t        var contentString = contentTags[0].innerHTML;\n\t\n\t        var content = _util.parseJSON(contentString);\n\t\n\t        var rtcOptions = content;\n\t\n\t        var streamType = msginfo.getElementsByTagName('stream_type')[0].innerHTML; //VOICE, VIDEO\n\t\n\t        if (streamType == \"\") {\n\t            streamType = \"VOICE\";\n\t        }\n\t\n\t        rtcOptions.streamType = streamType;\n\t\n\t        if (rtcOptions.op == 102) {\n\t            self.singalStreamType = streamType;\n\t        }\n\t\n\t        var tsxId = content.tsxId;\n\t\n\t        self.ctx = content.ctx;\n\t\n\t        _logger.debug(\"Recv [op = \" + rtcOptions.op + \"] [tsxId=\" + tsxId + \"]\\r\\n json :\", msginfo);\n\t\n\t        //if a->b already, c->a/b should be termiated with 'busy' reason\n\t        if (from.indexOf(\"@\") >= 0) {\n\t            if (self._connectedSid == '' && rtcOptions.op == 102) {\n\t                self._connectedSid = fromSessionId;\n\t            } else {\n\t                if (self._connectedSid != fromSessionId) {\n\t                    _logger.debug(\"Error recv [op = \" + rtcOptions.op + \"] [tsxId=\" + tsxId + \"]. caused by _connectedSid != fromSessionId :\", self._connectedSid, fromSessionId);\n\t\n\t                    //onInitC\n\t                    if (rtcOptions.op == 102) {\n\t                        var rt = new RouteTo({\n\t                            to: from,\n\t                            rtKey: rtkey,\n\t                            sid: fromSessionId,\n\t                            success: function success(result) {\n\t                                _logger.debug(\"iq to server success\", result);\n\t                            },\n\t                            fail: function fail(error) {\n\t                                _logger.debug(\"iq to server error\", error);\n\t                                self.onError(error);\n\t                            }\n\t                        });\n\t\n\t                        var options = {\n\t                            data: {\n\t                                op: 107,\n\t                                sessId: rtcOptions.sessId,\n\t                                rtcId: rtcOptions.rtcId,\n\t                                reason: 'busy'\n\t\n\t                            },\n\t                            reason: 'busy'\n\t                        };\n\t                        self.sendRtcMessage(rt, options);\n\t                    }\n\t                    return;\n\t                }\n\t            }\n\t        }\n\t\n\t        //onTermC\n\t        if (rtcOptions.op == 107) {\n\t            self._connectedSid = '';\n\t            self._fromSessionID = {};\n\t\n\t            var reasonObj = msginfo.getElementsByTagName('reason');\n\t            //var endReason = msginfo.getElementsByTagName('reason')[0].innerHTML;\n\t            reasonObj && reasonObj.length > 0 && (rtcOptions.reason = reasonObj[0].innerHTML);\n\t        }\n\t\n\t        if (rtcOptions.sdp) {\n\t            if (typeof rtcOptions.sdp === 'string') {\n\t                rtcOptions.sdp = _util.parseJSON(rtcOptions.sdp);\n\t            }\n\t            rtcOptions.sdp.type && (rtcOptions.sdp.type = rtcOptions.sdp.type.toLowerCase());\n\t        }\n\t        if (rtcOptions.cands) {\n\t            if (typeof rtcOptions.cands === 'string') {\n\t                rtcOptions.cands = _util.parseJSON(rtcOptions.cands);\n\t            }\n\t\n\t            for (var i = 0; i < rtcOptions.cands.length; i++) {\n\t                typeof rtcOptions.cands[i] === 'string' && (rtcOptions.cands[i] = _util.parseJSON(rtcOptions.cands[i]));\n\t\n\t                rtcOptions.cands[i].sdpMLineIndex = rtcOptions.cands[i].mlineindex;\n\t                rtcOptions.cands[i].sdpMid = rtcOptions.cands[i].mid;\n\t\n\t                delete rtcOptions.cands[i].mlineindex;\n\t                delete rtcOptions.cands[i].mid;\n\t            }\n\t        }\n\t\n\t        rtcOptions.rtcCfg && typeof rtcOptions.rtcCfg === 'string' && (rtcOptions.rtcCfg = _util.parseJSON(rtcOptions.rtcCfg));\n\t        rtcOptions.rtcCfg2 && typeof rtcOptions.rtcCfg2 === 'string' && (rtcOptions.rtcCfg2 = _util.parseJSON(rtcOptions.rtcCfg2));\n\t        rtcOptions.WebRTC && typeof rtcOptions.WebRTC === 'string' && (rtcOptions.WebRTC = _util.parseJSON(rtcOptions.WebRTC));\n\t\n\t        if (tsxId && self._apiCallbacks[tsxId]) {\n\t            try {\n\t                self._apiCallbacks[tsxId].callback && self._apiCallbacks[tsxId].callback(from, rtcOptions);\n\t            } catch (err) {\n\t                throw err;\n\t            } finally {\n\t                delete self._apiCallbacks[tsxId];\n\t            }\n\t        } else {\n\t            self.onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId);\n\t        }\n\t\n\t        return true;\n\t    },\n\t\n\t    onRecvRtcMessage: function onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId) {\n\t        _logger.debug(' form : ' + from + \" \\r\\n json :\" + _util.stringifyJSON(rtcJSON));\n\t    },\n\t\n\t    convertRtcOptions: function convertRtcOptions(options) {\n\t        var sdp = options.data.sdp;\n\t        if (sdp) {\n\t            var _sdp = {\n\t                type: sdp.type,\n\t                sdp: sdp.sdp\n\t            };\n\t\n\t            sdp = _sdp;\n\t\n\t            sdp.type = sdp.type.toUpperCase();\n\t            sdp = _util.stringifyJSON(sdp);\n\t\n\t            options.data.sdp = sdp;\n\t        }\n\t\n\t        var cands = options.data.cands;\n\t\n\t        if (cands) {\n\t            if (_util.isArray(cands)) {} else {\n\t                var _cands = [];\n\t                _cands.push(cands);\n\t                cands = _cands;\n\t            }\n\t\n\t            for (var i in cands) {\n\t                if (cands[i] instanceof RTCIceCandidate) {\n\t                    var _cand = {\n\t                        type: \"candidate\",\n\t                        candidate: cands[i].candidate,\n\t                        mlineindex: cands[i].sdpMLineIndex,\n\t                        mid: cands[i].sdpMid\n\t                        // seq: i\n\t                    };\n\t\n\t                    cands[i] = _util.stringifyJSON(_cand);\n\t                }\n\t            }\n\t\n\t            options.data.cands = cands;\n\t        } else {\n\t            // options.data.cands = [];\n\t        }\n\t\n\t        var rtcCfg = options.data.rtcCfg;\n\t        if (rtcCfg) {\n\t            typeof rtcCfg !== 'string' && (options.data.rtcCfg = _util.stringifyJSON(rtcCfg));\n\t        }\n\t\n\t        var _webrtc = options.data.WebRTC;\n\t        if (_webrtc) {\n\t            typeof _webrtc !== 'string' && (options.data.WebRTC = _util.stringifyJSON(_webrtc));\n\t        }\n\t    },\n\t\n\t    /**\n\t     * rt: { id: , to: , rtKey: , rtflag: , sid: , tsxId: , type: , }\n\t     *\n\t     * rtcOptions: { data : { op : 'reqP2P', video : 1, audio : 1, peer :\n\t     * curChatUserId, //appKey + \"_\" + curChatUserId + \"@\" + this.domain, } }\n\t     *\n\t     */\n\t    sendRtcMessage: function sendRtcMessage(rt, options, callback) {\n\t        var self = this;\n\t\n\t        var _conn = self.imConnection;\n\t\n\t        var tsxId = rt.tsxId || _conn.getUniqueId();\n\t\n\t        var to = rt.to || _conn.domain;\n\t\n\t        var sid = rt.sid || self._fromSessionID && self._fromSessionID[to];\n\t        //sid = sid || ((self._fromSessionID || (self._fromSessionID = {}))[to] = _conn.getUniqueId(\"CONFR_\"));\n\t        sid = sid || _conn.getUniqueId(\"CONFR_\");\n\t        (self._fromSessionID || (self._fromSessionID = {}))[to] = sid;\n\t\n\t        if (to.indexOf(\"@\") >= 0) {\n\t            if (self._connectedSid == '' && options.data.op == 102) {\n\t                self._connectedSid = sid;\n\t            }\n\t        }\n\t        var rtKey = rt.rtKey || rt.rtkey;\n\t        // rtKey && delete rt.rtKey;\n\t        rtKey || (rtKey = \"\");\n\t\n\t        var rtflag = rt.rtflag;\n\t        // rtflag && delete rt.rtflag;\n\t        rtflag || (rtflag = 1);\n\t\n\t        options.data || (options.data = {});\n\t        options.data.tsxId = tsxId;\n\t\n\t        self.ctx && (options.data.ctx = self.ctx);\n\t        self.convertRtcOptions(options);\n\t\n\t        var streamType = options.streamType || self.singalStreamType || \"VIDEO\"; // \"VIDEO\"; //VOICE, VIDEO\n\t        if (options.data.op == 102) {\n\t            self.singalStreamType = streamType;\n\t        }\n\t\n\t        var id = rt.id || _conn.getUniqueId(\"CONFR_\");\n\t        var iq = $iq({\n\t            // xmlns: CONFERENCE_XMLNS,\n\t            id: id,\n\t            to: to,\n\t            from: _conn.context.jid,\n\t            type: rt.type || \"get\"\n\t        }).c(\"query\", {\n\t            xmlns: CONFERENCE_XMLNS\n\t        }).c(\"MediaReqExt\").c('rtkey').t(rtKey).up().c('rtflag').t(rtflag).up().c('stream_type').t(streamType).up().c('sid').t(sid).up().c('content').t(_util.stringifyJSON(options.data));\n\t\n\t        if (options.data.op == 107 && options.reason) {\n\t            iq.up().c('reason').t(options.reason);\n\t        }\n\t        _logger.debug(\"Send [op = \" + options.data.op + \"] : \\r\\n\", iq.tree());\n\t\n\t        callback && (self._apiCallbacks[tsxId] = {\n\t            callback: callback\n\t        });\n\t\n\t        var completeFn = function (result) {\n\t            rt.success(result);\n\t        } || function (result) {\n\t            _logger.debug(\"send result. op:\" + options.data.op + \".\", result);\n\t        };\n\t\n\t        var errFn = function (ele) {\n\t            rt.fail(ele);\n\t        } || function (ele) {\n\t            _logger.debug(ele);\n\t        };\n\t\n\t        _conn.context.stropheConn.sendIQ(iq.tree(), completeFn, errFn);\n\t\n\t        //onTermC\n\t        if (options.data.op == 107 && self._connectedSid) {\n\t            if (!rt.sid || self._connectedSid == rt.sid) {\n\t                self._connectedSid = '';\n\t                self._fromSessionID = {};\n\t            }\n\t        }\n\t    }\n\t};\n\t\n\tvar RTCIQHandler = function RTCIQHandler(initConfigs) {\n\t    _util.extend(true, this, _RtcHandler, initConfigs || {});\n\t\n\t    this.init();\n\t};\n\tmodule.exports = RTCIQHandler;\n\n/***/ }),\n\n/***/ 252:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * API\n\t */\n\tvar _util = __webpack_require__(249);\n\tvar _logger = _util.logger;\n\t\n\tvar _RouteTo = {\n\t    // to : null,\n\t    // rtKey: null,\n\t    rtFlag: 1,\n\t\n\t    success: function success(result) {},\n\t    fail: function fail(error) {}\n\t};\n\t\n\tvar RouteTo = function RouteTo(extendCfg) {\n\t    if (this instanceof RouteTo) {\n\t        var self = this;\n\t        _util.extend(true, self, _RouteTo, extendCfg || {});\n\t    } else {\n\t        var sub = function sub(extendCfg) {\n\t            var self = this;\n\t            _util.extend(true, self, extendCfg || {});\n\t        };\n\t\n\t        _util.extend(true, sub.prototype, _RouteTo, extendCfg || {});\n\t\n\t        return sub;\n\t    }\n\t};\n\texports.RouteTo = RouteTo;\n\t\n\tvar _clazz = {\n\t    imConnection: null,\n\t    // webRtc: null,\n\t\n\t    rtcHandler: null,\n\t\n\t    events: {\n\t        '0': 'onReqP2P',\n\t        '1': 'onNewCfr',\n\t        '2': 'onDelCfr',\n\t        '3': 'onReqTkt',\n\t\n\t        '100': 'onPing',\n\t        '101': 'onPong',\n\t        '102': 'onInitC',\n\t        '103': 'onReqC',\n\t        '104': 'onAcptC',\n\t        '105': 'onTcklC',\n\t        '106': 'onAnsC',\n\t        '107': 'onTermC',\n\t\n\t        // '200' : 'onEnter',\n\t        // '201' : 'onExit',\n\t        // '202' : 'onInvite',\n\t        // '203' : 'onGetMems',\n\t\n\t        // '205' : 'onSubC',\n\t        // '206' : 'onUsubC',\n\t\n\t        '300': 'onEvEnter',\n\t        '301': 'onEvExit',\n\t        '302': 'onEvPub',\n\t        '303': 'onEvUnpub',\n\t        '304': 'onEvMems',\n\t        '204': 'onEvClose',\n\t        '400': 'onStreamControl',\n\t        '401': 'onEvJoin',\n\t\n\t        'onServerError': 'onServerError'\n\t    },\n\t\n\t    register: function register(listener) {\n\t        if ((typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) === \"object\") {\n\t            for (var event in listener) {\n\t                this.bind(event, listener[event]);\n\t            }\n\t        }\n\t    },\n\t\n\t    bind: function bind(event, func) {\n\t        var self = this;\n\t\n\t        var onFunc;\n\t        if (onFunc = self.events[event]) {\n\t            self[onFunc] = func;\n\t        } else {\n\t            onFunc = self.events[event] = 'on_' + event;\n\t            self[onFunc] = func;\n\t        }\n\t    },\n\t\n\t    jid: function jid(shortUserName) {\n\t        if (/^.+#.+_.+@.+$/g.test(shortUserName)) {\n\t            return shortUserName;\n\t        }\n\t        // if (shortUserName.indexOf(this.imConnection.context.appKey) >= 0) {\n\t        //     return shortUserName;\n\t        // }\n\t        return this.imConnection.context.appKey + \"_\" + shortUserName + \"@\" + this.imConnection.domain;\n\t    },\n\t\n\t    /**\n\t     * ReqP2P 0\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param video\n\t     *            1 0\n\t     * @param audio\n\t     *            1 0\n\t     * @param peer\n\t     *\n\t     */\n\t    reqP2P: function reqP2P(rt, video, audio, peer, callback) {\n\t        _logger.debug(\"req p2p ...\");\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 0,\n\t                video: video,\n\t                audio: audio,\n\t                peer: peer // appKey + \"_\" + curChatUserId + \"@\" + this.domain,\n\t            }\n\t        };\n\t\n\t        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * NewCfr 1\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param reqTkt\n\t     *            1 null\n\t     * @param password\n\t     *            string null\n\t     *\n\t     */\n\t    newCfr: function newCfr(rt, reqTkt, password, callback) {\n\t        _logger.debug(\"newCfr ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 1\n\t            }\n\t        };\n\t\n\t        reqTkt && (rtcOptions.data.reqTkt = reqTkt);\n\t        password && (rtcOptions.data.password = password);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * Enter 200\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param WebRTCId\n\t     * @param reqMembers !=\n\t     *            0 members\n\t     * @param tkt\n\t     * @param nonce\n\t     * @param digest\n\t     *\n\t     */\n\t    enter: function enter(rt, WebRTCId, reqMembers, tkt, nonce, digest, callback) {\n\t        _logger.debug(\"enter ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 200\n\t            }\n\t        };\n\t\n\t        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\t        reqMembers && (rtcOptions.data.reqMembers = reqMembers);\n\t        tkt && (rtcOptions.data.tkt = tkt);\n\t        nonce && (rtcOptions.data.nonce = nonce);\n\t        digest && (rtcOptions.data.digest = digest);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * Ping 100\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     *\n\t     */\n\t    ping: function ping(rt, sessId, callback) {\n\t        _logger.debug(\"ping ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 100\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * 通知对方 我已经关闭/打开 麦卡，摄像头\n\t     *\n\t     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)\n\t     *\n\t     *\n\t     * @param rt\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param controlType\n\t     * @param callback\n\t     */\n\t    streamControl: function streamControl(rt, sessId, rtcId, controlType, callback) {\n\t        _logger.debug(\"streamControl ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 400\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        typeof controlType !== 'undefined' && controlType != null && (rtcOptions.data.controlType = controlType);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * ReqTkt 3\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param WebRTCId\n\t     * @param success(from,\n\t     *            rtcOptions)\n\t     *\n\t     */\n\t    reqTkt: function reqTkt(rt, WebRTCId, callback) {\n\t        _logger.debug(\"reqTkt ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 3\n\t            }\n\t        };\n\t\n\t        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * InitC 102\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param WebRTCId\n\t     * @param tkt\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param pubS\n\t     *            {name: streamName, video:1, audio:1, type: 0}\n\t     * @param subS\n\t     *            {memId: , rtcId: }\n\t     * @param sdp\n\t     *            sdp:sdpstring\n\t     * @param cands [ ]\n\t     *\n\t     */\n\t    initC: function initC(rt, streamType, WebRTCId, tkt, sessId, rtcId, pubS, subS, sdp, cands, rtcCfg, WebRTC, callback) {\n\t        _logger.debug(\"initC ...\");\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 102\n\t            }\n\t        };\n\t\n\t        rtcOptions.streamType = streamType || \"VIDEO\";\n\t\n\t        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\t        tkt && (rtcOptions.data.tkt = tkt);\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        pubS && (rtcOptions.data.pubS = pubS);\n\t        subS && (rtcOptions.data.subS = subS);\n\t        sdp && (rtcOptions.data.sdp = sdp);\n\t        cands && (rtcOptions.data.cands = cands);\n\t        rtcCfg && (rtcOptions.data.rtcCfg = rtcCfg);\n\t        WebRTC && (rtcOptions.data.WebRTC = WebRTC);\n\t\n\t        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * TcklC 105\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param cands\n\t     * @param success(from,\n\t     *            rtcOptions)\n\t     *\n\t     */\n\t    tcklC: function tcklC(rt, sessId, rtcId, sdp, cands, callback) {\n\t        _logger.debug(\"tcklC ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 105\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        sdp && (rtcOptions.data.sdp = sdp);\n\t        cands && (rtcOptions.data.cands = cands);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * AnsC 106\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param sdp\n\t     * @param cands\n\t     *\n\t     */\n\t    ansC: function ansC(rt, sessId, rtcId, sdp, cands, callback, enableVoice, enableVideo) {\n\t        _logger.debug(\"ansC ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 106\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        sdp && (rtcOptions.data.sdp = sdp);\n\t        cands && (rtcOptions.data.cands = cands);\n\t\n\t        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);\n\t        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);\n\t\n\t        // rtcOptions.data.enableVoice = false;\n\t        // rtcOptions.data.enableVideo = false;\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * AcptC 104\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param sdp\n\t     * @param ans\n\t     *            1\n\t     *\n\t     */\n\t    acptC: function acptC(rt, sessId, rtcId, sdp, cands, ans, callback, enableVoice, enableVideo) {\n\t        _logger.debug(\"acptC ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 104\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        sdp && (rtcOptions.data.sdp = sdp);\n\t        cands && (rtcOptions.data.cands = cands);\n\t        ans && (rtcOptions.data.ans = ans);\n\t\n\t        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);\n\t        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);\n\t\n\t        // rtcOptions.data.enableVoice = false;\n\t        // rtcOptions.data.enableVideo = false;\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * GetMems 203\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param WebRTCId\n\t     * @param sessId\n\t     * @param success(from,\n\t     *            rtcOptions)\n\t     *\n\t     */\n\t    getMems: function getMems(rt, WebRTCId, sessId, callback) {\n\t        _logger.debug(\"getMems ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 203\n\t            }\n\t        };\n\t\n\t        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * SubC 205\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param subS\n\t     *            {memId:m001, rtcId:r001}\n\t     *\n\t     */\n\t    subC: function subC(rt, sessId, rtcId, subS, callback) {\n\t        _logger.debug(\"subC ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 205\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        subS && (rtcOptions.data.subS = subS);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * UsubC 206\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     * @param rtcId\n\t     *\n\t     */\n\t    usubC: function usubC(rt, sessId, rtcId, callback) {\n\t        _logger.debug(\"usubC ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 206\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * TermC 107\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param sessId\n\t     * @param rtcId\n\t     * @param reason\n\t     *               \"ok\"      -> 'HANGUP'     \"success\" -> 'HANGUP'   \"timeout\"          -> 'NORESPONSE'\n\t     *               \"decline\" -> 'REJECT'     \"busy\"    -> 'BUSY'     \"failed-transport\" -> 'FAIL'\n\t     *\n\t     */\n\t    termC: function termC(rt, sessId, rtcId, reason, callback) {\n\t        _logger.debug(\"termC ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 107\n\t            }\n\t        };\n\t\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t        rtcId && (rtcOptions.data.rtcId = rtcId);\n\t        reason && (rtcOptions.reason = reason);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * Exit 201\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param WebRTCId\n\t     * @param sessId\n\t     * @param success(from,\n\t     *            rtcOptions)\n\t     *\n\t     */\n\t    exit: function exit(rt, WebRTCId, sessId, callback) {\n\t        _logger.debug(\"exit ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 201\n\t            }\n\t        };\n\t\n\t        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\t        sessId && (rtcOptions.data.sessId = sessId);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    },\n\t\n\t    /**\n\t     * DelCfr 2\n\t     *\n\t     * @param rt\n\t     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n\t     *\n\t     * @param callback(from, rtcOptions)\n\t     *\n\t     *\n\t     * @param WebRTCId\n\t     * @param admtok\n\t     * @param success(from,\n\t     *            rtcOptions)\n\t     *\n\t     */\n\t    delCfr: function delCfr(rt, WebRTCId, admtok, callback) {\n\t        _logger.debug(\"delCfr ...\");\n\t\n\t        var self = this;\n\t\n\t        var rtcOptions = {\n\t            data: {\n\t                op: 2\n\t            }\n\t        };\n\t\n\t        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\t        admtok && (rtcOptions.data.admtok = admtok);\n\t\n\t        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n\t    }\n\t};\n\t\n\texports.Api = function (initConfigs) {\n\t    var self = this;\n\t\n\t    _util.extend(true, this, _clazz, initConfigs || {});\n\t\n\t    function _onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId) {\n\t        if (rtcOptions.result != 0 && self['onServerError']) {\n\t            self['onServerError'].call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);\n\t        } else {\n\t            var onFunction;\n\t\n\t            if (self.events[rtcOptions.op] && (onFunction = self[self.events[rtcOptions.op]])) {\n\t                onFunction.call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);\n\t            } else {\n\t                _logger.info(\"can not handle(recvRtcMessage) the op: \" + rtcOptions.op, rtcOptions);\n\t            }\n\t        }\n\t    }\n\t\n\t    this.rtcHandler.onRecvRtcMessage = _onRecvRtcMessage;\n\t};\n\n/***/ }),\n\n/***/ 253:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * WebRTC\n\t *\n\t *                              A                   |                                       B\n\t *                                                  |\n\t *   1.createMedia:got streamA                      | 1.createMedia:got streamB\n\t *   2.new RTCPeerConnection: APeerConnection       | 2.new RTCPeerConnection: BPeerConnection\n\t *   3.APeerConnection.createOffer:got offerA       |\n\t *      APeerConnection.setLocalDescription(offerA) |\n\t *      send offerA ---> ---> ---> --->        ---> |\n\t *                                                  | ---> 3.got offerA | offerA = new RTCSessionDescription(offerA);\n\t *                                                  | BPeerConnection.setRemoteDescription(offerA)\n\t *                                                  |\n\t *                                                  |\n\t *                                                  | 4.BPeerConnection.createAnswer: got answerB\n\t *                                                  | BPeerConnection.setLocalDescription(answerB)\n\t *                                                  | <---- send answerB\n\t *                                                  | 5.got answerB <--- <--- <--- <---\n\t *                                                  | answerB = new RTCSessionDescription(answerB)\n\t *                                                  |\n\t * APeerConnection.setRemoteDescription(answerB)    |\n\t *                                                  |\n\t * 6.got candidateA ---> --->  ---> --->            | ---> got candidateA\n\t *                                                  | BPeerConnection.addIceCandidate(new RTCIceCandidate(candidateA))\n\t *                                                  |\n\t *                                                  |\n\t *                                                  | got candidateB <--- <--- <--- <---\n\t *                                                  | <--- 6.got candidateB APeerConnection.addIceCandidate(candidateB)\n\t *                                                  |\n\t *                                                  |\n\t *                                                  | 7. APeerConnection.addStream(streamA)\n\t *                                                  | 7.BPeerConnection.addStream(streamB)\n\t *                                                  |\n\t *                              streamA >>>>>>>>>>> |  <<<<< see A\n\t *                              seeB <<<<<<<<<<<    | <<<<< streamB\n\t *                                                  |\n\t *\n\t */\n\tvar _util = __webpack_require__(249);\n\tvar _logger = _util.logger;\n\t\n\tvar _WebrtcStatistics = {\n\t    bytesPrev: null,\n\t    timestampPrev: null,\n\t    sentBytesPrev: null,\n\t    sentTimestampPrev: null,\n\t\n\t    printStats: function printStats(rtcPeerConnection) {\n\t        var self = this;\n\t\n\t        rtcPeerConnection.getStats(null, function (results) {\n\t            self.parseRecvStatistics(results, function (name, value) {\n\t                _logger.info(new Date(), \"RECV \", name, value);\n\t            }, function (name, value) {\n\t                _logger.info(new Date(), \"SEND \", name, value);\n\t            });\n\t        });\n\t    },\n\t\n\t    stopIntervalPrintStats: function stopIntervalPrintStats() {\n\t        var self = this;\n\t\n\t        self._printIntervalId && window.clearInterval(self._printIntervalId);\n\t        self._printIntervalId = null;\n\t    },\n\t\n\t    intervalPrintStats: function intervalPrintStats(rtcPeerConnection, seconds) {},\n\t\n\t    _intervalPrintStats: function _intervalPrintStats(rtcPeerConnection, seconds) {\n\t        var self = this;\n\t\n\t        self._printIntervalId && window.clearInterval(self._printIntervalId);\n\t        self._printIntervalId = window.setInterval(function () {\n\t            self.printStats(rtcPeerConnection);\n\t        }, seconds * 1000);\n\t    },\n\t\n\t    parseRecvStatistics: function parseRecvStatistics(results, callback, callbackSent) {\n\t        var self = this;\n\t\n\t        // calculate video bitrate\n\t        var bitrate;\n\t        var remoteWidth;\n\t        var remoteHeight;\n\t\n\t        var activeCandidatePair = null;\n\t        var remoteCandidate = null;\n\t\n\t        Object.keys(results).forEach(function (result) {\n\t            var report = results[result];\n\t            var now = report.timestamp;\n\t\n\t            if (report.type === 'inboundrtp' && report.mediaType === 'audio') {\n\t                // firefox calculates the bitrate for us\n\t                // https://bugzilla.mozilla.org/show_bug.cgi?id=951496\n\t                bitrate = Math.floor(report.bitrateMean / 1024);\n\t            } else if (report.type === 'ssrc' && report.bytesReceived) {\n\t                if (report.mediaType === 'video') {\n\t                    // remoteWidth = report.googFrameWidthReceived;\n\t                    // remoteHeight = report.googFrameHeightReceived;\n\t                    // // chrome does not so we need to do it ourselves\n\t                    // var bytes = report.bytesReceived;\n\t                    // if (self.timestampPrev) {\n\t                    //     bitrate = 8 * (bytes - self.bytesPrev) / (now - self.timestampPrev);\n\t                    //     bitrate = Math.floor(bitrate);\n\t                    // }\n\t                    // self.bytesPrev = bytes;\n\t                    // self.timestampPrev = now;\n\t                } else {\n\t                    // chrome does not so we need to do it ourselves\n\t                    var bytes = report.bytesReceived;\n\t                    if (self.timestampPrev) {\n\t                        bitrate = 8 * (bytes - self.bytesPrev) / (now - self.timestampPrev);\n\t                        bitrate = Math.floor(bitrate);\n\t                    }\n\t                    self.bytesPrev = bytes;\n\t                    self.timestampPrev = now;\n\t                }\n\t            }\n\t\n\t            if (report.type === 'candidatepair' && report.selected || report.type === 'googCandidatePair' && report.googActiveConnection === 'true') {\n\t                activeCandidatePair = report;\n\t            }\n\t\n\t            if (report.type === 'outboundrtp' && report.mediaType === 'audio') {\n\t                callbackSent('audio Bitrate', Math.floor(report.bitrateMean / 1024) + ' kbps');\n\t            } else if (report.type === 'ssrc' && report.bytesSent && report.googFrameHeightSent) {\n\t                // chrome does not so we need to do it ourselves\n\t                var bytes = report.bytesSent;\n\t                if (self.sentTimestampPrev) {\n\t                    var br = 8 * (bytes - self.sentBytesPrev) / (now - self.sentTimestampPrev);\n\t                    br = Math.floor(br);\n\t                    callbackSent('audio Bitrate', br + ' kbps');\n\t                    callbackSent('audio Size', report.googFrameWidthSent + 'x' + report.googFrameHeightSent);\n\t                }\n\t                self.sentBytesPrev = bytes;\n\t                self.sentTimestampPrev = now;\n\t            }\n\t        });\n\t\n\t        if (activeCandidatePair && activeCandidatePair.remoteCandidateId) {\n\t            remoteCandidate = results[activeCandidatePair.remoteCandidateId];\n\t        }\n\t        if (remoteCandidate && remoteCandidate.ipAddress && remoteCandidate.portNumber) {\n\t            callback('Peer', remoteCandidate.ipAddress + ':' + remoteCandidate.portNumber);\n\t        }\n\t\n\t        callback('audio Bitrate', bitrate + ' kbps');\n\t\n\t        if (remoteHeight) {\n\t            callback('audio Size', remoteWidth + 'x' + remoteHeight);\n\t        }\n\t    }\n\t};\n\t\n\tvar WebrtcStatisticsHelper = function WebrtcStatisticsHelper(cfg) {\n\t    _util.extend(this, _WebrtcStatistics, cfg || {});\n\t};\n\t\n\tvar webrtcStatisticsHelper = new WebrtcStatisticsHelper();\n\t\n\tvar _SDPSection = {\n\t    headerSection: null,\n\t\n\t    audioSection: null,\n\t    videoSection: null,\n\t\n\t    _parseHeaderSection: function _parseHeaderSection(sdp) {\n\t        var index = sdp.indexOf('m=audio');\n\t        if (index >= 0) {\n\t            return sdp.slice(0, index);\n\t        }\n\t\n\t        index = sdp.indexOf('m=video');\n\t        if (index >= 0) {\n\t            return sdp.slice(0, index);\n\t        }\n\t\n\t        return sdp;\n\t    },\n\t\n\t    _parseAudioSection: function _parseAudioSection(sdp) {\n\t        var index = sdp.indexOf('m=audio');\n\t        if (index >= 0) {\n\t            var endIndex = sdp.indexOf('m=video');\n\t            return sdp.slice(index, endIndex < 0 ? sdp.length : endIndex);\n\t        }\n\t    },\n\t\n\t    _parseVideoSection: function _parseVideoSection(sdp) {\n\t        var index = sdp.indexOf('m=video');\n\t        if (index >= 0) {\n\t            return sdp.slice(index);\n\t        }\n\t    },\n\t\n\t    spiltSection: function spiltSection(sdp) {\n\t        var self = this;\n\t\n\t        self.headerSection = self._parseHeaderSection(sdp);\n\t        self.audioSection = self._parseAudioSection(sdp);\n\t        self.videoSection = self._parseVideoSection(sdp);\n\t    },\n\t\n\t    removeSSRC: function removeSSRC(section) {\n\t        var arr = [];\n\t\n\t        var _arr = section.split(/a=ssrc:[^\\n]+/g);\n\t        for (var i = 0; i < _arr.length; i++) {\n\t            _arr[i] != '\\n' && arr.push(_arr[i]);\n\t        }\n\t        // arr.push('');\n\t\n\t        return arr.join('\\n');\n\t    },\n\t\n\t    removeField_msid: function removeField_msid(section) {\n\t        var arr = [];\n\t\n\t        var _arr = section.split(/a=msid:[^\\n]+/g);\n\t        for (var i = 0; i < _arr.length; i++) {\n\t            _arr[i] != '\\n' && arr.push(_arr[i]);\n\t        }\n\t        // arr.push('');\n\t\n\t        section = arr.join('\\n');\n\t        arr = [];\n\t\n\t        _arr = section.split(/[\\n]+/g);\n\t        for (var i = 0; i < _arr.length; i++) {\n\t            _arr[i] != '\\n' && arr.push(_arr[i]);\n\t        }\n\t\n\t        return arr.join('\\n');\n\t    },\n\t\n\t    updateHeaderMsidSemantic: function updateHeaderMsidSemantic(wms) {\n\t\n\t        var self = this;\n\t\n\t        var line = \"a=msid-semantic: WMS \" + wms;\n\t\n\t        var _arr = self.headerSection.split(/a=msid\\-semantic: WMS.*/g);\n\t        var arr = [];\n\t        switch (_arr.length) {\n\t            case 1:\n\t                arr.push(_arr[0]);\n\t                break;\n\t            case 2:\n\t                arr.push(_arr[0]);\n\t                arr.push(line);\n\t                arr.push('\\n');\n\t                break;\n\t            case 3:\n\t                arr.push(_arr[0]);\n\t                arr.push(line);\n\t                arr.push('\\n');\n\t                arr.push(_arr[2]);\n\t                arr.push('\\n');\n\t                break;\n\t        }\n\t\n\t        return self.headerSection = arr.join('');\n\t    },\n\t\n\t    updateAudioSSRCSection: function updateAudioSSRCSection(ssrc, cname, msid, label) {\n\t        var self = this;\n\t\n\t        self.audioSection && (self.audioSection = self.removeSSRC(self.audioSection));\n\t        self.audioSection && (self.audioSection = self.removeField_msid(self.audioSection));\n\t        self.audioSection && (self.audioSection = self.audioSection + self.ssrcSection(ssrc, cname, msid, label));\n\t    },\n\t\n\t    updateVideoSSRCSection: function updateVideoSSRCSection(ssrc, cname, msid, label) {\n\t        var self = this;\n\t\n\t        self.videoSection && (self.videoSection = self.removeSSRC(self.videoSection));\n\t        self.videoSection && (self.videoSection = self.removeField_msid(self.videoSection));\n\t        self.videoSection && (self.videoSection = self.videoSection + self.ssrcSection(ssrc, cname, msid, label));\n\t    },\n\t\n\t    getUpdatedSDP: function getUpdatedSDP() {\n\t        var self = this;\n\t\n\t        var sdp = \"\";\n\t\n\t        self.headerSection && (sdp += self.headerSection);\n\t        self.audioSection && (sdp += self.audioSection);\n\t        self.videoSection && (sdp += self.videoSection);\n\t\n\t        return sdp;\n\t    },\n\t\n\t    parseMsidSemantic: function parseMsidSemantic(header) {\n\t        var self = this;\n\t\n\t        var regexp = /a=msid\\-semantic:\\s*WMS (\\S+)/ig;\n\t        var arr = self._parseLine(header, regexp);\n\t\n\t        arr && arr.length == 2 && (self.msidSemantic = {\n\t            line: arr[0],\n\t            WMS: arr[1]\n\t        });\n\t\n\t        return self.msidSemantic;\n\t    },\n\t\n\t    ssrcSection: function ssrcSection(ssrc, cname, msid, label) {\n\t        var lines = ['a=ssrc:' + ssrc + ' cname:' + cname, 'a=ssrc:' + ssrc + ' msid:' + msid + ' ' + label, 'a=ssrc:' + ssrc + ' mslabel:' + msid, 'a=ssrc:' + ssrc + ' label:' + label, ''];\n\t\n\t        return lines.join('\\n');\n\t    },\n\t\n\t    parseSSRC: function parseSSRC(section) {\n\t        var self = this;\n\t\n\t        var regexp = new RegExp(\"a=(ssrc):(\\\\d+) (\\\\S+):(\\\\S+)\", \"ig\");\n\t\n\t        var arr = self._parseLine(section, regexp);\n\t        if (arr) {\n\t            var ssrc = {\n\t                lines: [],\n\t                updateSSRCSection: self.ssrcSection\n\t            };\n\t\n\t            for (var i = 0; i < arr.length; i++) {\n\t                var e = arr[i];\n\t                if (e.indexOf(\"a=ssrc\") >= 0) {\n\t                    ssrc.lines.push(e);\n\t                } else {\n\t                    switch (e) {\n\t                        case 'ssrc':\n\t                        case 'cname':\n\t                        case 'msid':\n\t                        case 'mslabel':\n\t                        case 'label':\n\t                            ssrc[e] = arr[++i];\n\t                    }\n\t                }\n\t            }\n\t\n\t            return ssrc;\n\t        }\n\t    },\n\t\n\t    _parseLine: function _parseLine(str, regexp) {\n\t        var arr = [];\n\t\n\t        var _arr;\n\t        while ((_arr = regexp.exec(str)) != null) {\n\t            for (var i = 0; i < _arr.length; i++) {\n\t                arr.push(_arr[i]);\n\t            }\n\t        }\n\t\n\t        if (arr.length > 0) {\n\t            return arr;\n\t        }\n\t    }\n\t};\n\t\n\tvar SDPSection = function SDPSection(sdp) {\n\t    _util.extend(this, _SDPSection);\n\t    this.spiltSection(sdp);\n\t};\n\t\n\t/**\n\t * Abstract\n\t */\n\tvar _WebRTC = {\n\t    streamType: \"VIDEO\", // VIDEO or VOICE\n\t\n\t    mediaStreamConstaints: {\n\t        audio: true,\n\t        video: true\n\t    },\n\t\n\t    localStream: null,\n\t    rtcPeerConnection: null,\n\t\n\t    offerOptions: {\n\t        offerToReceiveAudio: 1,\n\t        offerToReceiveVideo: 1\n\t    },\n\t\n\t    createMedia: function createMedia(constaints, onGotStream) {\n\t        var self = this;\n\t\n\t        if (constaints && typeof constaints === \"function\") {\n\t            onGotStream = constaints;\n\t            constaints = null;\n\t        }\n\t\n\t        _logger.debug('[WebRTC-API] begin create media ......');\n\t\n\t        function gotStream(stream) {\n\t            _logger.debug('[WebRTC-API] got local stream');\n\t\n\t            self.localStream = stream;\n\t\n\t            var videoTracks = self.localStream.getVideoTracks();\n\t            var audioTracks = self.localStream.getAudioTracks();\n\t\n\t            if (videoTracks.length > 0) {\n\t                _logger.debug('[WebRTC-API] Using video device: ' + videoTracks[0].label);\n\t            }\n\t            if (audioTracks.length > 0) {\n\t                _logger.debug('[WebRTC-API] Using audio device: ' + audioTracks[0].label);\n\t            }\n\t\n\t            onGotStream ? onGotStream(self, stream, self.streamType) : self.onGotStream(stream, self.streamType);\n\t        }\n\t\n\t        return navigator.mediaDevices.getUserMedia(constaints || self.mediaStreamConstaints).then(gotStream).then(self.onCreateMedia).catch(function (e) {\n\t            _logger.debug('[WebRTC-API] getUserMedia() error: ', e);\n\t            self.onError(e);\n\t        });\n\t    },\n\t\n\t    setLocalVideoSrcObject: function setLocalVideoSrcObject(stream) {\n\t        this.onGotLocalStream(stream, this.streamType);\n\t        _logger.debug('[WebRTC-API] you can see yourself !');\n\t    },\n\t\n\t    createRtcPeerConnection: function createRtcPeerConnection(iceServerConfig) {\n\t        _logger.debug('[WebRTC-API] begin create RtcPeerConnection ......');\n\t\n\t        var self = this;\n\t\n\t        // if (iceServerConfig && iceServerConfig.iceServers) {\n\t        // } else {\n\t        //     iceServerConfig = null;\n\t        // }\n\t\n\t        if (iceServerConfig) {\n\t            //reduce icecandidate number:add default value\n\t            !iceServerConfig.iceServers && (iceServerConfig.iceServers = []);\n\t\n\t            iceServerConfig.rtcpMuxPolicy = \"require\";\n\t            iceServerConfig.bundlePolicy = \"max-bundle\";\n\t\n\t            //iceServerConfig.iceTransportPolicy = 'relay';\n\t            if (iceServerConfig.relayOnly) {\n\t                iceServerConfig.iceTransportPolicy = 'relay';\n\t            }\n\t        } else {\n\t            iceServerConfig = null;\n\t        }\n\t        _logger.debug('[WebRTC-API] RtcPeerConnection config:', iceServerConfig);\n\t\n\t        self.startTime = window.performance.now();\n\t\n\t        var rtcPeerConnection = self.rtcPeerConnection = new RTCPeerConnection(iceServerConfig);\n\t        _logger.debug('[WebRTC-API] Created local peer connection object', rtcPeerConnection);\n\t\n\t        rtcPeerConnection.onicecandidate = function (event) {\n\t            //reduce icecandidate number: don't deal with tcp, udp only\n\t            if (event.type == \"icecandidate\" && (event.candidate == null || / tcp /.test(event.candidate.candidate))) {\n\t                return;\n\t            }\n\t            self.onIceCandidate(event);\n\t        };\n\t\n\t        rtcPeerConnection.onicestatechange = function (event) {\n\t            self.onIceStateChange(event);\n\t        };\n\t\n\t        rtcPeerConnection.oniceconnectionstatechange = function (event) {\n\t            self.onIceStateChange(event);\n\t\n\t            if (\"connected\" == event.target.iceConnectionState) {\n\t                webrtcStatisticsHelper.intervalPrintStats(rtcPeerConnection, 1);\n\t            }\n\t\n\t            if (\"closed\" == event.target.iceConnectionState) {\n\t                webrtcStatisticsHelper.stopIntervalPrintStats();\n\t            }\n\t        };\n\t\n\t        rtcPeerConnection.onaddstream = function (event) {\n\t            self._onGotRemoteStream(event);\n\t        };\n\t    },\n\t\n\t    _uploadLocalStream: function _uploadLocalStream() {\n\t        this.rtcPeerConnection.addStream(this.localStream);\n\t        _logger.debug('[WebRTC-API] Added local stream to RtcPeerConnection');\n\t    },\n\t\n\t    createOffer: function createOffer(onCreateOfferSuccess, onCreateOfferError) {\n\t        var self = this;\n\t\n\t        self._uploadLocalStream();\n\t\n\t        _logger.debug('[WebRTC-API] createOffer start...');\n\t\n\t        return self.rtcPeerConnection.createOffer(self.offerOptions).then(function (desc) {\n\t            self.offerDescription = desc;\n\t\n\t            _logger.debug('[WebRTC-API] Offer '); //_logger.debug('from \\n' + desc.sdp);\n\t            _logger.debug('[WebRTC-API] setLocalDescription start');\n\t\n\t            self.rtcPeerConnection.setLocalDescription(desc).then(self.onSetLocalSessionDescriptionSuccess, self.onSetSessionDescriptionError).then(function () {\n\t                (onCreateOfferSuccess || self.onCreateOfferSuccess)(desc);\n\t            });\n\t        }, onCreateOfferError || self.onCreateSessionDescriptionError);\n\t    },\n\t\n\t    createPRAnswer: function createPRAnswer(onCreatePRAnswerSuccess, onCreatePRAnswerError) {\n\t        var self = this;\n\t\n\t        _logger.info(' createPRAnswer start');\n\t        // Since the 'remote' side has no media stream we need\n\t        // to pass in the right constraints in order for it to\n\t        // accept the incoming offer of audio and video.\n\t        return self.rtcPeerConnection.createAnswer().then(function (desc) {\n\t            _logger.debug('[WebRTC-API] _____________PRAnswer ', desc.sdp); //_logger.debug('from :\\n' + desc.sdp);\n\t\n\t            desc.type = \"pranswer\";\n\t            desc.sdp = desc.sdp.replace(/a=recvonly/g, 'a=inactive');\n\t\n\t            self.prAnswerDescription = desc;\n\t\n\t            _logger.debug('[WebRTC-API] inactive PRAnswer ', desc.sdp); //_logger.debug('from :\\n' + desc.sdp);\n\t            _logger.debug('[WebRTC-API] setLocalDescription start');\n\t\n\t            self.rtcPeerConnection.setLocalDescription(desc).then(self.onSetLocalSuccess, self.onSetSessionDescriptionError).then(function () {\n\t                var sdpSection = new SDPSection(desc.sdp);\n\t                sdpSection.updateHeaderMsidSemantic(\"MS_0000\");\n\t                sdpSection.updateAudioSSRCSection(1000, \"CHROME0000\", \"MS_0000\", \"LABEL_AUDIO_1000\");\n\t                sdpSection.updateVideoSSRCSection(2000, \"CHROME0000\", \"MS_0000\", \"LABEL_VIDEO_2000\");\n\t\n\t                desc.sdp = sdpSection.getUpdatedSDP();\n\t\n\t                _logger.debug('[WebRTC-API] Send PRAnswer ', desc.sdp); //_logger.debug('from :\\n' + desc.sdp);\n\t\n\t                (onCreatePRAnswerSuccess || self.onCreatePRAnswerSuccess)(desc);\n\t            });\n\t        }, onCreatePRAnswerError || self.onCreateSessionDescriptionError);\n\t    },\n\t\n\t    createAnswer: function createAnswer(onCreateAnswerSuccess, onCreateAnswerError) {\n\t        var self = this;\n\t\n\t        self._uploadLocalStream();\n\t\n\t        _logger.info('[WebRTC-API] createAnswer start');\n\t        // Since the 'remote' side has no media stream we need\n\t        // to pass in the right constraints in order for it to\n\t        // accept the incoming offer of audio and video.\n\t        return self.rtcPeerConnection.createAnswer().then(function (desc) {\n\t            _logger.debug('[WebRTC-API] _____________________Answer ', desc.sdp); //_logger.debug('from :\\n' + desc.sdp);\n\t\n\t            desc.type = 'answer';\n\t\n\t            if (WebIM.WebRTC.supportPRAnswer) {\n\t                var sdpSection = new SDPSection(desc.sdp);\n\t                var ms = sdpSection.parseMsidSemantic(sdpSection.headerSection);\n\t                if (ms.WMS == '*') {\n\t                    sdpSection.updateHeaderMsidSemantic(ms.WMS = \"MS_0000\");\n\t                }\n\t                var audioSSRC = sdpSection.parseSSRC(sdpSection.audioSection);\n\t                var videoSSRC = sdpSection.parseSSRC(sdpSection.videoSection);\n\t\n\t                sdpSection.updateAudioSSRCSection(1000, \"CHROME0000\", ms.WMS, audioSSRC.label || \"LABEL_AUDIO_1000\");\n\t                if (videoSSRC) {\n\t                    sdpSection.updateVideoSSRCSection(2000, \"CHROME0000\", ms.WMS, videoSSRC.label || \"LABEL_VIDEO_2000\");\n\t                }\n\t                // mslabel cname\n\t\n\t                desc.sdp = sdpSection.getUpdatedSDP();\n\t            }\n\t\n\t            self.answerDescription = desc;\n\t\n\t            _logger.debug('[WebRTC-API] Answer ', desc.sdp); //_logger.debug('from :\\n' + desc.sdp);\n\t            _logger.debug('[WebRTC-API] setLocalDescription start');\n\t\n\t            self.rtcPeerConnection.setLocalDescription(desc).then(self.onSetLocalSuccess, self.onSetSessionDescriptionError).then(function () {\n\t                if (WebIM.WebRTC.supportPRAnswer) {\n\t                    var sdpSection = new SDPSection(desc.sdp);\n\t\n\t                    sdpSection.updateHeaderMsidSemantic(\"MS_0000\");\n\t                    sdpSection.updateAudioSSRCSection(1000, \"CHROME0000\", \"MS_0000\", \"LABEL_AUDIO_1000\");\n\t                    sdpSection.updateVideoSSRCSection(2000, \"CHROME0000\", \"MS_0000\", \"LABEL_VIDEO_2000\");\n\t\n\t                    desc.sdp = sdpSection.getUpdatedSDP();\n\t                }\n\t\n\t                _logger.debug('[WebRTC-API] Send Answer ', desc.sdp); //_logger.debug('from :\\n' + desc.sdp);\n\t\n\t                (onCreateAnswerSuccess || self.onCreateAnswerSuccess)(desc);\n\t            });\n\t        }, onCreateAnswerError || self.onCreateSessionDescriptionError);\n\t    },\n\t\n\t    close: function close() {\n\t        var self = this;\n\t        try {\n\t            webrtcStatisticsHelper.stopIntervalPrintStats();\n\t\n\t            self.rtcPeerConnection && self.rtcPeerConnection.close();\n\t        } catch (e) {}\n\t\n\t        if (self.localStream) {\n\t            self.localStream.getTracks().forEach(function (track) {\n\t                track.stop();\n\t            });\n\t        }\n\t        self.localStream = null;\n\t    },\n\t\n\t    addIceCandidate: function addIceCandidate(candidate) {\n\t        var self = this;\n\t\n\t        if (!self.rtcPeerConnection) {\n\t            return;\n\t        }\n\t\n\t        _logger.debug('[WebRTC-API] Add ICE candidate: \\n', candidate);\n\t\n\t        var _cands = _util.isArray(candidate) ? candidate : [];\n\t        !_util.isArray(candidate) && _cands.push(candidate);\n\t\n\t        for (var i = 0; i < _cands.length; i++) {\n\t            candidate = _cands[i];\n\t\n\t            self.rtcPeerConnection.addIceCandidate(new RTCIceCandidate(candidate)).then(self.onAddIceCandidateSuccess, self.onAddIceCandidateError);\n\t        }\n\t    },\n\t\n\t    setRemoteDescription: function setRemoteDescription(desc) {\n\t        var self = this;\n\t\n\t        _logger.debug('[WebRTC-API] setRemoteDescription start. ');\n\t\n\t        desc.sdp = desc.sdp.replace(/UDP\\/TLS\\/RTP\\/SAVPF/g, \"RTP/SAVPF\");\n\t        _logger.debug('[WebRTC-API] setRemoteDescription.', desc);\n\t\n\t        desc = new RTCSessionDescription(desc);\n\t\n\t        return self.rtcPeerConnection.setRemoteDescription(desc).then(self.onSetRemoteSuccess, self.onSetSessionDescriptionError);\n\t    },\n\t\n\t    iceConnectionState: function iceConnectionState() {\n\t        var self = this;\n\t\n\t        return self.rtcPeerConnection.iceConnectionState;\n\t    },\n\t\n\t    onCreateMedia: function onCreateMedia() {\n\t        _logger.debug('[WebRTC-API] media created.');\n\t    },\n\t\n\t    _onGotRemoteStream: function _onGotRemoteStream(event) {\n\t        _logger.debug('[WebRTC-API] onGotRemoteStream.', event);\n\t\n\t        event.stream.getAudioTracks()[0].enabled = true;\n\t        event.stream.getVideoTracks()[0] && (event.stream.getVideoTracks()[0].enabled = this.streamType == \"VIDEO\");\n\t\n\t        this.onGotRemoteStream(event.stream, this.streamType);\n\t        _logger.debug('[WebRTC-API] received remote stream, you will see the other.');\n\t    },\n\t\n\t    onGotStream: function onGotStream(stream, streamType) {\n\t        _logger.debug('[WebRTC-API] on got a local stream : ' + streamType);\n\t    },\n\t\n\t    onSetRemoteSuccess: function onSetRemoteSuccess() {\n\t        _logger.info('[WebRTC-API] onSetRemoteSuccess complete');\n\t    },\n\t\n\t    onSetLocalSuccess: function onSetLocalSuccess() {\n\t        _logger.info('[WebRTC-API] setLocalDescription complete');\n\t    },\n\t\n\t    onAddIceCandidateSuccess: function onAddIceCandidateSuccess() {\n\t        _logger.debug('[WebRTC-API] addIceCandidate success');\n\t    },\n\t\n\t    onAddIceCandidateError: function onAddIceCandidateError(error) {\n\t        _logger.debug('[WebRTC-API] failed to add ICE Candidate: ' + error.toString());\n\t    },\n\t\n\t    onIceCandidate: function onIceCandidate(event) {\n\t        _logger.debug('[WebRTC-API] onIceCandidate : ICE candidate: \\n' + event.candidate);\n\t    },\n\t\n\t    onIceStateChange: function onIceStateChange(event) {\n\t        _logger.debug('[WebRTC-API] onIceStateChange : ICE state change event: ', event);\n\t    },\n\t\n\t    onCreateSessionDescriptionError: function onCreateSessionDescriptionError(error) {\n\t        _logger.error('[WebRTC-API] Failed to create session description: ' + error.toString());\n\t    },\n\t\n\t    onCreateOfferSuccess: function onCreateOfferSuccess(desc) {\n\t        _logger.debug('[WebRTC-API] create offer success');\n\t    },\n\t\n\t    onCreatePRAnswerSuccess: function onCreatePRAnswerSuccess(desc) {\n\t        _logger.debug('[WebRTC-API] create answer success');\n\t    },\n\t\n\t    onCreateAnswerSuccess: function onCreateAnswerSuccess(desc) {\n\t        _logger.debug('[WebRTC-API] create answer success');\n\t    },\n\t\n\t    onSetSessionDescriptionError: function onSetSessionDescriptionError(error) {\n\t        _logger.error('[WebRTC-API] onSetSessionDescriptionError : Failed to set session description: ' + error.toString());\n\t    },\n\t\n\t    onSetLocalSessionDescriptionSuccess: function onSetLocalSessionDescriptionSuccess() {\n\t        _logger.debug('[WebRTC-API] onSetLocalSessionDescriptionSuccess : setLocalDescription complete');\n\t    }\n\t\n\t};\n\t\n\tmodule.exports = function (initConfigs) {\n\t    _util.extend(true, this, _WebRTC, initConfigs || {});\n\t};\n\n/***/ }),\n\n/***/ 254:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * P2P\n\t */\n\tvar _util = __webpack_require__(249);\n\tvar RouteTo = __webpack_require__(252).RouteTo;\n\tvar _logger = _util.logger;\n\t\n\tvar P2PRouteTo = RouteTo({\n\t    success: function success(result) {\n\t        _logger.debug(\"iq to server success\", result);\n\t    },\n\t    fail: function fail(error) {\n\t        _logger.debug(\"iq to server error\", error);\n\t    }\n\t});\n\t\n\tvar CommonPattern = {\n\t    _pingIntervalId: null,\n\t    _p2pConfig: null,\n\t    _rtcCfg: null,\n\t    _rtcCfg2: null,\n\t    _rtKey: null,\n\t    _rtFlag: null,\n\t\n\t    webRtc: null,\n\t    api: null,\n\t\n\t    callee: null,\n\t\n\t    isCaller: false,\n\t    accepted: false,\n\t\n\t    setLocalSDP: false,\n\t    setRemoteSDP: false,\n\t\n\t    hangup: false,\n\t\n\t    init: function init() {\n\t        var self = this;\n\t\n\t        self.api.onPing = function () {\n\t            self._onPing.apply(self, arguments);\n\t        };\n\t        self.api.onTcklC = function () {\n\t            self._onTcklC.apply(self, arguments);\n\t        };\n\t        self.api.onAcptC = function () {\n\t            self._onAcptC.apply(self, arguments);\n\t        };\n\t        self.api.onAnsC = function () {\n\t            self._onAnsC.apply(self, arguments);\n\t        };\n\t        self.api.onTermC = function () {\n\t            self._onTermC.apply(self, arguments);\n\t        };\n\t        self.api.onEvJoin = function () {\n\t            self._onEvJoin.apply(self, arguments);\n\t        };\n\t        self.api.onStreamControl = function () {\n\t            self._onStreamControl.apply(self, arguments);\n\t        };\n\t        self.webRtc.onIceCandidate = function () {\n\t            self._onIceCandidate.apply(self, arguments);\n\t        };\n\t        self.webRtc.onIceStateChange = function () {\n\t            self._onIceStateChange.apply(self, arguments);\n\t        };\n\t    },\n\t\n\t    _ping: function _ping() {\n\t        var self = this;\n\t\n\t        var index = 0;\n\t\n\t        function ping() {\n\t            var rt = new P2PRouteTo({\n\t                to: self.callee,\n\t                rtKey: self._rtKey\n\t            });\n\t\n\t            self.api.ping(rt, self._sessId, function (from, rtcOptions) {\n\t                _logger.debug(\"ping result\", rtcOptions);\n\t            });\n\t            // self.api.streamControl(rt, self._sessId, \"rtcId\", (index++) % 4, function (from, rtcOptions) {\n\t            //     _logger.debug(\"streamControl result\", rtcOptions);\n\t            //\n\t            // });\n\t        }\n\t\n\t        self._pingIntervalId = window.setInterval(ping, 50000);\n\t    },\n\t\n\t    _onPing: function _onPing(from, options, rtkey, tsxId, fromSid) {\n\t        _logger.debug('_onPing from', fromSid);\n\t    },\n\t\n\t    initC: function initC(mediaStreamConstaints, accessSid) {\n\t        var self = this;\n\t        self.sid = accessSid;\n\t\n\t        self.isCaller = true;\n\t        self.accepted = false;\n\t        self.setLocalSDP = false;\n\t        self.setRemoteSDP = false;\n\t        self.hangup = false;\n\t\n\t        self.streamType = mediaStreamConstaints.audio && mediaStreamConstaints.video ? \"VIDEO\" : \"VOICE\";\n\t\n\t        self.createLocalMedia(mediaStreamConstaints);\n\t    },\n\t\n\t    createLocalMedia: function createLocalMedia(mediaStreamConstaints) {\n\t        var self = this;\n\t\n\t        this.webRtc.createMedia(mediaStreamConstaints, function (webrtc, stream) {\n\t            webrtc.setLocalVideoSrcObject(stream);\n\t\n\t            self.webRtc.createRtcPeerConnection(self._rtcCfg);\n\t\n\t            self.webRtc.createOffer(function (offer) {\n\t                self._onGotWebRtcOffer(offer);\n\t            });\n\t        });\n\t    },\n\t\n\t    _onGotWebRtcOffer: function _onGotWebRtcOffer(offer) {\n\t        var self = this;\n\t\n\t        var rt = new P2PRouteTo({\n\t            sid: self.sid,\n\t            to: self.callee,\n\t            rtKey: self._rtKey\n\t        });\n\t\n\t        self.api.initC(rt, self.streamType, null, null, self._sessId, self._rtcId, null, null, offer, null, self._rtcCfg2, null, function (from, rtcOptions) {\n\t            _logger.debug(\"initc result\", rtcOptions);\n\t        });\n\t\n\t        self.setLocalSDP = true;\n\t\n\t        self._ping();\n\t    },\n\t\n\t    _onAcptC: function _onAcptC(from, options) {\n\t        var self = this;\n\t\n\t        if (options.ans && options.ans == 1) {\n\t            _logger.info(\"[WebRTC-API] _onAcptC : 104, ans = 1, it is a answer. will onAcceptCall\");\n\t            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n\t            self._onAnsC(from, options);\n\t        } else if (!WebIM.WebRTC.supportPRAnswer) {\n\t            _logger.info(\"[WebRTC-API] _onAcptC : not supported pranswer. drop it. will onAcceptCall\");\n\t\n\t            self.setRemoteSDP = false;\n\t            self._handRecvCandsOrSend(from, options);\n\t\n\t            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n\t        } else {\n\t            _logger.info(\"[WebRTC-API] _onAcptC : recv pranswer. \");\n\t\n\t            if (options.sdp || options.cands) {\n\t                // options.sdp && (options.sdp.type = \"pranswer\");\n\t                options.sdp && self.webRtc.setRemoteDescription(options.sdp);\n\t\n\t                self.setRemoteSDP = true;\n\t                self._handRecvCandsOrSend(from, options);\n\t\n\t                self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n\t            }\n\t        }\n\t    },\n\t\n\t    _onEvJoin: function _onEvJoin(from, options, rtkey, tsxId, fromSid) {\n\t        var self = this;\n\t\n\t        _logger.debug('_onEvJoin from', fromSid, from);\n\t\n\t        self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n\t    },\n\t\n\t    onAcceptCall: function onAcceptCall(from, options, enableVoice, enableVideo) {},\n\t\n\t    __onVoiceOrVideo: function __onVoiceOrVideo(from, options, fromSid) {\n\t        var self = this;\n\t\n\t        options.enableVoice === false ? self.onOtherUserOpenVoice(from, false) : self.onOtherUserOpenVoice(from, true);\n\t        options.enableVideo === false ? self.onOtherUserOpenVideo(from, false) : self.onOtherUserOpenVideo(from, true);\n\t    },\n\t\n\t    /*\n\t     * { verison : MSYNC_V1, compress_algorimth : 0, command : SYNC, payload : { meta : { id : 2326, to : easemob-demo#chatdemoui_xyj002@easemob.com, ns : CONFERENCE, payload : { session_id : xyj0011494320598055, operation : MEDIA_REQUEST, peer_name : xyj001, route_flag : 1, route_key : --X--, content : {\"op\":400,\"callVersion\":\"2.0.0\",\"sessId\":\"128542826909667328\",\"rtcId\":\"Channel1494320598056\",\"tsxId\":\"1494320622866-6\",\"controlType\":0}, control_type : PAUSE_VOICE } } } }\n\t     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)\n\t     *\n\t     */\n\t    _onStreamControl: function _onStreamControl(from, options, rtkey, tsxId, fromSid) {\n\t        var self = this;\n\t        var controlType = options.controlType;\n\t\n\t        controlType === 0 && self.onOtherUserOpenVoice(from, false);\n\t        controlType === 1 && self.onOtherUserOpenVoice(from, true);\n\t        controlType === 2 && self.onOtherUserOpenVideo(from, false);\n\t        controlType === 3 && self.onOtherUserOpenVideo(from, true);\n\t\n\t        self.onStreamControl(from, options, rtkey, tsxId, fromSid);\n\t    },\n\t    onStreamControl: function onStreamControl(from, options, rtkey, tsxId, fromSid) {},\n\t\n\t    onOtherUserOpenVoice: function onOtherUserOpenVoice(from, opened) {\n\t        _logger.debug(\"from open:\", opened, \" voice .\", from);\n\t    },\n\t    onOtherUserOpenVideo: function onOtherUserOpenVideo(from, opened) {\n\t        _logger.debug(\"from open:\", opened, \" voideo .\", from);\n\t    },\n\t\n\t    _onAnsC: function _onAnsC(from, options) {\n\t        // answer\n\t        var self = this;\n\t\n\t        _logger.info(\"[WebRTC-API] _onAnsC : recv answer. \");\n\t\n\t        self.accepted = true;\n\t\n\t        options.sdp && self.webRtc.setRemoteDescription(options.sdp);\n\t\n\t        self.setRemoteSDP = true;\n\t        self._handRecvCandsOrSend(from, options);\n\t\n\t        self.__onVoiceOrVideo(from, options);\n\t    },\n\t\n\t    _onInitC: function _onInitC(from, options, rtkey, tsxId, fromSid) {\n\t        var self = this;\n\t\n\t        self.isCaller = false;\n\t        self.accepted = false;\n\t        self.setLocalSDP = false;\n\t        self.setRemoteSDP = false;\n\t        self.hangup = false;\n\t\n\t        self.callee = from;\n\t        self._rtcCfg2 = options.rtcCfg;\n\t        self._rtKey = rtkey;\n\t        self._tsxId = tsxId;\n\t        self._fromSid = fromSid;\n\t\n\t        self._rtcId = options.rtcId;\n\t        self._sessId = options.sessId;\n\t\n\t        self.streamType = options.streamType;\n\t\n\t        self.webRtc.createRtcPeerConnection(self._rtcCfg2);\n\t\n\t        options.sdp && _logger.debug(options.sdp.sdp);\n\t\n\t        options.sdp && self.webRtc.setRemoteDescription(options.sdp).then(function () {\n\t\n\t            self.setRemoteSDP = true;\n\t            self._handRecvCandsOrSend(from, options);\n\t\n\t            /*\n\t             * chrome 版本 大于 50时，可以使用pranswer。\n\t             * 小于50 不支持pranswer，此时处理逻辑是，直接进入振铃状态\n\t             *\n\t             */\n\t            if (WebIM.WebRTC.supportPRAnswer) {\n\t                self.webRtc.createPRAnswer(function (prAnswer) {\n\t                    self._onGotWebRtcPRAnswer(prAnswer);\n\t\n\t                    setTimeout(function () {\n\t                        //由于 chrome 在 pranswer时，ice状态只是 checking，并不能像sdk那样 期待 connected 振铃；所以目前改为 发送完pranswer后，直接振铃\n\t                        _logger.info(\"[WebRTC-API] onRinging : after send pranswer. \", self.callee);\n\t                        self.onRinging(self.callee, self.streamType);\n\t                    }, 500);\n\t                });\n\t            } else {\n\t                setTimeout(function () {\n\t                    _logger.info(\"[WebRTC-API] onRinging : After iniC, cause by: not supported pranswer. \", self.callee);\n\t                    self.onRinging(self.callee, self.streamType);\n\t                }, 500);\n\t                self._ping();\n\t            }\n\t        });\n\t    },\n\t\n\t    _onGotWebRtcPRAnswer: function _onGotWebRtcPRAnswer(prAnswer) {\n\t        var self = this;\n\t\n\t        var rt = new P2PRouteTo({\n\t            //tsxId: self._tsxId,\n\t            to: self.callee,\n\t            rtKey: self._rtKey\n\t        });\n\t\n\t        //self.api.acptC(rt, self._sessId, self._rtcId, prAnswer, null, 1);\n\t        self.api.acptC(rt, self._sessId, self._rtcId, prAnswer);\n\t\n\t        self.setLocalSDP = true;\n\t        self._handRecvCandsOrSend();\n\t\n\t        self._ping();\n\t    },\n\t\n\t    onRinging: function onRinging(caller, streamType) {},\n\t\n\t    accept: function accept() {\n\t        var self = this;\n\t\n\t        function createAndSendAnswer() {\n\t            _logger.info(\"createAndSendAnswer : ...... \");\n\t\n\t            self.webRtc.createAnswer(function (answer) {\n\t                var rt = new P2PRouteTo({\n\t                    //tsxId: self._tsxId,\n\t                    to: self.callee,\n\t                    rtKey: self._rtKey\n\t                });\n\t\n\t                if (WebIM.WebRTC.supportPRAnswer) {\n\t                    self.api.ansC(rt, self._sessId, self._rtcId, answer);\n\t                } else {\n\t                    self.api.acptC(rt, self._sessId, self._rtcId, answer, null, 1);\n\t                }\n\t\n\t                if (!WebIM.WebRTC.supportPRAnswer) {\n\t                    self.setLocalSDP = true;\n\t                }\n\t                self._handRecvCandsOrSend();\n\t\n\t                self.accepted = true;\n\t            });\n\t        }\n\t\n\t        var constaints = {\n\t            audio: true\n\t        };\n\t        if (self.streamType == \"VIDEO\") {\n\t            constaints.video = true;\n\t        }\n\t\n\t        self.webRtc.createMedia(constaints, function (webrtc, stream) {\n\t            webrtc.setLocalVideoSrcObject(stream);\n\t\n\t            createAndSendAnswer();\n\t        });\n\t    },\n\t\n\t    _handRecvCandsOrSend: function _handRecvCandsOrSend(from, options) {\n\t        var self = this;\n\t\n\t        setTimeout(function () {\n\t            self._onTcklC(from, options);\n\t        }, 50);\n\t\n\t        setTimeout(function () {\n\t            self._onIceCandidate();\n\t        }, 50);\n\t    },\n\t\n\t    _onTcklC: function _onTcklC(from, options) {\n\t        // setRemoteSDP，才可以添加 添加 对方 cands\n\t        var self = this;\n\t\n\t        // options.sdp && self.webRtc.setRemoteDescription(options.sdp);\n\t\n\t        if (self.setRemoteSDP) {\n\t            _logger.info(\"[WebRTC-API] recv and add cands.\");\n\t\n\t            self._recvCands && self._recvCands.length > 0 && self.webRtc.addIceCandidate(self._recvCands);\n\t            self._recvCands && self._recvCands.length > 0 && (self._recvCands = []);\n\t            options && options.cands && self.webRtc.addIceCandidate(options.cands);\n\t        } else if (options && options.cands && options.cands.length > 0) {\n\t            for (var i = 0; i < options.cands.length; i++) {\n\t                (self._recvCands || (self._recvCands = [])).push(options.cands[i]);\n\t            }\n\t            _logger.debug(\"[_onTcklC] temporary memory[recv] ice candidate. util setRemoteSDP = true\");\n\t        }\n\t    },\n\t\n\t    _onIceStateChange: function _onIceStateChange(event) {\n\t        var self = this;\n\t        event && _logger.debug(\"[WebRTC-API] \" + self.webRtc.iceConnectionState() + \" |||| ice state is \" + event.target.iceConnectionState);\n\t\n\t        if (event && event.target.iceConnectionState == \"closed\") {\n\t            self.setLocalSDP = false;\n\t            self.setRemoteSDP = false;\n\t        }\n\t\n\t        self.api.onIceConnectionStateChange(self.webRtc.iceConnectionState());\n\t    },\n\t\n\t    _onIceCandidate: function _onIceCandidate(event) {\n\t        //在本地sdp set 发送完成后，发送 cands\n\t        var self = this;\n\t\n\t        if (self.setLocalSDP) {\n\t            var sendIceCandidate = function sendIceCandidate(candidate) {\n\t                _logger.debug(\"send ice candidate...\");\n\t\n\t                var rt = new P2PRouteTo({\n\t                    to: self.callee,\n\t                    rtKey: self._rtKey\n\t                });\n\t\n\t                if (candidate) {\n\t                    self.api.tcklC(rt, self._sessId, self._rtcId, null, candidate);\n\t                }\n\t            };\n\t\n\t            if (self._cands && self._cands.length > 0) {\n\t\n\t                sendIceCandidate(self._cands);\n\t\n\t                self._cands = [];\n\t            }\n\t            event && event.candidate && sendIceCandidate(event.candidate);\n\t        } else {\n\t            event && event.candidate && (self._cands || (self._cands = [])).push(event.candidate);\n\t            _logger.debug(\"[_onIceCandidate] temporary memory[send] ice candidate. util setLocalSDP = true\");\n\t        }\n\t    },\n\t\n\t    termCall: function termCall(reason) {\n\t        var self = this;\n\t\n\t        self._pingIntervalId && window.clearInterval(self._pingIntervalId);\n\t\n\t        var rt = new P2PRouteTo({\n\t            to: self.callee,\n\t            rtKey: self._rtKey\n\t        });\n\t\n\t        var sendReason;\n\t        reason || !self.isCaller && !self.accepted && (sendReason = 'decline') || (sendReason = 'success');\n\t\n\t        self.hangup || self.api.termC(rt, self._sessId, self._rtcId, sendReason);\n\t\n\t        self.webRtc.close();\n\t\n\t        self.hangup = true;\n\t\n\t        self.setLocalSDP = false;\n\t        self.setRemoteSDP = false;\n\t\n\t        self.onTermCall(reason);\n\t    },\n\t\n\t    /**\n\t     *\n\t     * @param from\n\t     * @param options\n\t     * @param options.reason\n\t     *               \"ok\"      -> 'HANGUP'     \"success\" -> 'HANGUP'   \"timeout\"          -> 'NORESPONSE'\n\t     *               \"decline\" -> 'REJECT'     \"busy\"    -> 'BUSY'     \"failed-transport\" -> 'FAIL'\n\t     * @private\n\t     */\n\t    _onTermC: function _onTermC(from, options) {\n\t        _logger.debug(\"[_onTermC] options.reason = \" + options.reason);\n\t\n\t        var self = this;\n\t\n\t        self.hangup = true;\n\t\n\t        self.setLocalSDP = false;\n\t        self.setRemoteSDP = false;\n\t\n\t        self.termCall(options.reason);\n\t    },\n\t\n\t    onTermCall: function onTermCall() {\n\t        //to be overwrited by call.listener.onTermCall\n\t    }\n\t};\n\t\n\tmodule.exports = function (initConfigs) {\n\t    var self = this;\n\t\n\t    _util.extend(true, this, CommonPattern, initConfigs || {});\n\t\n\t    self.init();\n\t};\n\t\n\t/**\n\t * TODO: Conference\n\t */\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// webrtc/dist/webrtc-1.4.12.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c9402f91bc3dfc2c1147","var Util = require('./components/utils');\nvar Call = require('./components/call');\n\nwindow.WebIM = typeof WebIM !== 'undefined' ? WebIM : {};\nWebIM.WebRTC = WebIM.WebRTC || {};\nWebIM.WebRTC.Call = Call;\nWebIM.WebRTC.Util = Util;\n\nif (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = WebIM.WebRTC;\n} else if (typeof define === 'function' && define.amd) {\n    define([], function () {\n        return WebIM.WebRTC;\n    });\n}\n\n\n/**\n * 判断是否支持pranswer\n */\nif (/Chrome/.test(navigator.userAgent)) {\n    WebIM.WebRTC.supportPRAnswer = (navigator.userAgent.split(\"Chrome/\")[1].split(\".\")[0] >= 50) ? true : false;\n}\n\n//WebIM.WebRTC.supportPRAnswer = false;\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/entry.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 248\n// module chunks = 3","/*\n * ! Math.uuid.js (v1.4) http://www.broofa.com mailto:robert@broofa.com\n * \n * Copyright (c) 2010 Robert Kieffer Dual licensed under the MIT and GPL\n * licenses.\n */\n\n/*\n * Generate a random uuid.\n * \n * USAGE: Math.uuid(length, radix) length - the desired number of characters\n * radix - the number of allowable values for each character.\n * \n * EXAMPLES: // No arguments - returns RFC4122, version 4 ID >>> Math.uuid()\n * \"92329D39-6F5C-4520-ABFC-AAB64544E172\" // One argument - returns ID of the\n * specified length >>> Math.uuid(15) // 15 character ID (default base=62)\n * \"VcydxgltxrVZSTV\" // Two arguments - returns ID of the specified length, and\n * radix. (Radix must be <= 62) >>> Math.uuid(8, 2) // 8 character ID (base=2)\n * \"01001010\" >>> Math.uuid(8, 10) // 8 character ID (base=10) \"47473046\" >>>\n * Math.uuid(8, 16) // 8 character ID (base=16) \"098F4D35\"\n */\n(function () {\n    // Private array of chars to use\n    var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\n    Math.uuid = function (len, radix) {\n        var chars = CHARS, uuid = [], i;\n        radix = radix || chars.length;\n\n        if (len) {\n            // Compact form\n            for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random() * radix];\n        } else {\n            // rfc4122, version 4 form\n            var r;\n\n            // rfc4122 requires these characters\n            uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n            uuid[14] = '4';\n\n            // Fill in random data. At i==19 set the high bits of clock sequence\n            // as\n            // per rfc4122, sec. 4.1.5\n            for (i = 0; i < 36; i++) {\n                if (!uuid[i]) {\n                    r = 0 | Math.random() * 16;\n                    uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n                }\n            }\n        }\n\n        return uuid.join('');\n    };\n\n    // A more performant, but slightly bulkier, RFC4122v4 solution. We boost\n    // performance\n    // by minimizing calls to random()\n    Math.uuidFast = function () {\n        var chars = CHARS, uuid = new Array(36), rnd = 0, r;\n        for (var i = 0; i < 36; i++) {\n            if (i == 8 || i == 13 || i == 18 || i == 23) {\n                uuid[i] = '-';\n            } else if (i == 14) {\n                uuid[i] = '4';\n            } else {\n                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n                r = rnd & 0xf;\n                rnd = rnd >> 4;\n                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n            }\n        }\n        return uuid.join('');\n    };\n\n    // A more compact, but less performant, RFC4122v4 solution:\n    Math.uuidCompact = function () {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n        });\n    };\n})();\n\n\n/**\n * Util\n *\n * @constructor\n */\nfunction Util() {\n}\n\n/**\n * Function Logger\n *\n * @constructor\n */\nvar Logger = function () {\n    var self = this;\n\n    var LogLevel = {\n        TRACE: 0,\n        DEBUG: 1,\n        INFO: 2,\n        WARN: 3,\n        ERROR: 4,\n        FATAL: 5\n    }\n\n    var LogLevelName = [\n        'TRACE',\n        'DEBUG',\n        'INFO',\n        'WARN',\n        'ERROR',\n        'FATAL'\n    ]\n\n    this.log = function () {\n        var level = arguments[0];\n\n        level = arguments[0] = '[' + LogLevelName[level] + '] ';\n\n        var text = arguments[1];\n\n        if (WebIM && WebIM.config && WebIM.config.isDebug) {\n            console.log.apply(console, arguments);\n        }\n\n    };\n\n    function callLog(level, args) {\n        var _args = [];\n\n        _args.push(level);\n\n        for (var i in args) {\n            _args.push(args[i]);\n        }\n\n        self.log.apply(self, _args);\n    };\n\n    this.trace = function () {\n        this.log && callLog(LogLevel.TRACE, arguments)\n    };\n\n    this.debug = function () {\n        this.log && callLog(LogLevel.DEBUG, arguments)\n    };\n\n    this.info = function () {\n        this.log && callLog(LogLevel.INFO, arguments)\n    };\n\n    this.warn = function () {\n        this.log && callLog(LogLevel.WARN, arguments)\n    };\n\n    this.error = function () {\n        this.log && callLog(LogLevel.ERROR, arguments)\n    };\n\n    this.fatal = function () {\n        this.log && callLog(LogLevel.FATAL, arguments)\n    };\n}\n\nUtil.prototype.logger = new Logger();\n\n/**\n * parse json\n *\n * @param jsonString\n */\nUtil.prototype.parseJSON = function (jsonString) {\n    return JSON.parse(jsonString);\n};\n\n/**\n * json to string\n *\n * @type {Util.stringifyJSON}\n */\nvar stringifyJSON = Util.prototype.stringifyJSON = function (jsonObj) {\n    return JSON.stringify(jsonObj);\n};\n\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call(Object);\n\n/**\n * check object type\n *\n * @type {Util.isPlainObject}\n */\nvar isPlainObject = Util.prototype.isPlainObject = function (obj) {\n    var proto, Ctor;\n\n    // Detect obvious negatives\n    // Use toString instead of jQuery.type to catch host objects\n    if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n    }\n\n    proto = Object.getPrototypeOf(obj);\n\n    // Objects with no prototype (e.g., `Object.create( null )`) are plain\n    if (!proto) {\n        return true;\n    }\n\n    // Objects with prototype are plain iff they were constructed by a\n    // global Object function\n    Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n    return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n};\n\nUtil.prototype.isArray = Array.isArray;\n\n/**\n * check empty object\n *\n * @param obj\n * @returns {boolean}\n */\nUtil.prototype.isEmptyObject = function (obj) {\n    var name;\n    for (name in obj) {\n        return false;\n    }\n    return true;\n};\n\nUtil.prototype.type = function (obj) {\n    if (obj == null) {\n        return obj + \"\";\n    }\n    return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj;\n};\n\n/**\n * Function extend\n *\n * @returns {*|{}}\n */\nUtil.prototype.extend = function () {\n    var self = this;\n    var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if (typeof target === \"boolean\") {\n        deep = target;\n\n        // Skip the boolean and the target\n        target = arguments[i] || {};\n        i++;\n    }\n\n    // Handle case when target is a string or something (possible in deep\n    // copy)\n    if (typeof target !== \"object\" && !self.isFunction(target)) {\n        target = {};\n    }\n\n    // Extend self itself if only one argument is passed\n    if (i === length) {\n        target = this;\n        i--;\n    }\n\n    for (; i < length; i++) {\n\n        // Only deal with non-null/undefined values\n        if (( options = arguments[i] ) != null) {\n\n            // Extend the base object\n            for (name in options) {\n                src = target[name];\n                copy = options[name];\n\n                // Prevent never-ending loop\n                if (target === copy) {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays\n                if (deep && copy && ( self.isPlainObject(copy) ||\n                    ( copyIsArray = self.isArray(copy) ) )) {\n\n                    if (copyIsArray) {\n                        copyIsArray = false;\n                        clone = src && self.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src && self.isPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    target[name] = self.extend(deep, clone, copy);\n\n                    // Don't bring in undefined values\n                } else if (copy !== undefined) {\n                    target[name] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n}\n\n/**\n * get local cache\n *\n * @memberOf tool\n * @name hasLocalData\n * @param key{string}\n *            localStorage的key值\n * @return boolean\n */\nUtil.prototype.hasLocalStorage = function (key) {\n    // null -> localStorage.removeItem时\n    // '{}' -> collection.models.destroy时\n    if (localStorage.getItem(key) == null || localStorage.getItem(key) == '{}') {\n        return false;\n    }\n    return true;\n}\n\nUtil.prototype.toggleClass = function (node, className) {\n    if (node.hasClass(className)) {\n        node.removeClass(className);\n        return;\n    }\n    node.addClass(className);\n}\n\n\n/**\n * set cookie\n *\n * @param name{String}\n *\n * @param value{String}\n *\n * @param hour{Number}\n *\n * @return void\n */\nUtil.prototype.setCookie = function (name, value, hour) {\n    var exp = new Date();\n    exp.setTime(exp.getTime() + hour * 60 * 60 * 1000);\n    document.cookie = name + \"=\" + escape(value) + \";expires=\" + exp.toGMTString();\n}\n\n/**\n * read cookie\n *\n * @param name(String)\n *            cookie key\n * @return cookie value\n * @memberOf Tool\n */\nUtil.prototype.getCookie = function (name) {\n    var arr = document.cookie.match(new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\"));\n    if (arr != null) {\n        return unescape(arr[2]);\n    }\n    return null;\n}\n\n\n/**\n * query parameter from url\n *\n * @name parseURL\n * @memberof C.Tools\n * @param {string}\n *\n * @return {string}\n * @type function\n * @public\n */\nUtil.prototype.parseURL = function (name) {\n    var reg = new RegExp(\"(^|&)\" + name + \"=([^&]*)(&|$)\", \"i\");\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null) {\n        return unescape(r[2]);\n    }\n    return null;\n}\n\nmodule.exports = new Util();\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/components/utils.js","var Util = require('./utils');\nvar RTCIQHandler = require('./iq');\nvar API = require('./api');\nvar WebRTC = require('./webrtc');\nvar CommonPattern = require('./p2p');\n\nvar RouteTo = API.RouteTo;\nvar Api = API.Api;\nvar _logger = Util.logger;\n\n\nvar _Call = {\n    api: null,\n    caller: '',\n    connection: null,\n\n    pattern: null,\n\n    listener: {\n        onAcceptCall: function (from, options) {\n        },\n\n        onRinging: function (caller) {\n        },\n\n        onTermCall: function () {\n        },\n\n        onIceConnectionStateChange: function (iceState) {\n        }\n    },\n\n    mediaStreamConstaints: {\n        audio: true,\n        video: true\n    },\n\n    init: function () {\n        var self = this;\n\n        if (typeof self.connection === \"undefined\") {\n            throw \"Caller need a instance of Easemob.im.Connection\"\n        }\n\n        self.api = self.api || new Api({\n                imConnection: self.connection,\n\n                rtcHandler: new RTCIQHandler({\n                    imConnection: self.connection\n                })\n            });\n\n        self.api.onInitC = function () {\n            self._onInitC.apply(self, arguments);\n        },\n\n        self.api.onIceConnectionStateChange = function () {\n            self.listener.onIceConnectionStateChange.apply(self, arguments);\n        }\n    },\n\n    makeVideoCall: function (callee, accessSid) {\n        var self = this;\n\n        var mediaStreamConstaints = {};\n        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);\n        self.mediaStreamConstaints.video = true;\n\n        this.call(callee, mediaStreamConstaints, accessSid);\n    },\n\n    makeVoiceCall: function (callee, accessSid) {\n        console.log('ScareCrow');\n        var self = this;\n\n        var mediaStreamConstaints = {};\n        Util.extend(mediaStreamConstaints, self.mediaStreamConstaints);\n        self.mediaStreamConstaints.video = false;\n\n        self.call(callee, mediaStreamConstaints, accessSid);\n    },\n\n    acceptCall: function () {\n        var self = this;\n        self.pattern.accept();\n    },\n\n    endCall: function (callee) {\n        var self = this;\n        self.caller = '';\n        self.pattern.termCall();\n    },\n\n    call: function (callee, mediaStreamConstaints, accessSid) {\n        var self = this;\n        this.callee = this.api.jid(callee);\n\n        var rt = new RouteTo({\n            rtKey: \"\",\n            sid: accessSid,\n\n            success: function (result) {\n                _logger.debug(\"iq to server success\", result);\n            },\n            fail: function (error) {\n                _logger.debug(\"iq to server error\", error);\n                self.onError(error);\n            }\n        });\n\n        this.api.reqP2P(\n            rt,\n            mediaStreamConstaints.video ? 1 : 0,\n            mediaStreamConstaints.audio ? 1 : 0,\n            this.api.jid(callee),\n            function (from, rtcOptions) {\n                if (rtcOptions.online == \"0\") {\n                    self.listener.onError({message: \"callee is not online!\"});\n                    return;\n                }\n                self._onGotServerP2PConfig(from, rtcOptions);\n                self.pattern.initC(self.mediaStreamConstaints, accessSid);\n            });\n    },\n\n    _onInitC: function (from, options, rtkey, tsxId, fromSid) {\n        var self = this;\n\n        self.callee = from;\n        self._rtcCfg = options.rtcCfg;\n        self._WebRTCCfg = options.WebRTC;\n\n        self.sessId = options.sessId;\n        self.rtcId = options.rtcId;\n\n        self.switchPattern(options.streamType == \"VIDEO\" ? \"VIDEO\" : \"VOICE\");\n        self.pattern._onInitC(from, options, rtkey, tsxId, fromSid);\n    },\n\n    _onGotServerP2PConfig: function (from, rtcOptions) {\n        var self = this;\n\n        if (rtcOptions.result == 0) {\n            self._p2pConfig = rtcOptions;\n            self._rtcCfg = rtcOptions.rtcCfg;\n            self._rtcCfg2 = rtcOptions.rtcCfg2;\n\n            self.sessId = rtcOptions.sessId;\n            self.rtcId = \"Channel_webIM\";\n\n            self._rtKey = self._rtkey = rtcOptions.rtKey || rtcOptions.rtkey;\n            self._rtFlag = self._rtflag = rtcOptions.rtFlag || rtcOptions.rtflag;\n\n            self._WebRTCCfg = rtcOptions.WebRTC;\n            self.admtok = rtcOptions.admtok;\n            self.tkt = rtcOptions.tkt;\n\n\n            self.switchPattern(self.mediaStreamConstaints.audio && self.mediaStreamConstaints.video ? \"VIDEO\" : \"VOICE\");\n        } else {\n            //\n        }\n    },\n\n    switchPattern: function (streamType) {\n        var self = this;\n\n        (!self._WebRTCCfg) && (self.pattern = new CommonPattern({\n            callee: self.callee,\n\n            _p2pConfig: self._p2pConfig,\n            _rtcCfg: self._rtcCfg,\n            _rtcCfg2: self._rtcCfg2,\n\n            _rtKey: self._rtKey || self._rtkey,\n            _rtFlag: self._rtFlag || self._rtflag,\n\n            _sessId: self.sessId,\n            _rtcId: self.rtcId,\n\n            webRtc: new WebRTC({\n                streamType: streamType,\n                onGotLocalStream: self.listener.onGotLocalStream,\n                onGotRemoteStream: self.listener.onGotRemoteStream,\n                onError: self.listener.onError\n            }),\n\n            api: self.api,\n\n            onAcceptCall: (self.listener && self.listener.onAcceptCall) || function () {\n\n            },\n            onRinging: (self.listener && self.listener.onRinging) || function () {\n\n            },\n            onTermCall: (self.listener && self.listener.onTermCall) || function () {\n\n            },\n            onOtherUserOpenVoice: (self.listener && self.listener.onOtherUserOpenVoice) || function () {\n\n            },\n            onOtherUserOpenVideo: (self.listener && self.listener.onOtherUserOpenVideo) || function () {\n\n            }\n        }));\n    }\n};\n\n\nmodule.exports = function (initConfigs) {\n    Util.extend(true, this, _Call, initConfigs || {});\n\n    this.init();\n};\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/components/call.js","/**\n * IQ Message，IM -> CMServer --> IM\n */\n\nvar _util = require('./utils');\nvar _logger = _util.logger;\nvar API = require('./api');\nvar RouteTo = API.RouteTo;\n\nvar CONFERENCE_XMLNS = \"urn:xmpp:media-conference\";\n\n\nvar _RtcHandler = {\n    _apiCallbacks: {},\n\n    imConnection: null,\n\n    _connectedSid: '',\n\n\n    init: function () {\n        var self = this;\n\n        var _conn = self.imConnection;\n\n        _conn.registerConfrIQHandler = function(){\n            var handleConferenceIQ = function (msginfo) {\n                try {\n                    self.handleRtcMessage(msginfo);\n                } catch (error) {\n                    _logger.error(error.stack || error);\n                    throw error;\n                }\n\n                return true;\n            };\n\n            _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', \"set\");\n            _conn.addHandler(handleConferenceIQ, CONFERENCE_XMLNS, 'iq', \"get\");\n\n            _logger.warn(\"Conference iq handler. registered.\");\n        }\n    },\n\n    handleRtcMessage: function (msginfo) {\n        var self = this;\n\n        var id = msginfo.getAttribute('id');\n        var from = msginfo.getAttribute('from') || '';\n\n        // remove resource\n        from.lastIndexOf(\"/\") >= 0 && (from = from.substring(0, from.lastIndexOf(\"/\")));\n\n\n        var rtkey = msginfo.getElementsByTagName('rtkey')[0].innerHTML;\n\n        var fromSessionId = msginfo.getElementsByTagName('sid')[0].innerHTML;\n\n        (self._fromSessionID || (self._fromSessionID = {}))[from] = fromSessionId;\n\n        var contentTags = msginfo.getElementsByTagName('content');\n\n\n\n        var contentString = contentTags[0].innerHTML;\n\n        var content = _util.parseJSON(contentString);\n\n        var rtcOptions = content;\n\n        var streamType = msginfo.getElementsByTagName('stream_type')[0].innerHTML; //VOICE, VIDEO\n\n        if(streamType == \"\"){\n            streamType = \"VOICE\";\n        }\n\n        rtcOptions.streamType = streamType;\n\n        if(rtcOptions.op == 102){\n            self.singalStreamType = streamType;\n        }\n\n\n        var tsxId = content.tsxId;\n\n        self.ctx = content.ctx;\n\n        _logger.debug(\"Recv [op = \" + rtcOptions.op + \"] [tsxId=\" + tsxId + \"]\\r\\n json :\", msginfo);\n\n\n        //if a->b already, c->a/b should be termiated with 'busy' reason\n        if (from.indexOf(\"@\") >= 0) {\n            if (self._connectedSid == '' && rtcOptions.op == 102) {\n                self._connectedSid = fromSessionId;\n            } else {\n                if (self._connectedSid != fromSessionId) {\n                    _logger.debug(\"Error recv [op = \" + rtcOptions.op + \"] [tsxId=\" + tsxId + \"]. caused by _connectedSid != fromSessionId :\",\n                        self._connectedSid, fromSessionId);\n\n                    //onInitC\n                    if (rtcOptions.op == 102) {\n                        var rt = new RouteTo({\n                            to: from,\n                            rtKey: rtkey,\n                            sid: fromSessionId,\n                            success: function (result) {\n                                _logger.debug(\"iq to server success\", result);\n                            },\n                            fail: function (error) {\n                                _logger.debug(\"iq to server error\", error);\n                                self.onError(error);\n                            }\n                        });\n\n                        var options = {\n                            data: {\n                                op: 107,\n                                sessId: rtcOptions.sessId,\n                                rtcId: rtcOptions.rtcId,\n                                reason: 'busy'\n\n                            },\n                            reason: 'busy'\n                        };\n                        self.sendRtcMessage(rt, options)\n                    }\n                    return;\n                }\n            }\n        }\n\n        //onTermC\n        if (rtcOptions.op == 107) {\n            self._connectedSid = '';\n            self._fromSessionID = {};\n\n            var reasonObj = msginfo.getElementsByTagName('reason');\n            //var endReason = msginfo.getElementsByTagName('reason')[0].innerHTML;\n            reasonObj && reasonObj.length > 0 && (rtcOptions.reason = reasonObj[0].innerHTML);\n        }\n\n        if (rtcOptions.sdp) {\n            if (typeof rtcOptions.sdp === 'string') {\n                rtcOptions.sdp = _util.parseJSON(rtcOptions.sdp);\n            }\n            rtcOptions.sdp.type && (rtcOptions.sdp.type = rtcOptions.sdp.type.toLowerCase());\n        }\n        if (rtcOptions.cands) {\n            if (typeof rtcOptions.cands === 'string') {\n                rtcOptions.cands = _util.parseJSON(rtcOptions.cands);\n            }\n\n            for (var i = 0; i < rtcOptions.cands.length; i++) {\n                typeof rtcOptions.cands[i] === 'string' && (rtcOptions.cands[i] = _util.parseJSON(rtcOptions.cands[i]));\n\n                rtcOptions.cands[i].sdpMLineIndex = rtcOptions.cands[i].mlineindex;\n                rtcOptions.cands[i].sdpMid = rtcOptions.cands[i].mid;\n\n                delete rtcOptions.cands[i].mlineindex;\n                delete rtcOptions.cands[i].mid;\n            }\n        }\n\n        rtcOptions.rtcCfg && (typeof rtcOptions.rtcCfg === 'string') && (rtcOptions.rtcCfg = _util.parseJSON(rtcOptions.rtcCfg));\n        rtcOptions.rtcCfg2 && (typeof rtcOptions.rtcCfg2 === 'string') && (rtcOptions.rtcCfg2 = _util.parseJSON(rtcOptions.rtcCfg2));\n        rtcOptions.WebRTC && (typeof rtcOptions.WebRTC === 'string') && (rtcOptions.WebRTC = _util.parseJSON(rtcOptions.WebRTC));\n\n        if (tsxId && self._apiCallbacks[tsxId]) {\n            try {\n                self._apiCallbacks[tsxId].callback && self._apiCallbacks[tsxId].callback(from, rtcOptions);\n            } catch (err) {\n                throw err;\n            } finally {\n                delete self._apiCallbacks[tsxId]\n            }\n        } else {\n            self.onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId);\n        }\n\n        return true;\n    },\n\n\n    onRecvRtcMessage: function (from, rtcOptions, rtkey, tsxId, fromSessionId) {\n        _logger.debug(' form : ' + from + \" \\r\\n json :\" + _util.stringifyJSON(rtcJSON));\n    },\n\n    convertRtcOptions: function (options) {\n        var sdp = options.data.sdp;\n        if (sdp) {\n            var _sdp = {\n                type: sdp.type,\n                sdp: sdp.sdp\n            };\n\n            sdp = _sdp;\n\n            sdp.type = sdp.type.toUpperCase();\n            sdp = _util.stringifyJSON(sdp);\n\n            options.data.sdp = sdp;\n        }\n\n\n        var cands = options.data.cands;\n\n        if (cands) {\n            if (_util.isArray(cands)) {\n\n            } else {\n                var _cands = [];\n                _cands.push(cands);\n                cands = _cands;\n            }\n\n            for (var i in cands) {\n                if (cands[i] instanceof RTCIceCandidate) {\n                    var _cand = {\n                        type: \"candidate\",\n                        candidate: cands[i].candidate,\n                        mlineindex: cands[i].sdpMLineIndex,\n                        mid: cands[i].sdpMid,\n                        // seq: i\n                    };\n\n                    cands[i] = _util.stringifyJSON(_cand);\n                }\n            }\n\n            options.data.cands = cands;\n        } else {\n            // options.data.cands = [];\n        }\n\n        var rtcCfg = options.data.rtcCfg;\n        if (rtcCfg) {\n            typeof rtcCfg !== 'string' && (options.data.rtcCfg = _util.stringifyJSON(rtcCfg));\n        }\n\n        var _webrtc = options.data.WebRTC;\n        if (_webrtc) {\n            typeof _webrtc !== 'string' && (options.data.WebRTC = _util.stringifyJSON(_webrtc));\n        }\n    },\n\n    /**\n     * rt: { id: , to: , rtKey: , rtflag: , sid: , tsxId: , type: , }\n     *\n     * rtcOptions: { data : { op : 'reqP2P', video : 1, audio : 1, peer :\n     * curChatUserId, //appKey + \"_\" + curChatUserId + \"@\" + this.domain, } }\n     *\n     */\n    sendRtcMessage: function (rt, options, callback) {\n        var self = this;\n\n        var _conn = self.imConnection;\n\n        var tsxId = rt.tsxId || _conn.getUniqueId();\n\n        var to = rt.to || _conn.domain;\n\n        var sid = rt.sid || self._fromSessionID && self._fromSessionID[to];\n        //sid = sid || ((self._fromSessionID || (self._fromSessionID = {}))[to] = _conn.getUniqueId(\"CONFR_\"));\n        sid = sid || _conn.getUniqueId(\"CONFR_\");\n        (self._fromSessionID || (self._fromSessionID = {}))[to] = sid;\n\n        if (to.indexOf(\"@\") >= 0) {\n            if (self._connectedSid == '' && options.data.op == 102) {\n                self._connectedSid = sid;\n            }\n        }\n        var rtKey = rt.rtKey || rt.rtkey;\n        // rtKey && delete rt.rtKey;\n        rtKey || (rtKey = \"\");\n\n        var rtflag = rt.rtflag;\n        // rtflag && delete rt.rtflag;\n        rtflag || (rtflag = 1);\n\n        options.data || (options.data = {});\n        options.data.tsxId = tsxId;\n\n        self.ctx && (options.data.ctx = self.ctx);\n        self.convertRtcOptions(options);\n\n        var streamType = options.streamType || self.singalStreamType || \"VIDEO\"; // \"VIDEO\"; //VOICE, VIDEO\n        if (options.data.op == 102) {\n            self.singalStreamType = streamType;\n        }\n\n\n        var id = rt.id || _conn.getUniqueId(\"CONFR_\");\n        var iq = $iq({\n            // xmlns: CONFERENCE_XMLNS,\n            id: id,\n            to: to,\n            from: _conn.context.jid,\n            type: rt.type || \"get\"\n        }).c(\"query\", {\n            xmlns: CONFERENCE_XMLNS\n        }).c(\"MediaReqExt\").c('rtkey').t(rtKey)\n            .up().c('rtflag').t(rtflag)\n            .up().c('stream_type').t(streamType)\n            .up().c('sid').t(sid)\n            .up().c('content').t(_util.stringifyJSON(options.data));\n\n        if (options.data.op == 107 && options.reason) {\n            iq.up().c('reason').t(options.reason);\n        }\n        _logger.debug(\"Send [op = \" + options.data.op + \"] : \\r\\n\", iq.tree());\n\n\n        callback && (\n            self._apiCallbacks[tsxId] = {\n                callback: callback\n            }\n        );\n\n        var completeFn = function (result) {\n                rt.success(result);\n            } || function (result) {\n                _logger.debug(\"send result. op:\" + options.data.op + \".\", result);\n            };\n\n        var errFn = function (ele) {\n                rt.fail(ele);\n            } || function (ele) {\n                _logger.debug(ele);\n            };\n\n        _conn.context.stropheConn.sendIQ(iq.tree(), completeFn, errFn);\n\n        //onTermC\n        if (options.data.op == 107 && self._connectedSid) {\n            if (!rt.sid || self._connectedSid == rt.sid) {\n                self._connectedSid = '';\n                self._fromSessionID = {};\n            }\n        }\n    }\n};\n\n\nvar RTCIQHandler = function (initConfigs) {\n    _util.extend(true, this, _RtcHandler, initConfigs || {});\n\n    this.init();\n};\nmodule.exports = RTCIQHandler;\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/components/iq.js","/**\n * API\n */\nvar _util = require('./utils');\nvar _logger = _util.logger;\n\n\nvar _RouteTo = {\n    // to : null,\n    // rtKey: null,\n    rtFlag: 1,\n\n    success: function (result) {\n\n    },\n    fail: function (error) {\n\n    }\n};\n\nvar RouteTo = function (extendCfg) {\n    if (this instanceof RouteTo) {\n        var self = this;\n        _util.extend(true, self, _RouteTo, extendCfg || {});\n\n    } else {\n        var sub = function (extendCfg) {\n            var self = this;\n            _util.extend(true, self, extendCfg || {});\n        };\n\n        _util.extend(true, sub.prototype, _RouteTo, extendCfg || {});\n\n        return sub;\n    }\n};\nexports.RouteTo = RouteTo;\n\n\nvar _clazz = {\n    imConnection: null,\n    // webRtc: null,\n\n    rtcHandler: null,\n\n    events: {\n        '0': 'onReqP2P',\n        '1': 'onNewCfr',\n        '2': 'onDelCfr',\n        '3': 'onReqTkt',\n\n        '100': 'onPing',\n        '101': 'onPong',\n        '102': 'onInitC',\n        '103': 'onReqC',\n        '104': 'onAcptC',\n        '105': 'onTcklC',\n        '106': 'onAnsC',\n        '107': 'onTermC',\n\n        // '200' : 'onEnter',\n        // '201' : 'onExit',\n        // '202' : 'onInvite',\n        // '203' : 'onGetMems',\n\n        // '205' : 'onSubC',\n        // '206' : 'onUsubC',\n\n        '300': 'onEvEnter',\n        '301': 'onEvExit',\n        '302': 'onEvPub',\n        '303': 'onEvUnpub',\n        '304': 'onEvMems',\n        '204': 'onEvClose',\n        '400': 'onStreamControl',\n        '401': 'onEvJoin',\n\n        'onServerError': 'onServerError'\n    },\n\n    register: function (listener) {\n        if (typeof listener === \"object\") {\n            for (var event in listener) {\n                this.bind(event, listener[event]);\n            }\n        }\n    },\n\n    bind: function (event, func) {\n        var self = this;\n\n        var onFunc;\n        if ((onFunc = self.events[event])) {\n            self[onFunc] = func;\n        } else {\n            onFunc = self.events[event] = 'on_' + event;\n            self[onFunc] = func;\n        }\n    },\n\n    jid: function (shortUserName) {\n        if(/^.+#.+_.+@.+$/g.test(shortUserName)){\n            return shortUserName;\n        }\n        // if (shortUserName.indexOf(this.imConnection.context.appKey) >= 0) {\n        //     return shortUserName;\n        // }\n        return this.imConnection.context.appKey + \"_\" + shortUserName + \"@\" + this.imConnection.domain;\n    },\n\n    /**\n     * ReqP2P 0\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param video\n     *            1 0\n     * @param audio\n     *            1 0\n     * @param peer\n     *\n     */\n    reqP2P: function (rt, video, audio, peer, callback) {\n        _logger.debug(\"req p2p ...\");\n\n\n        var rtcOptions = {\n            data: {\n                op: 0,\n                video: video,\n                audio: audio,\n                peer: peer // appKey + \"_\" + curChatUserId + \"@\" + this.domain,\n            }\n        };\n\n        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * NewCfr 1\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param reqTkt\n     *            1 null\n     * @param password\n     *            string null\n     *\n     */\n    newCfr: function (rt, reqTkt, password, callback) {\n        _logger.debug(\"newCfr ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 1\n            }\n        };\n\n        reqTkt && (rtcOptions.data.reqTkt = reqTkt);\n        password && (rtcOptions.data.password = password);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * Enter 200\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param WebRTCId\n     * @param reqMembers !=\n     *            0 members\n     * @param tkt\n     * @param nonce\n     * @param digest\n     *\n     */\n    enter: function (rt, WebRTCId, reqMembers, tkt, nonce, digest, callback) {\n        _logger.debug(\"enter ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 200\n            }\n        };\n\n        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n        reqMembers && (rtcOptions.data.reqMembers = reqMembers);\n        tkt && (rtcOptions.data.tkt = tkt);\n        nonce && (rtcOptions.data.nonce = nonce);\n        digest && (rtcOptions.data.digest = digest);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * Ping 100\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     *\n     */\n    ping: function (rt, sessId, callback) {\n        _logger.debug(\"ping ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 100\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * 通知对方 我已经关闭/打开 麦卡，摄像头\n     *\n     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)\n     *\n     *\n     * @param rt\n     * @param sessId\n     * @param rtcId\n     * @param controlType\n     * @param callback\n     */\n    streamControl: function (rt, sessId, rtcId, controlType, callback) {\n        _logger.debug(\"streamControl ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 400\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        (typeof controlType !== 'undefined' &&  controlType != null ) && (rtcOptions.data.controlType = controlType);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * ReqTkt 3\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param WebRTCId\n     * @param success(from,\n     *            rtcOptions)\n     *\n     */\n    reqTkt: function (rt, WebRTCId, callback) {\n        _logger.debug(\"reqTkt ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 3\n            }\n        };\n\n        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * InitC 102\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param WebRTCId\n     * @param tkt\n     * @param sessId\n     * @param rtcId\n     * @param pubS\n     *            {name: streamName, video:1, audio:1, type: 0}\n     * @param subS\n     *            {memId: , rtcId: }\n     * @param sdp\n     *            sdp:sdpstring\n     * @param cands [ ]\n     *\n     */\n    initC: function (rt, streamType, WebRTCId, tkt, sessId, rtcId, pubS, subS, sdp, cands, rtcCfg, WebRTC, callback) {\n        _logger.debug(\"initC ...\");\n\n\n        var rtcOptions = {\n            data: {\n                op: 102\n            }\n        };\n\n        rtcOptions.streamType = streamType || \"VIDEO\";\n\n        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n        tkt && (rtcOptions.data.tkt = tkt);\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        pubS && (rtcOptions.data.pubS = pubS);\n        subS && (rtcOptions.data.subS = subS);\n        sdp && (rtcOptions.data.sdp = sdp);\n        cands && (rtcOptions.data.cands = cands);\n        rtcCfg && (rtcOptions.data.rtcCfg = rtcCfg);\n        WebRTC && (rtcOptions.data.WebRTC = WebRTC);\n\n        this.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * TcklC 105\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     * @param rtcId\n     * @param cands\n     * @param success(from,\n     *            rtcOptions)\n     *\n     */\n    tcklC: function (rt, sessId, rtcId, sdp, cands, callback) {\n        _logger.debug(\"tcklC ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 105\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        sdp && (rtcOptions.data.sdp = sdp);\n        cands && (rtcOptions.data.cands = cands);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * AnsC 106\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     * @param rtcId\n     * @param sdp\n     * @param cands\n     *\n     */\n    ansC: function (rt, sessId, rtcId, sdp, cands, callback, enableVoice, enableVideo) {\n        _logger.debug(\"ansC ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 106\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        sdp && (rtcOptions.data.sdp = sdp);\n        cands && (rtcOptions.data.cands = cands);\n\n        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);\n        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);\n\n\n\n        // rtcOptions.data.enableVoice = false;\n        // rtcOptions.data.enableVideo = false;\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * AcptC 104\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     * @param rtcId\n     * @param sdp\n     * @param ans\n     *            1\n     *\n     */\n    acptC: function (rt, sessId, rtcId, sdp, cands, ans, callback, enableVoice, enableVideo) {\n        _logger.debug(\"acptC ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 104\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        sdp && (rtcOptions.data.sdp = sdp);\n        cands && (rtcOptions.data.cands = cands);\n        ans && (rtcOptions.data.ans = ans);\n\n        enableVoice === false && (rtcOptions.data.enableVoice = enableVoice);\n        enableVideo === false && (rtcOptions.data.enableVideo = enableVideo);\n\n        // rtcOptions.data.enableVoice = false;\n        // rtcOptions.data.enableVideo = false;\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * GetMems 203\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param WebRTCId\n     * @param sessId\n     * @param success(from,\n     *            rtcOptions)\n     *\n     */\n    getMems: function (rt, WebRTCId, sessId, callback) {\n        _logger.debug(\"getMems ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 203\n            }\n        };\n\n        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n        sessId && (rtcOptions.data.sessId = sessId);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * SubC 205\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     * @param rtcId\n     * @param subS\n     *            {memId:m001, rtcId:r001}\n     *\n     */\n    subC: function (rt, sessId, rtcId, subS, callback) {\n        _logger.debug(\"subC ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 205\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        subS && (rtcOptions.data.subS = subS);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * UsubC 206\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     * @param rtcId\n     *\n     */\n    usubC: function (rt, sessId, rtcId, callback) {\n        _logger.debug(\"usubC ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 206\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * TermC 107\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param sessId\n     * @param rtcId\n     * @param reason\n     *               \"ok\"      -> 'HANGUP'     \"success\" -> 'HANGUP'   \"timeout\"          -> 'NORESPONSE'\n     *               \"decline\" -> 'REJECT'     \"busy\"    -> 'BUSY'     \"failed-transport\" -> 'FAIL'\n     *\n     */\n    termC: function (rt, sessId, rtcId, reason, callback) {\n        _logger.debug(\"termC ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 107\n            }\n        };\n\n        sessId && (rtcOptions.data.sessId = sessId);\n        rtcId && (rtcOptions.data.rtcId = rtcId);\n        reason && (rtcOptions.reason = reason);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * Exit 201\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param WebRTCId\n     * @param sessId\n     * @param success(from,\n     *            rtcOptions)\n     *\n     */\n    exit: function (rt, WebRTCId, sessId, callback) {\n        _logger.debug(\"exit ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 201\n            }\n        };\n\n        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n        sessId && (rtcOptions.data.sessId = sessId);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    },\n\n    /**\n     * DelCfr 2\n     *\n     * @param rt\n     *            {to: , rtKey: , rtflag: , success(result), fail(error)}\n     *\n     * @param callback(from, rtcOptions)\n     *\n     *\n     * @param WebRTCId\n     * @param admtok\n     * @param success(from,\n     *            rtcOptions)\n     *\n     */\n    delCfr: function (rt, WebRTCId, admtok, callback) {\n        _logger.debug(\"delCfr ...\");\n\n        var self = this;\n\n        var rtcOptions = {\n            data: {\n                op: 2\n            }\n        };\n\n        WebRTCId && (rtcOptions.data.WebRTCId = WebRTCId);\n        admtok && (rtcOptions.data.admtok = admtok);\n\n        self.rtcHandler.sendRtcMessage(rt, rtcOptions, callback);\n    }\n};\n\nexports.Api = function (initConfigs) {\n    var self = this;\n\n    _util.extend(true, this, _clazz, initConfigs || {});\n\n\n    function _onRecvRtcMessage(from, rtcOptions, rtkey, tsxId, fromSessionId) {\n        if (rtcOptions.result != 0 && self['onServerError']) {\n            self['onServerError'].call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);\n        } else {\n            var onFunction;\n\n            if (self.events[rtcOptions.op] && (onFunction = self[self.events[rtcOptions.op]])) {\n                onFunction.call(self, from, rtcOptions, rtkey, tsxId, fromSessionId);\n            } else {\n                _logger.info(\"can not handle(recvRtcMessage) the op: \" + rtcOptions.op, rtcOptions);\n            }\n        }\n    }\n\n    this.rtcHandler.onRecvRtcMessage = _onRecvRtcMessage;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/components/api.js","/**\n * WebRTC\n *\n *                              A                   |                                       B\n *                                                  |\n *   1.createMedia:got streamA                      | 1.createMedia:got streamB\n *   2.new RTCPeerConnection: APeerConnection       | 2.new RTCPeerConnection: BPeerConnection\n *   3.APeerConnection.createOffer:got offerA       |\n *      APeerConnection.setLocalDescription(offerA) |\n *      send offerA ---> ---> ---> --->        ---> |\n *                                                  | ---> 3.got offerA | offerA = new RTCSessionDescription(offerA);\n *                                                  | BPeerConnection.setRemoteDescription(offerA)\n *                                                  |\n *                                                  |\n *                                                  | 4.BPeerConnection.createAnswer: got answerB\n *                                                  | BPeerConnection.setLocalDescription(answerB)\n *                                                  | <---- send answerB\n *                                                  | 5.got answerB <--- <--- <--- <---\n *                                                  | answerB = new RTCSessionDescription(answerB)\n *                                                  |\n * APeerConnection.setRemoteDescription(answerB)    |\n *                                                  |\n * 6.got candidateA ---> --->  ---> --->            | ---> got candidateA\n *                                                  | BPeerConnection.addIceCandidate(new RTCIceCandidate(candidateA))\n *                                                  |\n *                                                  |\n *                                                  | got candidateB <--- <--- <--- <---\n *                                                  | <--- 6.got candidateB APeerConnection.addIceCandidate(candidateB)\n *                                                  |\n *                                                  |\n *                                                  | 7. APeerConnection.addStream(streamA)\n *                                                  | 7.BPeerConnection.addStream(streamB)\n *                                                  |\n *                              streamA >>>>>>>>>>> |  <<<<< see A\n *                              seeB <<<<<<<<<<<    | <<<<< streamB\n *                                                  |\n *\n */\nvar _util = require('./utils');\nvar _logger = _util.logger;\n\n\nvar _WebrtcStatistics = {\n    bytesPrev: null,\n    timestampPrev: null,\n    sentBytesPrev: null,\n    sentTimestampPrev: null,\n\n    printStats: function(rtcPeerConnection) {\n        var self = this;\n\n        rtcPeerConnection.getStats(null, function (results) {\n            self.parseRecvStatistics(results, function (name, value) {\n                _logger.info(new Date(), \"RECV \", name, value);\n            }, function (name, value) {\n                _logger.info(new Date(), \"SEND \", name, value);\n            });\n        });\n    },\n\n    stopIntervalPrintStats: function () {\n        var self = this;\n\n        self._printIntervalId &&  window.clearInterval(self._printIntervalId);\n        self._printIntervalId = null;\n    },\n\n    intervalPrintStats: function(rtcPeerConnection, seconds){\n\n    },\n\n    _intervalPrintStats: function(rtcPeerConnection, seconds){\n        var self = this;\n\n        self._printIntervalId &&  window.clearInterval(self._printIntervalId);\n        self._printIntervalId = window.setInterval(function () {\n            self.printStats(rtcPeerConnection);\n        }, seconds * 1000);\n    },\n\n    parseRecvStatistics: function (results, callback, callbackSent) {\n        var self = this;\n\n        // calculate video bitrate\n        var bitrate;\n        var remoteWidth;\n        var remoteHeight;\n\n        var activeCandidatePair = null;\n        var remoteCandidate = null;\n\n        Object.keys(results).forEach(function (result) {\n            var report = results[result];\n            var now = report.timestamp;\n\n\n            if (report.type === 'inboundrtp' && report.mediaType === 'audio') {\n                // firefox calculates the bitrate for us\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=951496\n                bitrate = Math.floor(report.bitrateMean / 1024);\n            } else if (report.type === 'ssrc' && report.bytesReceived ){\n                if(report.mediaType === 'video') {\n                    // remoteWidth = report.googFrameWidthReceived;\n                    // remoteHeight = report.googFrameHeightReceived;\n                    // // chrome does not so we need to do it ourselves\n                    // var bytes = report.bytesReceived;\n                    // if (self.timestampPrev) {\n                    //     bitrate = 8 * (bytes - self.bytesPrev) / (now - self.timestampPrev);\n                    //     bitrate = Math.floor(bitrate);\n                    // }\n                    // self.bytesPrev = bytes;\n                    // self.timestampPrev = now;\n                }else{\n                    // chrome does not so we need to do it ourselves\n                    var bytes = report.bytesReceived;\n                    if (self.timestampPrev) {\n                        bitrate = 8 * (bytes - self.bytesPrev) / (now - self.timestampPrev);\n                        bitrate = Math.floor(bitrate);\n                    }\n                    self.bytesPrev = bytes;\n                    self.timestampPrev = now;\n                }\n            }\n\n            if (report.type === 'candidatepair' && report.selected ||\n                report.type === 'googCandidatePair' &&\n                report.googActiveConnection === 'true') {\n                activeCandidatePair = report;\n            }\n\n            if (report.type === 'outboundrtp' && report.mediaType === 'audio') {\n                callbackSent('audio Bitrate', Math.floor(report.bitrateMean / 1024) + ' kbps');\n            } else if (report.type === 'ssrc' && report.bytesSent &&\n                report.googFrameHeightSent) {\n                // chrome does not so we need to do it ourselves\n                var bytes = report.bytesSent;\n                if (self.sentTimestampPrev) {\n                    var br = 8 * (bytes - self.sentBytesPrev) / (now - self.sentTimestampPrev);\n                    br = Math.floor(br);\n                    callbackSent('audio Bitrate', br + ' kbps');\n                    callbackSent('audio Size', report.googFrameWidthSent + 'x' + report.googFrameHeightSent);\n                }\n                self.sentBytesPrev = bytes;\n                self.sentTimestampPrev = now;\n            }\n\n\n        });\n\n        if (activeCandidatePair && activeCandidatePair.remoteCandidateId) {\n            remoteCandidate = results[activeCandidatePair.remoteCandidateId];\n        }\n        if (remoteCandidate && remoteCandidate.ipAddress &&\n            remoteCandidate.portNumber) {\n            callback('Peer', remoteCandidate.ipAddress + ':' + remoteCandidate.portNumber);\n        }\n\n        callback('audio Bitrate', bitrate + ' kbps');\n\n        if (remoteHeight) {\n            callback('audio Size', remoteWidth + 'x' + remoteHeight);\n        }\n    }\n}\n\nvar WebrtcStatisticsHelper = function (cfg) {\n    _util.extend(this, _WebrtcStatistics, cfg || {});\n};\n\nvar webrtcStatisticsHelper = new WebrtcStatisticsHelper();\n\nvar _SDPSection = {\n    headerSection: null,\n\n    audioSection: null,\n    videoSection: null,\n\n\n    _parseHeaderSection: function (sdp) {\n        var index = sdp.indexOf('m=audio');\n        if (index >= 0) {\n            return sdp.slice(0, index);\n        }\n\n        index = sdp.indexOf('m=video');\n        if (index >= 0) {\n            return sdp.slice(0, index);\n        }\n\n        return sdp;\n    },\n\n    _parseAudioSection: function (sdp) {\n        var index = sdp.indexOf('m=audio');\n        if (index >= 0) {\n            var endIndex = sdp.indexOf('m=video');\n            return sdp.slice(index, endIndex < 0 ? sdp.length : endIndex);\n        }\n    },\n\n    _parseVideoSection: function (sdp) {\n        var index = sdp.indexOf('m=video');\n        if (index >= 0) {\n            return sdp.slice(index);\n        }\n    },\n\n    spiltSection: function (sdp) {\n        var self = this;\n\n        self.headerSection = self._parseHeaderSection(sdp);\n        self.audioSection = self._parseAudioSection(sdp);\n        self.videoSection = self._parseVideoSection(sdp);\n    },\n\n    removeSSRC: function (section) {\n        var arr = [];\n\n        var _arr = section.split(/a=ssrc:[^\\n]+/g);\n        for (var i = 0; i < _arr.length; i++) {\n            _arr[i] != '\\n' && arr.push(_arr[i]);\n        }\n        // arr.push('');\n\n        return arr.join('\\n');\n    },\n\n    removeField_msid: function (section) {\n        var arr = [];\n\n        var _arr = section.split(/a=msid:[^\\n]+/g);\n        for (var i = 0; i < _arr.length; i++) {\n            _arr[i] != '\\n' && arr.push(_arr[i]);\n        }\n        // arr.push('');\n\n        section = arr.join('\\n');\n        arr = [];\n\n        _arr = section.split(/[\\n]+/g);\n        for (var i = 0; i < _arr.length; i++) {\n            (_arr[i] != '\\n') && arr.push(_arr[i]);\n        }\n\n        return arr.join('\\n');\n    },\n\n    updateHeaderMsidSemantic: function (wms) {\n\n        var self = this;\n\n        var line = \"a=msid-semantic: WMS \" + wms;\n\n        var _arr = self.headerSection.split(/a=msid\\-semantic: WMS.*/g);\n        var arr = [];\n        switch (_arr.length) {\n            case 1:\n                arr.push(_arr[0]);\n                break;\n            case 2:\n                arr.push(_arr[0]);\n                arr.push(line);\n                arr.push('\\n');\n                break;\n            case 3:\n                arr.push(_arr[0]);\n                arr.push(line);\n                arr.push('\\n');\n                arr.push(_arr[2]);\n                arr.push('\\n');\n                break;\n        }\n\n        return self.headerSection = arr.join('');\n    },\n\n    updateAudioSSRCSection: function (ssrc, cname, msid, label) {\n        var self = this;\n\n        self.audioSection && (self.audioSection = self.removeSSRC(self.audioSection));\n        self.audioSection && (self.audioSection = self.removeField_msid(self.audioSection));\n        self.audioSection && (self.audioSection = self.audioSection + self.ssrcSection(ssrc, cname, msid, label));\n    },\n\n\n    updateVideoSSRCSection: function (ssrc, cname, msid, label) {\n        var self = this;\n\n        self.videoSection && (self.videoSection = self.removeSSRC(self.videoSection));\n        self.videoSection && (self.videoSection = self.removeField_msid(self.videoSection));\n        self.videoSection && (self.videoSection = self.videoSection + self.ssrcSection(ssrc, cname, msid, label))\n    },\n\n    getUpdatedSDP: function () {\n        var self = this;\n\n        var sdp = \"\";\n\n        self.headerSection && (sdp += self.headerSection);\n        self.audioSection && (sdp += self.audioSection);\n        self.videoSection && (sdp += self.videoSection);\n\n        return sdp;\n    },\n\n    parseMsidSemantic: function (header) {\n        var self = this;\n\n        var regexp = /a=msid\\-semantic:\\s*WMS (\\S+)/ig;\n        var arr = self._parseLine(header, regexp);\n\n        arr && arr.length == 2 && (self.msidSemantic = {\n            line: arr[0],\n            WMS: arr[1]\n        });\n\n        return self.msidSemantic;\n    },\n\n    ssrcSection: function (ssrc, cname, msid, label) {\n        var lines = [\n            'a=ssrc:' + ssrc + ' cname:' + cname,\n            'a=ssrc:' + ssrc + ' msid:' + msid + ' ' + label,\n            'a=ssrc:' + ssrc + ' mslabel:' + msid,\n            'a=ssrc:' + ssrc + ' label:' + label,\n            ''\n        ];\n\n        return lines.join('\\n');\n    },\n\n    parseSSRC: function (section) {\n        var self = this;\n\n        var regexp = new RegExp(\"a=(ssrc):(\\\\d+) (\\\\S+):(\\\\S+)\", \"ig\");\n\n        var arr = self._parseLine(section, regexp);\n        if (arr) {\n            var ssrc = {\n                lines: [],\n                updateSSRCSection: self.ssrcSection\n            };\n\n            for (var i = 0; i < arr.length; i++) {\n                var e = arr[i];\n                if (e.indexOf(\"a=ssrc\") >= 0) {\n                    ssrc.lines.push(e);\n                } else {\n                    switch (e) {\n                        case 'ssrc':\n                        case 'cname':\n                        case 'msid':\n                        case 'mslabel':\n                        case 'label':\n                            ssrc[e] = arr[++i];\n                    }\n                }\n            }\n\n            return ssrc;\n        }\n    },\n\n    _parseLine: function (str, regexp) {\n        var arr = [];\n\n        var _arr;\n        while ((_arr = regexp.exec(str)) != null) {\n            for (var i = 0; i < _arr.length; i++) {\n                arr.push(_arr[i]);\n            }\n        }\n\n        if (arr.length > 0) {\n            return arr;\n        }\n    },\n};\n\nvar SDPSection = function (sdp) {\n    _util.extend(this, _SDPSection);\n    this.spiltSection(sdp);\n};\n\n\n/**\n * Abstract\n */\nvar _WebRTC = {\n    streamType: \"VIDEO\", // VIDEO or VOICE\n\n    mediaStreamConstaints: {\n        audio: true,\n        video: true\n    },\n\n    localStream: null,\n    rtcPeerConnection: null,\n\n    offerOptions: {\n        offerToReceiveAudio: 1,\n        offerToReceiveVideo: 1\n    },\n\n\n    createMedia: function (constaints, onGotStream) {\n        var self = this;\n\n        if (constaints && (typeof constaints === \"function\")) {\n            onGotStream = constaints;\n            constaints = null;\n        }\n\n        _logger.debug('[WebRTC-API] begin create media ......');\n\n        function gotStream(stream) {\n            _logger.debug('[WebRTC-API] got local stream');\n\n            self.localStream = stream;\n\n            var videoTracks = self.localStream.getVideoTracks();\n            var audioTracks = self.localStream.getAudioTracks();\n\n            if (videoTracks.length > 0) {\n                _logger.debug('[WebRTC-API] Using video device: ' + videoTracks[0].label);\n            }\n            if (audioTracks.length > 0) {\n                _logger.debug('[WebRTC-API] Using audio device: ' + audioTracks[0].label);\n            }\n\n            onGotStream ? onGotStream(self, stream, self.streamType) : self.onGotStream(stream, self.streamType);\n        }\n\n        return navigator.mediaDevices.getUserMedia(constaints || self.mediaStreamConstaints)\n            .then(gotStream)\n            .then(self.onCreateMedia)\n            .catch(function (e) {\n                _logger.debug('[WebRTC-API] getUserMedia() error: ', e);\n                self.onError(e);\n            });\n    },\n\n    setLocalVideoSrcObject: function (stream) {\n        this.onGotLocalStream(stream, this.streamType);\n        _logger.debug('[WebRTC-API] you can see yourself !');\n    },\n\n    createRtcPeerConnection: function (iceServerConfig) {\n        _logger.debug('[WebRTC-API] begin create RtcPeerConnection ......');\n\n        var self = this;\n\n        // if (iceServerConfig && iceServerConfig.iceServers) {\n        // } else {\n        //     iceServerConfig = null;\n        // }\n\n        if (iceServerConfig){ //reduce icecandidate number:add default value\n            !iceServerConfig.iceServers && (iceServerConfig.iceServers = []);\n\n            iceServerConfig.rtcpMuxPolicy = \"require\";\n            iceServerConfig.bundlePolicy = \"max-bundle\";\n\n            //iceServerConfig.iceTransportPolicy = 'relay';\n            if(iceServerConfig.relayOnly){\n                iceServerConfig.iceTransportPolicy = 'relay';\n            }\n        } else {\n            iceServerConfig = null;\n        }\n        _logger.debug('[WebRTC-API] RtcPeerConnection config:', iceServerConfig);\n\n        self.startTime = window.performance.now();\n\n        var rtcPeerConnection = self.rtcPeerConnection = new RTCPeerConnection(iceServerConfig);\n        _logger.debug('[WebRTC-API] Created local peer connection object', rtcPeerConnection);\n\n\n        rtcPeerConnection.onicecandidate = function (event) {\n            //reduce icecandidate number: don't deal with tcp, udp only\n            if (event.type == \"icecandidate\" && ((event.candidate == null) || / tcp /.test(event.candidate.candidate))) {\n                return;\n            }\n            self.onIceCandidate(event);\n        };\n\n        rtcPeerConnection.onicestatechange = function (event) {\n            self.onIceStateChange(event);\n        };\n\n        rtcPeerConnection.oniceconnectionstatechange = function (event) {\n            self.onIceStateChange(event);\n\n            if(\"connected\" == event.target.iceConnectionState){\n                webrtcStatisticsHelper.intervalPrintStats(rtcPeerConnection, 1);\n            }\n\n            if(\"closed\" == event.target.iceConnectionState) {\n                webrtcStatisticsHelper.stopIntervalPrintStats();\n            }\n        };\n\n        rtcPeerConnection.onaddstream = function (event) {\n            self._onGotRemoteStream(event);\n        };\n    },\n\n    _uploadLocalStream: function () {\n        this.rtcPeerConnection.addStream(this.localStream);\n        _logger.debug('[WebRTC-API] Added local stream to RtcPeerConnection');\n    },\n\n    createOffer: function (onCreateOfferSuccess, onCreateOfferError) {\n        var self = this;\n\n        self._uploadLocalStream();\n\n        _logger.debug('[WebRTC-API] createOffer start...');\n\n        return self.rtcPeerConnection.createOffer(self.offerOptions).then(\n            function (desc) {\n                self.offerDescription = desc;\n\n                _logger.debug('[WebRTC-API] Offer ');//_logger.debug('from \\n' + desc.sdp);\n                _logger.debug('[WebRTC-API] setLocalDescription start');\n\n                self.rtcPeerConnection.setLocalDescription(desc).then(\n                    self.onSetLocalSessionDescriptionSuccess,\n                    self.onSetSessionDescriptionError\n                ).then(function () {\n                    (onCreateOfferSuccess || self.onCreateOfferSuccess)(desc);\n                });\n            },\n            (onCreateOfferError || self.onCreateSessionDescriptionError)\n        );\n    },\n\n    createPRAnswer: function (onCreatePRAnswerSuccess, onCreatePRAnswerError) {\n        var self = this;\n\n        _logger.info(' createPRAnswer start');\n        // Since the 'remote' side has no media stream we need\n        // to pass in the right constraints in order for it to\n        // accept the incoming offer of audio and video.\n        return self.rtcPeerConnection.createAnswer().then(\n            function (desc) {\n                _logger.debug('[WebRTC-API] _____________PRAnswer ', desc.sdp);//_logger.debug('from :\\n' + desc.sdp);\n\n                desc.type = \"pranswer\";\n                desc.sdp = desc.sdp.replace(/a=recvonly/g, 'a=inactive');\n\n\n                self.prAnswerDescription = desc;\n\n                _logger.debug('[WebRTC-API] inactive PRAnswer ', desc.sdp);//_logger.debug('from :\\n' + desc.sdp);\n                _logger.debug('[WebRTC-API] setLocalDescription start');\n\n                self.rtcPeerConnection.setLocalDescription(desc).then(\n                    self.onSetLocalSuccess,\n                    self.onSetSessionDescriptionError\n                ).then(function () {\n                    var sdpSection = new SDPSection(desc.sdp);\n                    sdpSection.updateHeaderMsidSemantic(\"MS_0000\");\n                    sdpSection.updateAudioSSRCSection(1000, \"CHROME0000\", \"MS_0000\", \"LABEL_AUDIO_1000\");\n                    sdpSection.updateVideoSSRCSection(2000, \"CHROME0000\", \"MS_0000\", \"LABEL_VIDEO_2000\");\n\n                    desc.sdp = sdpSection.getUpdatedSDP();\n\n                    _logger.debug('[WebRTC-API] Send PRAnswer ', desc.sdp);//_logger.debug('from :\\n' + desc.sdp);\n\n                    (onCreatePRAnswerSuccess || self.onCreatePRAnswerSuccess)(desc);\n                });\n            },\n            (onCreatePRAnswerError || self.onCreateSessionDescriptionError)\n        );\n    },\n\n    createAnswer: function (onCreateAnswerSuccess, onCreateAnswerError) {\n        var self = this;\n\n        self._uploadLocalStream();\n\n        _logger.info('[WebRTC-API] createAnswer start');\n        // Since the 'remote' side has no media stream we need\n        // to pass in the right constraints in order for it to\n        // accept the incoming offer of audio and video.\n        return self.rtcPeerConnection.createAnswer().then(\n            function (desc) {\n                _logger.debug('[WebRTC-API] _____________________Answer ', desc.sdp);//_logger.debug('from :\\n' + desc.sdp);\n\n                desc.type = 'answer';\n\n                if(WebIM.WebRTC.supportPRAnswer){\n                    var sdpSection = new SDPSection(desc.sdp);\n                    var ms = sdpSection.parseMsidSemantic(sdpSection.headerSection);\n                    if(ms.WMS == '*') {\n                        sdpSection.updateHeaderMsidSemantic(ms.WMS = \"MS_0000\");\n                    }\n                    var audioSSRC = sdpSection.parseSSRC(sdpSection.audioSection);\n                    var videoSSRC = sdpSection.parseSSRC(sdpSection.videoSection);\n\n                    sdpSection.updateAudioSSRCSection(1000, \"CHROME0000\", ms.WMS, audioSSRC.label || \"LABEL_AUDIO_1000\");\n                    if(videoSSRC){\n                        sdpSection.updateVideoSSRCSection(2000, \"CHROME0000\", ms.WMS, videoSSRC.label || \"LABEL_VIDEO_2000\");\n                    }\n                    // mslabel cname\n\n                    desc.sdp = sdpSection.getUpdatedSDP();\n                }\n\n\n                self.answerDescription = desc;\n\n                _logger.debug('[WebRTC-API] Answer ', desc.sdp);//_logger.debug('from :\\n' + desc.sdp);\n                _logger.debug('[WebRTC-API] setLocalDescription start');\n\n                self.rtcPeerConnection.setLocalDescription(desc).then(\n                    self.onSetLocalSuccess,\n                    self.onSetSessionDescriptionError\n                ).then(function () {\n                    if(WebIM.WebRTC.supportPRAnswer){\n                        var sdpSection = new SDPSection(desc.sdp);\n\n                        sdpSection.updateHeaderMsidSemantic(\"MS_0000\");\n                        sdpSection.updateAudioSSRCSection(1000, \"CHROME0000\", \"MS_0000\", \"LABEL_AUDIO_1000\");\n                        sdpSection.updateVideoSSRCSection(2000, \"CHROME0000\", \"MS_0000\", \"LABEL_VIDEO_2000\");\n\n                        desc.sdp = sdpSection.getUpdatedSDP();\n                    }\n\n                    _logger.debug('[WebRTC-API] Send Answer ', desc.sdp);//_logger.debug('from :\\n' + desc.sdp);\n\n                    (onCreateAnswerSuccess || self.onCreateAnswerSuccess)(desc);\n                });\n            },\n            (onCreateAnswerError || self.onCreateSessionDescriptionError)\n        );\n    },\n\n    close: function () {\n        var self = this;\n        try {\n            webrtcStatisticsHelper.stopIntervalPrintStats();\n\n            self.rtcPeerConnection && self.rtcPeerConnection.close();\n        } catch (e) {\n        }\n\n        if (self.localStream) {\n            self.localStream.getTracks().forEach(function (track) {\n                track.stop();\n            });\n        }\n        self.localStream = null;\n    },\n\n    addIceCandidate: function (candidate) {\n        var self = this;\n\n        if (!self.rtcPeerConnection) {\n            return;\n        }\n\n\n        _logger.debug('[WebRTC-API] Add ICE candidate: \\n', candidate);\n\n        var _cands = _util.isArray(candidate) ? candidate : [];\n        !_util.isArray(candidate) && _cands.push(candidate);\n\n        for (var i = 0; i < _cands.length; i++) {\n            candidate = _cands[i];\n\n            self.rtcPeerConnection.addIceCandidate(new RTCIceCandidate(candidate)).then(\n                self.onAddIceCandidateSuccess,\n                self.onAddIceCandidateError\n            );\n        }\n    },\n\n    setRemoteDescription: function (desc) {\n        var self = this;\n\n        _logger.debug('[WebRTC-API] setRemoteDescription start. ');\n\n        desc.sdp = desc.sdp.replace(/UDP\\/TLS\\/RTP\\/SAVPF/g, \"RTP/SAVPF\");\n        _logger.debug('[WebRTC-API] setRemoteDescription.', desc);\n\n        desc = new RTCSessionDescription(desc);\n\n        return self.rtcPeerConnection.setRemoteDescription(desc).then(\n            self.onSetRemoteSuccess,\n            self.onSetSessionDescriptionError\n        );\n    },\n\n    iceConnectionState: function () {\n        var self = this;\n\n        return self.rtcPeerConnection.iceConnectionState;\n    },\n\n    onCreateMedia: function () {\n        _logger.debug('[WebRTC-API] media created.');\n    },\n\n    _onGotRemoteStream: function (event) {\n        _logger.debug('[WebRTC-API] onGotRemoteStream.', event);\n\n        event.stream.getAudioTracks()[0].enabled = true;\n        event.stream.getVideoTracks()[0] && (event.stream.getVideoTracks()[0].enabled = (this.streamType == \"VIDEO\"));\n\n        this.onGotRemoteStream(event.stream, this.streamType);\n        _logger.debug('[WebRTC-API] received remote stream, you will see the other.');\n    },\n\n    onGotStream: function (stream, streamType) {\n        _logger.debug('[WebRTC-API] on got a local stream : ' + streamType);\n    },\n\n    onSetRemoteSuccess: function () {\n        _logger.info('[WebRTC-API] onSetRemoteSuccess complete');\n    },\n\n    onSetLocalSuccess: function () {\n        _logger.info('[WebRTC-API] setLocalDescription complete');\n    },\n\n    onAddIceCandidateSuccess: function () {\n        _logger.debug('[WebRTC-API] addIceCandidate success');\n    },\n\n    onAddIceCandidateError: function (error) {\n        _logger.debug('[WebRTC-API] failed to add ICE Candidate: ' + error.toString());\n    },\n\n    onIceCandidate: function (event) {\n        _logger.debug('[WebRTC-API] onIceCandidate : ICE candidate: \\n' + event.candidate);\n    },\n\n    onIceStateChange: function (event) {\n        _logger.debug('[WebRTC-API] onIceStateChange : ICE state change event: ', event);\n    },\n\n    onCreateSessionDescriptionError: function (error) {\n        _logger.error('[WebRTC-API] Failed to create session description: ' + error.toString());\n    },\n\n    onCreateOfferSuccess: function (desc) {\n        _logger.debug('[WebRTC-API] create offer success');\n    },\n\n    onCreatePRAnswerSuccess: function (desc) {\n        _logger.debug('[WebRTC-API] create answer success');\n    },\n\n    onCreateAnswerSuccess: function (desc) {\n        _logger.debug('[WebRTC-API] create answer success');\n    },\n\n    onSetSessionDescriptionError: function (error) {\n        _logger.error('[WebRTC-API] onSetSessionDescriptionError : Failed to set session description: ' + error.toString());\n    },\n\n    onSetLocalSessionDescriptionSuccess: function () {\n        _logger.debug('[WebRTC-API] onSetLocalSessionDescriptionSuccess : setLocalDescription complete');\n    }\n\n\n};\n\nmodule.exports = function (initConfigs) {\n    _util.extend(true, this, _WebRTC, initConfigs || {});\n};\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/components/webrtc.js","/**\n * P2P\n */\nvar _util = require('./utils');\nvar RouteTo = require('./api').RouteTo;\nvar _logger = _util.logger;\n\n\nvar P2PRouteTo = RouteTo({\n    success: function (result) {\n        _logger.debug(\"iq to server success\", result);\n    },\n    fail: function (error) {\n        _logger.debug(\"iq to server error\", error);\n    }\n});\n\n\nvar CommonPattern = {\n    _pingIntervalId: null,\n    _p2pConfig: null,\n    _rtcCfg: null,\n    _rtcCfg2: null,\n    _rtKey: null,\n    _rtFlag: null,\n\n\n    webRtc: null,\n    api: null,\n\n    callee: null,\n\n\n    isCaller: false,\n    accepted: false,\n\n    setLocalSDP: false,\n    setRemoteSDP: false,\n\n    hangup: false,\n\n\n    init: function () {\n        var self = this;\n\n        self.api.onPing = function () {\n            self._onPing.apply(self, arguments);\n        };\n        self.api.onTcklC = function () {\n            self._onTcklC.apply(self, arguments);\n        };\n        self.api.onAcptC = function () {\n            self._onAcptC.apply(self, arguments);\n        };\n        self.api.onAnsC = function () {\n            self._onAnsC.apply(self, arguments);\n        };\n        self.api.onTermC = function () {\n            self._onTermC.apply(self, arguments);\n        };\n        self.api.onEvJoin = function() {\n            self._onEvJoin.apply(self, arguments);\n        };\n        self.api.onStreamControl = function() {\n            self._onStreamControl.apply(self, arguments);\n        };\n        self.webRtc.onIceCandidate = function () {\n            self._onIceCandidate.apply(self, arguments);\n        };\n        self.webRtc.onIceStateChange = function () {\n            self._onIceStateChange.apply(self, arguments);\n        };\n    },\n\n    _ping: function () {\n        var self = this;\n\n        var index = 0;\n\n        function ping() {\n            var rt = new P2PRouteTo({\n                to: self.callee,\n                rtKey: self._rtKey\n            });\n\n            self.api.ping(rt, self._sessId, function (from, rtcOptions) {\n                _logger.debug(\"ping result\", rtcOptions);\n\n            });\n            // self.api.streamControl(rt, self._sessId, \"rtcId\", (index++) % 4, function (from, rtcOptions) {\n            //     _logger.debug(\"streamControl result\", rtcOptions);\n            //\n            // });\n        }\n\n        self._pingIntervalId = window.setInterval(ping, 50000);\n    },\n\n    _onPing: function (from, options, rtkey, tsxId, fromSid) {\n        _logger.debug('_onPing from', fromSid);\n    },\n\n    initC: function (mediaStreamConstaints, accessSid) {\n        var self = this;\n        self.sid = accessSid;\n\n        self.isCaller = true;\n        self.accepted = false;\n        self.setLocalSDP = false;\n        self.setRemoteSDP = false;\n        self.hangup = false;\n\n        self.streamType = mediaStreamConstaints.audio && mediaStreamConstaints.video ? \"VIDEO\" : \"VOICE\";\n\n        self.createLocalMedia(mediaStreamConstaints);\n    },\n\n    createLocalMedia: function (mediaStreamConstaints) {\n        var self = this;\n\n        this.webRtc.createMedia(mediaStreamConstaints, function (webrtc, stream) {\n            webrtc.setLocalVideoSrcObject(stream);\n\n            self.webRtc.createRtcPeerConnection(self._rtcCfg);\n\n            self.webRtc.createOffer(function (offer) {\n                self._onGotWebRtcOffer(offer);\n            });\n        });\n    },\n\n    _onGotWebRtcOffer: function (offer) {\n        var self = this;\n\n        var rt = new P2PRouteTo({\n            sid: self.sid,\n            to: self.callee,\n            rtKey: self._rtKey\n        });\n\n        self.api.initC(rt, self.streamType, null, null, self._sessId, self._rtcId, null, null, offer, null, self._rtcCfg2, null, function (from, rtcOptions) {\n            _logger.debug(\"initc result\", rtcOptions);\n        });\n\n        self.setLocalSDP = true;\n\n        self._ping();\n    },\n\n    _onAcptC: function (from, options) {\n        var self = this;\n\n        if (options.ans && options.ans == 1) {\n            _logger.info(\"[WebRTC-API] _onAcptC : 104, ans = 1, it is a answer. will onAcceptCall\");\n            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n            self._onAnsC(from, options);\n        } else if (!WebIM.WebRTC.supportPRAnswer) {\n            _logger.info(\"[WebRTC-API] _onAcptC : not supported pranswer. drop it. will onAcceptCall\");\n\n            self.setRemoteSDP = false;\n            self._handRecvCandsOrSend(from, options);\n\n            self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n        } else {\n            _logger.info(\"[WebRTC-API] _onAcptC : recv pranswer. \");\n\n            if (options.sdp || options.cands) {\n                // options.sdp && (options.sdp.type = \"pranswer\");\n                options.sdp && self.webRtc.setRemoteDescription(options.sdp);\n\n                self.setRemoteSDP = true;\n                self._handRecvCandsOrSend(from, options);\n\n                self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n            }\n        }\n    },\n\n    _onEvJoin: function (from, options, rtkey, tsxId, fromSid) {\n        var self = this;\n\n        _logger.debug('_onEvJoin from', fromSid, from);\n\n        self.onAcceptCall(from, options, options.enableVoice !== false, options.enableVideo !== false);\n    },\n\n    onAcceptCall: function (from, options, enableVoice, enableVideo) {\n\n    },\n\n    __onVoiceOrVideo: function(from, options, fromSid){\n        var self = this;\n\n        options.enableVoice === false ? (self.onOtherUserOpenVoice(from, false)) : (self.onOtherUserOpenVoice(from, true));\n        options.enableVideo === false ? (self.onOtherUserOpenVideo(from, false)) : (self.onOtherUserOpenVideo(from, true));\n    },\n\n    /*\n     * { verison : MSYNC_V1, compress_algorimth : 0, command : SYNC, payload : { meta : { id : 2326, to : easemob-demo#chatdemoui_xyj002@easemob.com, ns : CONFERENCE, payload : { session_id : xyj0011494320598055, operation : MEDIA_REQUEST, peer_name : xyj001, route_flag : 1, route_key : --X--, content : {\"op\":400,\"callVersion\":\"2.0.0\",\"sessId\":\"128542826909667328\",\"rtcId\":\"Channel1494320598056\",\"tsxId\":\"1494320622866-6\",\"controlType\":0}, control_type : PAUSE_VOICE } } } }\n     * PAUSE_VOICE(0, 0), RESUME_VOICE(1, 1), PAUSE_VIDEO(2, 2), RESUME_VIDEO(3, 3)\n     *\n     */\n    _onStreamControl: function (from, options, rtkey, tsxId, fromSid){\n        var self = this;\n        var controlType = options.controlType;\n\n        controlType === 0 && (self.onOtherUserOpenVoice(from, false));\n        controlType === 1 && (self.onOtherUserOpenVoice(from, true));\n        controlType === 2 && (self.onOtherUserOpenVideo(from, false));\n        controlType === 3 && (self.onOtherUserOpenVideo(from, true));\n\n        self.onStreamControl(from, options, rtkey, tsxId, fromSid);\n    },\n    onStreamControl: function (from, options, rtkey, tsxId, fromSid){\n\n    },\n\n    onOtherUserOpenVoice: function (from, opened){\n        _logger.debug(\"from open:\", opened, \" voice .\", from)\n    },\n    onOtherUserOpenVideo: function (from, opened){\n        _logger.debug(\"from open:\", opened, \" voideo .\", from)\n    },\n\n\n    _onAnsC: function (from, options) { // answer\n        var self = this;\n\n        _logger.info(\"[WebRTC-API] _onAnsC : recv answer. \");\n\n        self.accepted = true;\n\n        options.sdp && self.webRtc.setRemoteDescription(options.sdp);\n\n        self.setRemoteSDP = true;\n        self._handRecvCandsOrSend(from, options);\n\n\n        self.__onVoiceOrVideo(from, options);\n    },\n\n\n    _onInitC: function (from, options, rtkey, tsxId, fromSid) {\n        var self = this;\n\n        self.isCaller = false;\n        self.accepted = false;\n        self.setLocalSDP = false;\n        self.setRemoteSDP = false;\n        self.hangup = false;\n\n        self.callee = from;\n        self._rtcCfg2 = options.rtcCfg;\n        self._rtKey = rtkey;\n        self._tsxId = tsxId;\n        self._fromSid = fromSid;\n\n        self._rtcId = options.rtcId;\n        self._sessId = options.sessId;\n\n        self.streamType = options.streamType;\n\n        self.webRtc.createRtcPeerConnection(self._rtcCfg2);\n\n        options.sdp && _logger.debug(options.sdp.sdp);\n\n        options.sdp && (self.webRtc.setRemoteDescription(options.sdp).then(function () {\n\n            self.setRemoteSDP = true;\n            self._handRecvCandsOrSend(from, options);\n\n            /*\n             * chrome 版本 大于 50时，可以使用pranswer。\n             * 小于50 不支持pranswer，此时处理逻辑是，直接进入振铃状态\n             *\n             */\n            if (WebIM.WebRTC.supportPRAnswer) {\n                self.webRtc.createPRAnswer(function (prAnswer) {\n                    self._onGotWebRtcPRAnswer(prAnswer);\n\n                    setTimeout(function () { //由于 chrome 在 pranswer时，ice状态只是 checking，并不能像sdk那样 期待 connected 振铃；所以目前改为 发送完pranswer后，直接振铃\n                        _logger.info(\"[WebRTC-API] onRinging : after send pranswer. \", self.callee);\n                        self.onRinging(self.callee, self.streamType);\n                    }, 500);\n                });\n            } else {\n                setTimeout(function () {\n                    _logger.info(\"[WebRTC-API] onRinging : After iniC, cause by: not supported pranswer. \", self.callee);\n                    self.onRinging(self.callee, self.streamType);\n                }, 500)\n                self._ping();\n            }\n        }));\n    },\n\n\n    _onGotWebRtcPRAnswer: function (prAnswer) {\n        var self = this;\n\n        var rt = new P2PRouteTo({\n            //tsxId: self._tsxId,\n            to: self.callee,\n            rtKey: self._rtKey\n        });\n\n        //self.api.acptC(rt, self._sessId, self._rtcId, prAnswer, null, 1);\n        self.api.acptC(rt, self._sessId, self._rtcId, prAnswer);\n\n        self.setLocalSDP = true;\n        self._handRecvCandsOrSend();\n\n        self._ping();\n    },\n\n    onRinging: function (caller, streamType) {\n    },\n\n    accept: function () {\n        var self = this;\n\n        function createAndSendAnswer() {\n            _logger.info(\"createAndSendAnswer : ...... \");\n\n            self.webRtc.createAnswer(function (answer) {\n                var rt = new P2PRouteTo({\n                    //tsxId: self._tsxId,\n                    to: self.callee,\n                    rtKey: self._rtKey\n                });\n\n                if (WebIM.WebRTC.supportPRAnswer) {\n                    self.api.ansC(rt, self._sessId, self._rtcId, answer);\n                } else {\n                    self.api.acptC(rt, self._sessId, self._rtcId, answer, null, 1);\n                }\n\n                if (!WebIM.WebRTC.supportPRAnswer) {\n                    self.setLocalSDP = true;\n                }\n                self._handRecvCandsOrSend();\n\n                self.accepted = true;\n            });\n        }\n\n        var constaints = {\n            audio: true\n        };\n        if(self.streamType == \"VIDEO\"){\n            constaints.video = true;\n        }\n\n        self.webRtc.createMedia(constaints, function (webrtc, stream) {\n            webrtc.setLocalVideoSrcObject(stream);\n\n            createAndSendAnswer();\n        });\n    },\n\n    _handRecvCandsOrSend: function (from, options) {\n        var self = this;\n\n        setTimeout(function () {\n            self._onTcklC(from, options);\n        }, 50);\n\n        setTimeout(function () {\n            self._onIceCandidate();\n        }, 50);\n    },\n\n    _onTcklC: function (from, options) { // setRemoteSDP，才可以添加 添加 对方 cands\n        var self = this;\n\n        // options.sdp && self.webRtc.setRemoteDescription(options.sdp);\n\n        if (self.setRemoteSDP) {\n            _logger.info(\"[WebRTC-API] recv and add cands.\");\n\n            self._recvCands && self._recvCands.length > 0 && self.webRtc.addIceCandidate(self._recvCands);\n            self._recvCands && self._recvCands.length > 0 && (self._recvCands = []);\n            options && options.cands && self.webRtc.addIceCandidate(options.cands);\n        } else if (options && options.cands && options.cands.length > 0) {\n            for (var i = 0; i < options.cands.length; i++) {\n                (self._recvCands || (self._recvCands = [])).push(options.cands[i]);\n            }\n            _logger.debug(\"[_onTcklC] temporary memory[recv] ice candidate. util setRemoteSDP = true\");\n        }\n    },\n\n    _onIceStateChange: function (event) {\n        var self = this;\n        event && _logger.debug(\"[WebRTC-API] \" + self.webRtc.iceConnectionState() + \" |||| ice state is \" + event.target.iceConnectionState);\n\n\n        if(event && event.target.iceConnectionState == \"closed\"){\n            self.setLocalSDP = false;\n            self.setRemoteSDP = false;\n        }\n\n        self.api.onIceConnectionStateChange(self.webRtc.iceConnectionState());\n    },\n\n    _onIceCandidate: function (event) { //在本地sdp set 发送完成后，发送 cands\n        var self = this;\n\n        if (self.setLocalSDP) {\n            function sendIceCandidate(candidate) {\n                _logger.debug(\"send ice candidate...\");\n\n                var rt = new P2PRouteTo({\n                    to: self.callee,\n                    rtKey: self._rtKey\n                });\n\n                if (candidate) {\n                    self.api.tcklC(rt, self._sessId, self._rtcId, null, candidate);\n                }\n            }\n\n            if (self._cands && self._cands.length > 0) {\n\n                sendIceCandidate(self._cands);\n\n                self._cands = [];\n            }\n            event && event.candidate && sendIceCandidate(event.candidate);\n        } else {\n            event && event.candidate && (self._cands || (self._cands = [])).push(event.candidate);\n            _logger.debug(\"[_onIceCandidate] temporary memory[send] ice candidate. util setLocalSDP = true\");\n        }\n    },\n\n\n    termCall: function (reason) {\n        var self = this;\n\n        self._pingIntervalId && window.clearInterval(self._pingIntervalId);\n\n        var rt = new P2PRouteTo({\n            to: self.callee,\n            rtKey: self._rtKey\n        });\n\n        var sendReason;\n        reason || (!self.isCaller && !self.accepted && (sendReason = 'decline')) || (sendReason = 'success');\n\n        self.hangup || self.api.termC(rt, self._sessId, self._rtcId, sendReason);\n\n        self.webRtc.close();\n\n        self.hangup = true;\n\n        self.setLocalSDP = false;\n        self.setRemoteSDP = false;\n\n        self.onTermCall(reason);\n    },\n\n    /**\n     *\n     * @param from\n     * @param options\n     * @param options.reason\n     *               \"ok\"      -> 'HANGUP'     \"success\" -> 'HANGUP'   \"timeout\"          -> 'NORESPONSE'\n     *               \"decline\" -> 'REJECT'     \"busy\"    -> 'BUSY'     \"failed-transport\" -> 'FAIL'\n     * @private\n     */\n    _onTermC: function (from, options) {\n        _logger.debug(\"[_onTermC] options.reason = \" + options.reason);\n\n        var self = this;\n\n        self.hangup = true;\n\n        self.setLocalSDP = false;\n        self.setRemoteSDP = false;\n\n        self.termCall(options.reason);\n\n    },\n\n    onTermCall: function () {\n        //to be overwrited by call.listener.onTermCall\n    }\n};\n\nmodule.exports = function (initConfigs) {\n    var self = this;\n\n    _util.extend(true, this, CommonPattern, initConfigs || {});\n\n    self.init();\n};\n\n/**\n * TODO: Conference\n */\n\n\n\n// WEBPACK FOOTER //\n// ./webrtc/src/components/p2p.js"],"sourceRoot":""}